File: ./Describe.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.PlayerComponents;

namespace text_survival
{
    public static class Describe
    {
        public static void DescribeGear(InventoryManager inv)
        {
            if (inv.IsArmed)
            {
                Output.Write("Weapon => ");
                DescribeItem(inv.Weapon);
            }
            foreach (Armor armor in inv.Armor)
            {
                Output.Write(armor.EquipSpot, " => ");
                DescribeItem(armor);
            }
            if (inv.HeldItem is not null)
            {
                Output.Write("Held Item => ");
                DescribeItem(inv.HeldItem);
            }
        }

        public static void DescribeItem(Item item)
        {
            Output.Write(item, " => ", item.Description, " ");
            if (item is Weapon weapon)
            {
                Output.Write("Damage: ", weapon.Damage, " hp, ");
                Output.Write("Hit Chance: ", weapon.Accuracy * 100, "%, ");
                if (weapon.BlockChance != 0)
                {
                    Output.Write(", BlockChance: ", weapon.BlockChance * 100, "%, ");
                }
            }
            else if (item is Armor armor)
            {
                if (armor.Rating != 0)
                    Output.Write("Defense: ", armor.Rating * 100, "%, ");

                if (armor.Warmth != 0)
                    Output.Write("Warmth: ", armor.Warmth, "F, ");
            }

            if (item.Weight != 0)
            {
                Output.Write("Weight: ", item.Weight, "kg");
            }
            Output.WriteLine();
        }

        // public static void DescribeLevel(Player player)
        // {
        //     Output.WriteLine("Level: ", player.Level);
        //     Output.WriteLine("XP: ", player.Experience, "/", player.ExperienceToNextLevel);
        // }
        public static void DescribePrimaryAttributes(Player player)
        {
            Output.WriteLine("Primary Attributes: ");
            Output.WriteLine("STR: ", player.Attributes.Strength);
            Output.WriteLine("SPD: ", player.Attributes.Speed);
            Output.WriteLine("END: ", player.Attributes.Endurance);
            Output.WriteLine("LUC: ", player.Attributes.Luck);
        }

        public static void DescribeSkills(Player player)
        {
            player._skillRegistry.Describe();

        }
    }
}
================================================================================

File: ./Actions.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.Interfaces;
using text_survival.IO;
using text_survival.Items;
using text_survival.PlayerComponents;

namespace text_survival
{

    public class Actions
    {
        private readonly Player _player;
        public List<ICommand> AvailableActions { get; private set; }

        public Actions(Player player)
        {
            _player = player;
            AvailableActions = [];
        }

        private Command<Player> LookAroundCommand => new Command<Player>($"Look Around {_player.CurrentLocation}", LookAround);
        private Command<Player> CheckStatsCommand => new Command<Player>("Check Stats", CheckStats);
        // private Command<Player> LevelUpCommand => new Command<Player>("Level Up", LevelUp);
        //private Command<Player, IInteractable> InteractCommand => new Command<Player, IInteractable>("Interact", Interact);
        private Command<Player> OpenInventoryCommand => new Command<Player>("Open Inventory", OpenInventory);
        private Command<Player> TravelCommand => new Command<Player>("Travel", Travel);
        private Command<Player> SleepCommand => new Command<Player>("Sleep", Sleep);
        private Command<Player> CheckGearCommand => new Command<Player>("Check Gear", CheckGear);
        private Command<Player> ForageCommand => new Command<Player>("Forage", Forage);
        //private Command<Player> QuitCommand => new Command<Player>("Quit", Quit);
        public void UpdatePossibleActions()
        {
            // Clear the available actions
            AvailableActions.Clear();

            // always available actions
            var lookCommand = LookAroundCommand;
            lookCommand.Player = _player;
            AvailableActions.Add(lookCommand);

            var forageCommand = ForageCommand;
            forageCommand.Player = _player;
            AvailableActions.Add(forageCommand);

            // conditional actions

            foreach (Location location in _player.CurrentLocation.Locations)
            {
                if (location.IsFound)
                {
                    var interactCommand = location.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Item item in _player.CurrentLocation.Items)
            {
                if (item.IsFound)
                {
                    var interactCommand = item.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Container container in _player.CurrentLocation.Containers)
            {
                if (container.IsFound)
                {
                    var interactCommand = container.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Npc npc in _player.CurrentLocation.Npcs)
            {
                if (npc.IsFound)
                {
                    var interactCommand = npc.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }




            foreach (Location location in GetNearbyLocations(_player))
            {
                if (location.IsFound)
                {
                    var interactCommand = location.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }



            var openInventoryCommand = OpenInventoryCommand;
            openInventoryCommand.Player = _player;
            AvailableActions.Add(openInventoryCommand);


            if (_player.CurrentLocation.Parent is not null)
            {
                var leaveCommand = _player.LeaveCommand;
                leaveCommand.Player = _player;
                AvailableActions.Add(leaveCommand);
            }

            var travelCommand = TravelCommand;
            travelCommand.Player = _player;
            AvailableActions.Add(travelCommand);


            var sleepCommand = SleepCommand;
            sleepCommand.Player = _player;
            AvailableActions.Add(sleepCommand);


            if (_player.IsArmored || _player.IsArmed)
            {
                var checkGearCommand = CheckGearCommand;
                checkGearCommand.Player = _player;
                AvailableActions.Add(checkGearCommand);
            }

            var checkStats = CheckStatsCommand;
            checkStats.Player = _player;
            AvailableActions.Add(checkStats);

            // if (_player.SkillPoints > 0)
            // {
            //     var levelUpCommand = LevelUpCommand;
            //     levelUpCommand.Player = _player;
            //     AvailableActions.Add(levelUpCommand);
            // }
        }

        private void Forage(Player player)
        {
            Location location = player.CurrentLocation;
            Output.WriteLine("How many hours would you like to forage?");
            int hours = Input.ReadInt();
            location.Forage(hours);


        }

        public void Act()
        {
            UpdatePossibleActions();
            Output.WriteLine();
            _player.DescribeSurvivalStats();
            Output.WriteLine();
            Output.WriteLine("What would you like to do?");
            ICommand? command = Input.GetSelectionFromList(AvailableActions);
            command?.Execute();
        }

        // private void LevelUp(Player player)
        // {
        //     Output.WriteLine("You have ", player.SkillPoints, " points.");
        //     while (player.SkillPoints > 0)
        //     {
        //         Output.WriteLine("Select an attribute to improve:");
        //         Output.WriteLine("1. ", Attributes.PrimaryAttributes.Strength);
        //         Output.WriteLine("3. ", Attributes.PrimaryAttributes.Speed);
        //         Output.WriteLine("4. ", Attributes.PrimaryAttributes.Endurance);
        //         Output.WriteLine("6. ", Attributes.PrimaryAttributes.Luck);

        //         Output.WriteLine("0. Cancel");
        //         int input = Input.ReadInt(0, 8);
        //         if (input == 0) return;
        //         var attribute = input switch
        //         {
        //             1 => Attributes.PrimaryAttributes.Strength,
        //             3 => Attributes.PrimaryAttributes.Speed,
        //             4 => Attributes.PrimaryAttributes.Endurance,
        //             6 => Attributes.PrimaryAttributes.Luck,
        //             _ => throw new NotImplementedException(),
        //         };
        //         // player.SpendPointToUpgradeAttribute(attribute);
        //     }
        // }

        private void CheckStats(Player player)
        {
            // Describe.DescribeLevel(player);
            Describe.DescribePrimaryAttributes(player);
            Describe.DescribeSkills(player);
            Output.WriteLine("Press any key to continue...");
            Console.ReadKey(true);
        }

        private void OpenInventory(Player player)
        {
            player.OpenInventory();
        }

        private void Travel(Player player)
        {
            player.Travel();
        }


        private void Sleep(Player player)
        {
            Output.WriteLine("How many hours would you like to sleep?");
            player.Sleep(Input.ReadInt() * 60);
        }

        private void CheckGear(Player player)
        {
            // player.CheckGear();
            //todo
        }

        private void LookAround(Player player)
        {
            Output.WriteLine("You look around the ", player.CurrentLocation);
            Output.WriteLine("You are in a ", player.CurrentLocation, " in a ", player.CurrentZone);
            Output.WriteLine("Its ", World.GetTimeOfDay(), " and ", player.CurrentLocation.GetTemperature(), " degrees.");
            if (player.CurrentLocation.Things.Count == 0)
            {
                Output.WriteLine("You see nothing of interest, time to move on.");
                return;
            }
            Output.WriteLine("You see:");
            foreach (var thing in player.CurrentLocation.Things)
            {
                Output.WriteLine(thing);
                thing.IsFound = true;
            }

            var nearbyLocations = GetNearbyLocations(player);
            if (nearbyLocations.Count == 0)
                return;
            bool inSubLocation = player.CurrentLocation.Parent is Location;
            Output.WriteLine("Nearby, in the ", inSubLocation ? player.CurrentLocation.Parent! : player.CurrentZone, " you see some other places: ");
            foreach (var location in nearbyLocations)
            {
                Output.WriteLine(location);
                location.IsFound = true;
            }
        }
        private List<Location> GetNearbyLocations(Player player)
        {
            List<Location> nearbyLocations = [];
            if (player.CurrentLocation.Parent is Location loc && loc.Locations.Count > 0)
            {
                foreach (var location in loc.Locations)
                {
                    if (location == player.CurrentLocation)
                        continue;
                    nearbyLocations.Add(location);
                }
            }
            else if (player.CurrentZone.Locations.Count > 0)
            {
                foreach (var location in player.CurrentZone.Locations)
                {
                    if (location == player.CurrentLocation)
                        continue;
                    nearbyLocations.Add(location);
                }
            }
            return nearbyLocations;
        }
    }
}
================================================================================

File: ./Physics.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Physics
    {
        public static float DeltaCelsiusToDeltaFahrenheit(float celsius)
        {
            return (celsius * (9.0F / 5.0F));
        }
        public static float TempChange(float mass, float specificHeat, float joules)
        {
            float deltaT = joules / (mass * specificHeat);
            return deltaT;
        }
        public static float CaloriesToJoules(float calories)
        {
            return calories * 4184.0F;
        }

    }
}
================================================================================

File: ./Player.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.Magic;
using text_survival.PlayerComponents;

namespace text_survival
{
    public class Player : Actor
    {

        private LocationManager locationManager;
        private SpellManager spellManager;

        public void Sleep(int minutes) => survivalManager.Sleep(minutes);
        public void OpenInventory() => inventoryManager.Open(this);

        // Location-related methods
        public override Location CurrentLocation
        {
            get => locationManager.CurrentLocation;
            set => locationManager.CurrentLocation = value;
        }

        public override Zone CurrentZone
        {
            get => locationManager.CurrentZone;
            set => locationManager.CurrentZone = value;
        }


        public Attributes Attributes { get; }


        #region Constructor

        public Player(Location startingLocation)
        {
            Name = "Player";
            Attributes = new Attributes();

            _skillRegistry = new SkillRegistry();
            _effectRegistry = new(this);

            Body body = new(BodyPartFactory.CreateHumanBody("Player", 100), 70, 20, 60, _effectRegistry);
            survivalManager = new SurvivalManager(this, _effectRegistry, true, body);
            inventoryManager = new(_effectRegistry);
            combatManager = new CombatManager(this);
            locationManager = new LocationManager(startingLocation);
            spellManager = new(_skillRegistry);


        }

        #endregion Constructor

        public void DropItem(Item item)
        {
            inventoryManager.RemoveFromInventory(item);
            Output.WriteLine("You drop the ", item);
            locationManager.AddItemToLocation(item);
        }

        public void TakeItem(Item item)
        {
            locationManager.RemoveItemFromLocation(item);
            Output.WriteLine("You take the ", item);
            inventoryManager.AddToInventory(item);
        }

        public void SelectSpell()
        {
            List<Actor> targets = [this];
            CurrentLocation.Npcs.ForEach(targets.Add);
            spellManager.SelectSpell(targets);
        }



        public override void Damage(DamageInfo damageInfo)
        {
            survivalManager.Damage(damageInfo);
            if (!survivalManager.IsAlive)
            {
                // end program
                Environment.Exit(0);
            }
        }

        internal void DescribeSurvivalStats() => survivalManager.Describe();
        public void UseItem(Item item)
        {
            Output.WriteLine($"DEBUG: Item '{item.Name}' has actual type: {item.GetType().FullName}");
            Output.WriteLine($"DEBUG: Base type: {item.GetType().BaseType?.FullName}");
            // handle special logic for each item type
            if (item is FoodItem food)
            {
                string eating_type = food.WaterContent > food.Calories ? "drink" : "eat";
                Output.Write($"You {eating_type} the ", food, "...");
                survivalManager.ConsumeFood(food);
            }
            else if (item is ConsumableItem consumable)
            {
                foreach (Effect e in consumable.Effects)
                {
                    ApplyEffect(e);
                }
            }
            else if (item is Gear gear)
            {
                Output.WriteLine("You equip the ", gear);
                inventoryManager.Equip(gear);
                foreach (Effect effect in gear.EquipEffects)
                {
                    ApplyEffect(effect);
                }
            }

            else if (item is WeaponModifierItem weaponMod)
            {
                if (ModifyWeapon(weaponMod.Damage))
                {
                    Output.WriteLine("You use the ", weaponMod, " to modify your ", inventoryManager.Weapon);
                }
                else
                {
                    Output.WriteLine("You don't have a weapon equipped to modify.");
                    return;
                }
            }
            else if (item is ArmorModifierItem armorMod)
            {
                if (ModifyArmor(armorMod.ValidArmorTypes[0], armorMod.Rating, armorMod.Warmth))
                {
                    Output.WriteLine("You use the ", armorMod, " to modify your armor.");
                }
                else
                {
                    Output.WriteLine("You don't have any armor you can use that on.");
                    return;
                }
            }
            else
            {
                Output.Write("You don't know what to use the ", item, " for...\n");
                return;
            }
            // shared logic for all item types
            if (item.NumUses != -1)
            {
                item.NumUses -= 1;
                if (item.NumUses == 0)
                {
                    inventoryManager.RemoveFromInventory(item);
                }
            }
            World.Update(1);
        }

        public bool ModifyWeapon(double damage)
        {
            if (!IsArmed) return false;

            inventoryManager.Weapon.Damage += damage;
            return true;
        }
        public bool ModifyArmor(EquipSpots spot, double rating = 0, double warmth = 0)
        {
            Armor? armor = inventoryManager.GetArmorInSpot(spot);
            if (armor is null) return false;

            armor.Rating += rating;
            armor.Warmth += warmth;
            return true;
        }



        public void Travel() => locationManager.TravelToAdjacentZone();
        public Command<Player> LeaveCommand => new("Leave " + Name, p => locationManager.Leave());
    }
}
================================================================================

File: ./Actors/Humanoid.cs
--------------------------------------------------------------------------------
﻿using text_survival.Items;
using text_survival.Level;

namespace text_survival.Actors
{
    public class Humanoid : Npc
    {
        public Weapon Weapon { get; set; }
        public Armor Armor { get; set; }


        public Humanoid(string name, Weapon? weapon = null, Armor? armor = null, Attributes? attributes = null) : base(name, attributes)
        {
            Weapon = weapon ?? new Weapon(WeaponType.Dagger, WeaponMaterial.Iron, quality: Utils.RandInt(1, 100));
            Armor = armor ?? new Armor("Leather Outfit", .2, EquipSpots.Chest, 4);
            AddLoot(Weapon);
            AddLoot(Armor);
        }

    }
}
================================================================================

File: ./Actors/Animal.cs
--------------------------------------------------------------------------------
﻿using text_survival.Level;

namespace text_survival.Actors
{
    public class Animal : Npc
    {
        public Animal(string name, double baseDamage, Attributes? attributes = null) : base(name, attributes)
        {
            // to-do
        }

    }
}
================================================================================

File: ./Actors/IBuffable.cs
--------------------------------------------------------------------------------
﻿// using text_survival.Magic;

// namespace text_survival.Actors
// {
//     public interface IBuffable //: IActor
//     {
//         public List<Buff> Buffs { get; }

//         public void AddBuff(Buff buff)
//         {
//             if (buff.Target == null)
//                 buff.ApplyTo(this);
//             Buffs.Add(buff);
//         }
//         public void RemoveBuff(Buff buff)
//         {
//             if (buff.Target == this)
//                 buff.Remove();
//             Buffs.Remove(buff);
//         }

//     }
// }
================================================================================

File: ./Actors/ICombatant.cs
--------------------------------------------------------------------------------
﻿
// using text_survival.Items;
// using text_survival.Level;

// namespace text_survival.Actors
// {
//     public interface ICombatant
//     {
//         bool IsAlive { get; }
//         bool IsEngaged { get; set; }
//         Weapon ActiveWeapon { get; }
//         Attributes Attributes { get; }
//         SkillRegistry _skillRegistry {get;}
//         double ConditionPercent { get; }
//         void Attack(ICombatant target);
//         // double DetermineDamage();
//         // double DetermineHitChance(ICombatant defender);
//         // double DetermineDodgeChance(ICombatant attacker);
//         // double DetermineBlockChance(ICombatant attacker);

//     }
// }
================================================================================

File: ./Actors/NPCFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Items;
using text_survival.Level;

namespace text_survival.Actors
{
    public static class NpcFactory
    {

        public static Humanoid MakeBandit()
        {
            Humanoid bandit = new("Bandit");
            bandit.AddLoot(BanditLootTable.GenerateRandomItem());
            return bandit;
        }
        private static readonly LootTable BanditLootTable = new LootTable([
            ItemFactory.MakeCoin,
            ItemFactory.MakeApple,
            ItemFactory.MakeCopperCoin,
            ItemFactory.MakeBread
        ]);

        public static Npc MakeRat()
        {
            Animal rat = new("Rat", 2, new Attributes(5, 40, 5, 70))
            {
                Description = "A rat with fleas."
            };
            rat.AddLoot(ItemFactory.MakeSmallMeat());
            return rat;
        }

        public static Animal MakeWolf()
        {
            Animal wolf = new("Wolf", 10, new Attributes(50, 50, 50, 50))
            {
                Description = "A wolf."
            };
            wolf.AddLoot(ItemFactory.MakeLargeMeat());
            return wolf;
        }

        public static Npc MakeBear()
        {
            Npc bear = new Animal("Bear", 20, new Attributes(80, 40, 80, 50));
            bear.AddLoot(ItemFactory.MakeLargeMeat());
            bear.Description = "A bear.";
            return bear;
        }

        public static Npc MakeSnake()
        {
            Npc snake = new Animal("Snake", 10, new Attributes(20, 40, 20, 55));
            snake.AddLoot(SnakeLootTable.GenerateRandomItem());
            // CommonBuffs.Venomous(2, 3, .5).ApplyTo(snake); // todo make effect for this
            return snake;
        }
        private static readonly LootTable SnakeLootTable = new([
            ItemFactory.MakeSmallMeat,
            ItemFactory.MakeVenomSac
         ]);



        public static Npc MakeBat()
        {
            Npc bat = new Animal("Bat", 2, new Attributes(10, 60, 40, 50));
            return bat;
        }

        public static Npc MakeSpider()
        {
            Npc spider = new Animal("Spider", 5, new Attributes(15, 30, 15, 55));
            // CommonBuffs.Venomous(1, 3, .4).ApplyTo(spider); // todo - make effect for this
            spider.AddLoot(SpiderLT.GenerateRandomItem());
            return spider;
        }

        public static Npc MakeCaveBear()
        {
            Npc bear = MakeBear();
            bear.Name = "Cave Bear";
            return bear;
        }

        private static readonly LootTable SpiderLT = new([
            ItemFactory.MakeSpiderSilk,
            ItemFactory.MakeVenomSac
        ]);

    }

}
================================================================================

File: ./Actors/NpcSpawner.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Actors
{
    public class NpcSpawner
    {
        private List<Func<Npc>> _factories { get; set; }

        public NpcSpawner()
        {
            _factories = [];
        }

        public NpcSpawner(List<Func<Npc>> factories)
        {
            _factories = factories;
        }

        public void Add(Func<Npc> factory)
        {
            _factories.Add(factory);
        }

        public Npc? GenerateRandomNpc()
        {
            if (_factories.Count == 0)
            {
                return new Npc("Ghost");
            }
            var fac = Utils.GetRandomFromList(_factories);
            return fac();
        }
    }
}================================================================================

File: ./Actors/Actor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.Items;
using text_survival.Level;
using text_survival.PlayerComponents;

namespace text_survival.Actors;

public abstract class Actor
{
    public string Name = "";

    public abstract Location CurrentLocation { get; set; }
    public abstract Zone CurrentZone { get; set; }
    public virtual void Attack(Actor target) => combatManager.Attack(target);

    public virtual void Damage(DamageInfo damage) => survivalManager.Damage(damage);
    public virtual void Heal(HealingInfo heal) => survivalManager.Heal(heal);

    public bool IsEngaged { get; set; }
    public bool IsAlive => survivalManager.IsAlive;
    public double ConditionPercent => survivalManager.ConditionPercent;
    public Weapon ActiveWeapon => inventoryManager.Weapon;
    public bool IsArmed => inventoryManager.IsArmed;
    public bool IsArmored => inventoryManager.IsArmored;
    public double EquipmentWarmth => inventoryManager.EquipmentWarmth;

    public virtual void ApplyEffect(Effect effect) => _effectRegistry.AddEffect(effect);
    public virtual void RemoveEffect(Effect effect) => _effectRegistry.RemoveEffect(effect);

    public virtual void Update()
    {
        survivalManager.Update();
        _effectRegistry.Update();
    }

    public required SkillRegistry _skillRegistry { get; init; }
    public required Body Body { get; init; }
    protected EffectRegistry _effectRegistry { get; init; }
    protected SurvivalManager survivalManager { get; init; }
    protected InventoryManager inventoryManager { get; init; }
    protected CombatManager combatManager { get; init; }

    public override string ToString() => Name;

    // protected Actor(EffectRegistry effectRegistry,
    //               SkillRegistry skillRegistry,
    //               SurvivalManager survivalManager,
    //               InventoryManager inventoryManager,
    //               CombatManager combatManager,
    //               Body body)
    // {
    //     _effectRegistry = effectRegistry;
    //     _skillRegistry = skillRegistry;
    //     this.survivalManager = survivalManager;
    //     this.inventoryManager = inventoryManager;
    //     this.combatManager = combatManager;
    //     Body = body;
    // }
}


================================================================================

File: ./Actors/NPC.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.PlayerComponents;
using text_survival.Bodies;

namespace text_survival.Actors
{
    public class Npc : Actor
    {
        #region Properties

        // Basic properties
        public string Description { get; set; }
        public bool IsFound { get; set; }
        public bool IsHostile { get; private set; }

        public override Location CurrentLocation {get; set;}
        public override Zone CurrentZone {get; set;}
        public Attributes Attributes { get; }

        // IPhysicalEntity implementation
        public double Health => Body.Health;
        public double MaxHealth => Body.MaxHealth;
        public bool IsDestroyed => Body.IsDestroyed;

        // Internal components

        private Container Loot { get; }

        #endregion

        #region Constructor

        public Npc(string name, Attributes? attributes = null)
        {
            // Basic initialization
            Name = name;
            Attributes = attributes ?? new Attributes();
            Description = "";
            IsHostile = true;

            // Component initialization
            _skillRegistry = new SkillRegistry(this is Humanoid);

            // Create the appropriate body type
            int baseHealth = (int)(((Attributes.Strength + Attributes.Endurance) / 10) * 2);
            BodyPart bodyPart;

            if (this is Humanoid)
            {
                bodyPart = BodyPartFactory.CreateHumanBody(name, baseHealth);
            }
            else if (this is Animal)
            {
                bodyPart = BodyPartFactory.CreateAnimalBody(name, baseHealth);
            }
            else
            {
                bodyPart = BodyPartFactory.CreateGenericBody(name, baseHealth);
            }

            // Create body from the generated body part with sensible defaults
            Body = new Body(bodyPart, 70, 20, 60, _effectRegistry);

            // Set up loot container
            Loot = new Container(name, 10);
        }

        #endregion

        #region IPhysicalEntity Interface Implementation

        public IReadOnlyDictionary<string, double> GetCapacities()
        {
            return Body.GetCapacities();
        }

        #endregion

  
        #region IInteractable Interface Implementation

        public void Interact(Player player)
        {
            if (IsAlive)
            {
                Combat.CombatLoop(player, this);
            }
            else
            {
                if (Loot.IsEmpty)
                {
                    Output.WriteLine("There is nothing to loot.");
                    return;
                }
                Loot.Open(player);
            }
        }

        public Command<Player> InteractCommand
        {
            get
            {
                string name = IsAlive ? "Fight " + Name : "Loot " + Name;
                return new Command<Player>(name, Interact);
            }
        }

        #endregion



        #region Inventory and Loot Methods

        public void AddLoot(Item item) => Loot.Add(item);

        public void DropInventory(Location location)
        {
            while (!Loot.IsEmpty)
            {
                Item item = Loot.GetItem(0);
                Output.WriteLine(this, " dropped ", item, "!");
                DropItem(item, location);
            }
        }

        private void DropItem(Item item, Location location)
        {
            item.IsFound = true;
            Loot.Remove(item);
            location.Items.Add(item);
        }

        #endregion

        public override string ToString() => Name;
    }
}================================================================================

File: ./Items/Container.cs
--------------------------------------------------------------------------------
﻿using System.Text.RegularExpressions;
using text_survival.Actors;
using text_survival.Interfaces;
using text_survival.IO;

namespace text_survival.Items
{
    public class Container : IInteractable
    {
        private string _name;
        public string Name { get => (IsEmpty && HasBeenOpened) ? _name + " (Empty)" : _name; set => _name = value; }
        public double Weight() => Items.Sum(item => item.Weight);
        public float MaxWeight { get; set; }
        public List<Item> Items { get; }
        public bool IsEmpty => Items.Count == 0;
        protected bool HasBeenOpened { get; set; }
        public bool IsFound { get; set; }

        public Container(string name, float maxWeight)
        {
            _name = name;
            MaxWeight = maxWeight;
            Items = [];
        }

        public Item GetItem(int index) => Items[index];
        public Item GetItemByName(string itemName) => Items.First(i => i.Name.Equals(itemName));

        public void Interact(Player player)
        {
            if (!Combat.SpeedCheck(player))
            {
                Npc npc = Combat.GetFastestNpc(player.CurrentLocation);
                Output.WriteLine("You couldn't get past the ", npc, "!");
                npc.Interact(player);
                return;
            }
            Output.WriteLine("You open the ", this);
            Open(player);
        }

        public Command<Player> InteractCommand => new("Look in " + Name, Interact);

        public virtual void Open(Player player)
        {
            HasBeenOpened = true;
            while (!IsEmpty)
            {
                Output.WriteLine(this, ":");

                var items = new List<Item>(Items);
                Item takeAll = new Item("Take all");
                if (items.Count > 1)
                {
                    items.Add(takeAll);
                }

                var itemStacks = ItemStack.CreateStacksFromItems(items);

                var selection = Input.GetSelectionFromList(itemStacks, true, "Close " + this);
                if (selection == null) return;

                Item selectedItem = selection.Take();

                if (selectedItem == takeAll)
                {
                    TakeAll(player);
                    return;
                }

                Output.WriteLine("What would you like to do with ", selectedItem);
                string? choice = Input.GetSelectionFromList(["Take", "Inspect"], true);
                switch (choice)
                {
                    case null:
                        continue;
                    case "Take":
                        Remove(selectedItem);
                        player.TakeItem(selectedItem);
                        break;
                    case "Inspect":
                        Describe.DescribeItem(selectedItem);
                        break;
                    case "Use":
                        Remove(selectedItem);
                        player.TakeItem(selectedItem);
                        player.UseItem(selectedItem);
                        break;
                }
            }
            Output.WriteLine(this, " is empty.");
        }


        private void TakeAll(Player player)
        {
            while (!IsEmpty)
            {
                var item = Items.First();
                Remove(item);
                player.TakeItem(item);
            }
        }

        public override string ToString() => Name;

        public void Add(Item item)
        {
            if (item.Weight + Weight() > MaxWeight)
            {
                Output.Write("The ", this, "is full!\n");
                return;
            }
            Items.Add(item);
        }

        public void Remove(Item item) => Items.Remove(item);
        public int Count() => Items.Count;

    }
}
================================================================================

File: ./Items/Item.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Interfaces;
using text_survival.IO;

namespace text_survival.Items
{
    //public interface IItem
    //{
    //    string Name { get; set; }
    //    double Weight { get; set; } // in kg
    //    Action<Player> UseEffect { get; set; }
    //    string Description { get; set; }
    //    int Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
    //    string ToString();
    //    void Use(Player player);
    //}

    public class Item : IInteractable
    {
        public string Name { get; set; }
        public double Weight { get; set; } // in kg
        public string Description { get; set; } = "";
        public double Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
        public bool IsFound { get; set; }
        public int NumUses { get; set; }

        public Item(string name, double weight = 1, int quality = 50)
        {
            Name = name;
            Weight = weight;
            Quality = quality;
            NumUses = -1; // not consumable
        }

        public override string ToString()
        {
            return Name;
        }
        

        public void Interact(Player player)
        {
            if (!Combat.SpeedCheck(player))
            {
                Npc npc = Combat.GetFastestNpc(player.CurrentLocation);
                Output.WriteLine("You couldn't get past the ", npc, "!");
                npc.Interact(player);
                return;
            }
            player.TakeItem(this);
        }
        public Command<Player> InteractCommand => new Command<Player>("Pick up " + Name, Interact);

    }
}
================================================================================

File: ./Items/ItemPool.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    //public class ItemPool
    //{
    //    private List<Func<Item>> ItemMethods { get; set; }
    //    public ItemPool()
    //    {
    //        ItemMethods = new List<Func<Item>>();
    //    }

    //    public void Add(Func<Item> item)
    //    {
    //        ItemMethods.Add(item);
    //    }

    //    public void Remove(Func<Item> itemFactoryMethod)
    //    {
    //        ItemMethods.Remove(itemFactoryMethod);
    //    }
    //    public Item GenerateRandomItem()
    //    {
    //        int index = Utils.RandInt(0, ItemMethods.Count - 1);
    //        Item item = ItemMethods[index].Invoke();
    //        return item;
    //    }


    //}
}
================================================================================

File: ./Items/FoodItem.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Interfaces;

namespace text_survival.Items
{
    public interface IEdible
    {
        int WaterContent { get; }
        int Calories { get; }
    }

    public class FoodItem : Item, IEdible
    {
        public FoodItem(string name, int calories, int waterContent = 0, double weight = .5) : base(name, weight)
        {
            Quality = 100;
            Calories = calories;
            WaterContent = waterContent;
            NumUses = 1;
        }

        public int WaterContent { get; }
        public int Calories { get; }
        public HealingInfo? HealthEffect {get; set;}
        public DamageInfo? DamageEffect {get; set;}
        public void Update()
        {
            Quality -= .1; //TODO: Add spoilage
        }
        public override string ToString() => Name;
    }
}
================================================================================

File: ./Items/LootTable.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Items;

public class LootTable
{
    private List<Func<Item>> itemFactories = [];
    public LootTable() { }
    public LootTable(List<Func<Item>> factories)
    {
        itemFactories = factories;
    }
    public void AddLootFactory(Func<Item> factory)
    {
        itemFactories.Add(factory);
    }
    public bool IsEmpty()
    {
        return itemFactories.Count == 0;
    }
    public Item GenerateRandomItem()
    {
        var factory = Utils.GetRandomFromList(itemFactories);
        return factory();
    }
}

================================================================================

File: ./Items/IEquippable.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Effects;

namespace text_survival.Items
{
    public interface IEquippable
    {
        // public List<Buff> GetEquipBuffs();
        // public void AddEquipBuff(Buff buff);
        // public void RemoveEquipBuff(Buff buff);
        public List<Effect> EquipEffects { get; }
    }

}================================================================================

File: ./Items/ItemStack.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class ItemStack
{
    public string DisplayName => Items.Count == 1 ? FirstItem.Name : $"{FirstItem.Name} x{Items.Count}";
    public Item FirstItem { get; private set; }
    public Stack<Item> Items { get; private set; }
    public int Count => Items.Count;
    
    public ItemStack(Item item)
    {
        FirstItem = item;
        Items = new Stack<Item>();
        Items.Push(item);
    }
    
    public void Add(Item item)
    {
        if (item.Name != FirstItem.Name)
        {
            throw new ArgumentException($"Cannot add item '{item.Name}' to stack of '{FirstItem.Name}'");
        }
        
        Items.Push(item);
    }
    
    public Item Take() => Items.Pop();
    
    public override string ToString() => DisplayName;
    
    public static List<ItemStack> CreateStacksFromItems(IEnumerable<Item> items)
    {
        var stacksByName = new Dictionary<string, ItemStack>();
        
        foreach (var item in items)
        {
            if (stacksByName.TryGetValue(item.Name, out var stack))
            {
                stack.Add(item);
            }
            else
            {
                stacksByName[item.Name] = new ItemStack(item);
            }
        }
        
        return stacksByName.Values.ToList();
    }
}================================================================================

File: ./Items/Gear.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Gear : Item, IEquippable
    {
        // private List<Buff> EquipBuffs { get; }
        // public List<Buff> GetEquipBuffs() => EquipBuffs;
        // public void AddEquipBuff(Buff buff) => EquipBuffs.Add(buff);
        // public void RemoveEquipBuff(Buff buff) => EquipBuffs.Remove(buff);
        public List<Effect> EquipEffects { get; set; }
        public double Warmth { get; set; }
        public Gear(string name, double weight = 1, int quality = 50) : base(name, weight, quality)
        {
            EquipEffects = [];
        }
    }

}

================================================================================

File: ./Items/ConsumableItem.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.Items;

namespace text_survival.Actors;

class ConsumableItem : Item
{
    public ConsumableItem(string name, int numUses=1) : base(name)
    {
        Effects = [];
        NumUses = numUses;
    }

    public List<Effect> Effects;
}
================================================================================

File: ./Items/ModifierItem.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class WeaponModifierItem : Item
{
    public double Damage { get; set; }
    public WeaponModifierItem(string name) : base(name)
    {
        Damage = 0;
    }

}

public class ArmorModifierItem : Item
{
    public List<EquipSpots> ValidArmorTypes;
    public double Warmth { get; set; }
    public double Rating { get; set; }
    public ArmorModifierItem(string name, List<EquipSpots> validArmorTypes) : base(name)
    {
        ValidArmorTypes = validArmorTypes;
        Warmth = 0;
        Rating = 0;
    }

}================================================================================

File: ./Items/Armor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Armor : Gear
    {
        public EquipSpots EquipSpot { get; set; }
        public double Rating { get; set; }
        public ArmorClass Type { get; set; }

        public Armor(string name, double rating, EquipSpots equipSpot, double warmth = 0, ArmorClass type = ArmorClass.Light) : base(name)
        {
            EquipEffects = [];
            Rating = rating;
            EquipSpot = equipSpot;
            Warmth = warmth;
            Type = type;
        }


    }
}================================================================================

File: ./Items/ItemEnums.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum EquipSpots
    {
        Head,
        Chest,
        Legs,
        Feet,
        Hands,
        Weapon
    }
    public enum WeaponClass
    {
        Blunt,
        Blade,
        Unarmed,
    }
    public enum WeaponType
    {
        Sword,
        Axe,
        Spear,
        Mace,
        Hammer,
        Dagger,
        Staff,
        Unarmed,
    }


    public enum WeaponMaterial
    {
        Wooden,
        Stone,
        Bronze,
        Iron,
        Steel,
        Silver,
        Golden,
        Other
    }
    public enum ArmorClass
    {
        Light,
        Heavy
    }

    public enum QualityEnum
    {
        Unknown,
        Trash,
        Broken,
        Worn,
        Poor,
        Fair,
        Average,
        Decent,
        Good,
        Fine,
        Excellent,
        Perfect
    }






}================================================================================

File: ./Items/Weapon.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{

    public class Weapon : Gear
    {
        //public WeaponClass WeaponClass { get; set; }
        public WeaponClass Class { get; set; }
        public WeaponMaterial WeaponMaterial { get; set; }
        public WeaponType WeaponType { get; set; }
        public double Damage { get; set; }
        public double Accuracy { get; set; }
        public double BlockChance { get; set; }
        // private List<Buff> EquipBuffs { get; }
        // public List<Buff> GetEquipBuffs() => EquipBuffs;
        // public void AddEquipBuff(Buff buff) => EquipBuffs.Add(buff);
        // public void RemoveEquipBuff(Buff buff) => EquipBuffs.Remove(buff);
        public Weapon(WeaponType type, WeaponMaterial weaponMaterial, string name = "", int quality = 50) : base(name, quality: quality)
        {

            SetBaseStats(type);
            ApplyMaterialModifier(weaponMaterial);
            ApplyQualityModifier();
            Class = GetDamageTypeFromWeaponType(type);
            if (string.IsNullOrWhiteSpace(name))
                Name = $"{GetQualityEnumFromQuality(Quality)} {weaponMaterial} {type}";
            WeaponType = type;
            WeaponMaterial = weaponMaterial;
            //Buff = new Buff(name, -1);
            EquipEffects = [];
        }

        private void ApplyQualityModifier()
        {
            Damage *= (double)(Quality * 2) / 100;
            BlockChance *= (double)(Quality * 2) / 100;
        }
        private void ApplyMaterialModifier(WeaponMaterial weaponMaterial)
        {
            switch (weaponMaterial)
            {
                case WeaponMaterial.Wooden:
                    Damage *= .1F;
                    BlockChance *= .7;
                    Weight *= .5F;
                    break;
                case WeaponMaterial.Stone:
                    Damage *= .7F;
                    BlockChance *= .6;
                    Weight *= 1.5F;
                    break;
                case WeaponMaterial.Bronze:
                    Damage *= .9F;
                    BlockChance *= .9;
                    Weight *= .9F;
                    break;
                case WeaponMaterial.Iron:
                    Damage *= 1F;
                    BlockChance *= 1;
                    Weight *= 1.4F;
                    break;
                case WeaponMaterial.Steel:
                    Damage *= 1F;
                    BlockChance *= 1;
                    Weight *= 1F;
                    break;
                case WeaponMaterial.Silver:
                    Damage *= 1.2F;
                    BlockChance *= 1.1;
                    Weight *= 1.1F;
                    break;
                case WeaponMaterial.Golden:
                    Damage *= 1.5F;
                    BlockChance *= .5;
                    Weight *= 1.5F;
                    break;
                case WeaponMaterial.Other:
                default:
                    break;
            }
        }
        private void SetBaseStats(WeaponType type)
        {
            switch (type)
            {
                case WeaponType.Sword:
                    Damage = 12;
                    BlockChance = .1;
                    Accuracy = 1;
                    Weight = 2;
                    break;
                case WeaponType.Axe:
                    Damage = 18;
                    BlockChance = .04;
                    Accuracy = .8;
                    Weight = 4;
                    break;
                case WeaponType.Spear:
                    Damage = 8;
                    BlockChance = .08;
                    Accuracy = 1.2;
                    Weight = 1;
                    break;
                case WeaponType.Mace:
                    Damage = 14;
                    BlockChance = .04;
                    Accuracy = .7;
                    Weight = 2;
                    break;
                case WeaponType.Hammer:
                    Damage = 20;
                    BlockChance = .1;
                    Accuracy = .5;
                    Weight = 5;
                    break;
                case WeaponType.Dagger:
                    Damage = 6;
                    BlockChance = .02;
                    Accuracy = 1.5;
                    Weight = .5F;
                    break;
                case WeaponType.Staff:
                    Damage = 4;
                    BlockChance = .14;
                    Accuracy = 1.2;
                    Weight = 2;
                    break;
                case WeaponType.Unarmed:
                    Damage = 2;
                    BlockChance = .01;
                    Accuracy = 1.5;
                    Weight = 0;
                    break;
                default:
                    break;
            }
        }
        public static Weapon GenerateRandomWeapon()
        {
            WeaponMaterial weaponMaterial = Utils.GetRandomEnum<WeaponMaterial>();
            WeaponType weaponType = Utils.GetRandomEnum<WeaponType>();

            Weapon weapon = new Weapon(weaponType, weaponMaterial);

            // Double-check name was set
            if (string.IsNullOrWhiteSpace(weapon.Name))
                weapon.Name = $"Unknown {weaponType}";

            return weapon;
        }

        private static WeaponClass GetDamageTypeFromWeaponType(WeaponType type)
        {
            return type switch
            {
                WeaponType.Sword => WeaponClass.Blade,
                WeaponType.Axe => WeaponClass.Blade,
                WeaponType.Spear => WeaponClass.Blade,
                WeaponType.Mace => WeaponClass.Blunt,
                WeaponType.Hammer => WeaponClass.Blunt,
                WeaponType.Dagger => WeaponClass.Blade,
                WeaponType.Staff => WeaponClass.Blunt,
                WeaponType.Unarmed => WeaponClass.Unarmed,
                _ => WeaponClass.Blunt,
            };
        }

        public static QualityEnum GetQualityEnumFromQuality(double quality)
        {
            return quality switch
            {
                0 => QualityEnum.Trash,
                < 10 => QualityEnum.Broken,
                < 20 => QualityEnum.Worn,
                < 30 => QualityEnum.Poor,
                < 40 => QualityEnum.Fair,
                < 60 => QualityEnum.Average,
                < 70 => QualityEnum.Decent,
                < 80 => QualityEnum.Good,
                < 90 => QualityEnum.Fine,
                < 99 => QualityEnum.Excellent,
                100 => QualityEnum.Perfect,
                _ => QualityEnum.Unknown
            };
        }


    }
}
================================================================================

File: ./Items/ItemFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class ItemFactory
    {

        public static readonly Dictionary<string, Func<Item>> ItemDefinitions = new()
        {
            { "Mushroom", MakeMushroom },
            { "Apple", MakeApple },
            { "Bread", MakeBread },
            { "Berry", MakeBerry },
            { "Carrot", MakeCarrot },
            { "Water", MakeWater },
            { "Stick", MakeStick },
            { "Wood", MakeWood },
            { "Rock", MakeRock },
            { "Gemstone", MakeGemstone },
            { "Coin", MakeCoin },
            { "Sword", MakeSword },
            { "Shield", MakeShield },
            { "Armor", MakeArmor },
            { "Health Potion", MakeHealthPotion },
            { "Bandage", MakeBandage },
            { "Torch", MakeTorch },
            { "Fish", MakeFish },
            { "RandomWeapon", Weapon.GenerateRandomWeapon }
        };

        public static Weapon MakeFists()
        {
            return new Weapon(WeaponType.Unarmed, WeaponMaterial.Other, "Fists");
        }
        public static FoodItem MakeMushroom()
        {
            var mushroom = new FoodItem("Mushroom", 25, 5)
            {
                Description = "A mushroom of unknown origin. It looks edible, but you're not sure.",
                Weight = 0.1F
            };
            // instead of making the effect dynamic, just have the factory return two types of mushroom with the same name
            double strength = Utils.RandDouble(1, 15);
            string targetOrgan = Utils.GetRandomFromList(["Stomach", "Liver", "Kidney"]);
            if (Utils.FlipCoin())
            {
                mushroom.HealthEffect = new()
                {
                    Amount = strength,
                    Type = "herbal",
                    TargetPart = targetOrgan,
                    Quality = Utils.RandDouble(0, 1.5)
                };
            }
            else
            {
                mushroom.DamageEffect = new()
                {
                    Amount = strength * .66, // make the poisonous ones less dangerous on average to make it worthwhile to take the risk
                    IsPenetrating = true,
                    Type = "poison",
                    TargetPart = targetOrgan,
                    Accuracy = 1,
                };
            }
            return mushroom;
        }

        public static FoodItem MakeApple()
        {
            var apple = new FoodItem("Apple", 90, 50)
            {
                Description = "A red apple. It looks delicious.",
                Weight = 0.2F
            };
            return apple;
        }

        public static FoodItem MakeBread()
        {
            var item = new FoodItem("Bread", 300, -10)
            {
                Description = "A loaf of bread. Looks kind of stale.",
                Weight = 0.5F
            };
            return item;
        }

        public static FoodItem MakeBerry()
        {
            var item = new FoodItem("Berries", 120, 100);
            string color = Utils.FlipCoin() ? "red" : "blue";
            item.Description = "A handful of " + color + " berries.";
            item.Weight = 0.1F;
            return item;
        }

        public static FoodItem MakeCarrot()
        {
            var item = new FoodItem("Carrot", 50, 30)
            {
                Description = "A carrot. It looks like it was just pulled from the ground.",
                Weight = 0.1F
            };
            return item;
        }

        public static FoodItem MakeWater()
        {
            var item = new FoodItem("Water", 0, 1000)
            {
                Description = "Some water. You store it in your waterskin.",
                Weight = 1
            };
            return item;
        }

        public static Item MakeStick()
        {
            Item stick = new Item("Stick")
            {
                Description = "A stick. Useful for crafting.",
                Weight = 1
            };
            return stick;
        }
        public static Item MakeSpear()
        {
            Weapon spear = new Weapon(WeaponType.Spear, WeaponMaterial.Wooden)
            {
                Description = "A makeshift spear.",
                Weight = 1
            };
            return spear;
        }

        public static Item MakeWood()
        {
            var item = new Item("Wood");
            return item;
        }

        public static Item MakeRock()
        {
            var item = new Item("Rock");
            return item;
        }

        public static Item MakeGemstone()
        {
            var item = new Item("Gemstone")
            {
                Description = "A shiny gemstone.",
                Weight = .1F
            };
            return item;
        }

        public static Item MakeCoin()
        {
            var item = new Item("Coin")
            {
                Weight = 0.01F
            };
            return item;
        }

        public static Weapon MakeSword()
        {
            Weapon sword = new Weapon(WeaponType.Sword, WeaponMaterial.Steel)
            {
                Description = "A steel sword.",
                Weight = 2
            };
            return sword;
        }

        public static Armor MakeShield()
        {
            Armor shield = new Armor("Shield", .1, EquipSpots.Hands)
            {
                EquipSpot = EquipSpots.Hands,
                Description = "A shield that blocks 10% damage",
                Weight = 2.5F
            };
            return shield;
        }

        public static Armor MakeArmor()
        {
            Armor armor = new Armor("Armor", .5, EquipSpots.Chest, 1)
            {
                EquipSpot = EquipSpots.Chest,
                Description = "Heavy armor that blocks 50% damage but slows you down",
                Weight = 5
            };
            return armor;
        }

        public static Item MakeHealthPotion()
        {
            var potion = new FoodItem("Health Potion", 5, 200)
            {
                Description = "A potent healing potion",

                Weight = 0.4F,
                NumUses = 1,
                HealthEffect = new()
                {
                    Amount = 50,
                    Type = "magic",
                    Quality = 1,
                    TargetPart = null
                }
            };
            return potion;
        }

        public static Item MakeBandage()
        {
            var bandage = new ConsumableItem("Bandage")
            {
                Description = "A cloth bandage. It might help a bit.",
                Weight = 0.1F,
                Effects = [
                    new RemoveBleedEffect(),
                    new HealEffect(
                        new HealingInfo() { Amount = 10, Quality = .9, Type = "medical" }
                    )
                ]
            };
            return bandage;
        }

        public static Gear MakeTorch()
        {
            Gear torch = new Gear("Torch", 1)
            {
                Description = "A torch that warms you",
                Warmth = 5
            };
            return torch;
        }

        public static FoodItem MakeFish()
        {
            var item = new FoodItem("Fish", 200, 0)
            {
                Weight = 0.3F
            };
            return item;
        }

        public static FoodItem MakeLargeMeat()
        {
            var item = new FoodItem("Large Meat", 600, 0)
            {
                Weight = .6F
            };
            return item;
        }
        public static FoodItem MakeSmallMeat()
        {
            var item = new FoodItem("Small Meat", 200, 0)
            {
                Weight = .2F
            };
            return item;
        }
        public static FoodItem MakeCheese()
        {
            var item = new FoodItem("Cheese", 150, 30)
            {
                Weight = .1F
            };
            return item;
        }

        public static Item MakeCopperCoin()
        {
            var item = new Item("Copper Coin")
            {
                Weight = 0.01F
            };
            return item;
        }


        public static Item MakeVenomSac()
        {
            Item venom = new Item("Venom Sac");
            // venom.UseEffect = (player) =>
            // {
            //     if (player.IsArmed)
            //     {
            //         Output.Write("You use ", venom, " to poison your weapon. (TODO)\n");
            //         // player.Weapon.AddEquipBuff(CommonBuffs.PoisionedWeapon(2, 3));
            //     }
            //     else
            //     {
            //         Output.Write("You don't have any weapons to poison.\n");
            //     }
            // };
            venom.NumUses = 2;
            venom.Description = "An organ extracted from a venomous animal.";
            venom.Weight = 0.1F;
            return venom;
        }

        //public static Item MakeBatWing()
        //{
        //    var item = new Item("Bat Wing");
        //    return item;
        //}

        //public static Item MakeGuano()
        //{
        //    var item = new Item("Guano");
        //    return item;
        //}

        public static Item MakeSpiderSilk()
        {
            Item silk = new ArmorModifierItem("Spider Silk", [EquipSpots.Hands, EquipSpots.Feet, EquipSpots.Head])
            {
                Weight = .1,
                Description = "A bundle of spider silk.",
                Warmth = .5
            };
            // silk.UseEffect = (player) =>
            // {
            //     Output.Write("You use this to improve the warmth of your clothing.\n");
            //     if (!player.ModifyArmor(EquipSpots.Chest, warmth: 1))
            //     {
            //         Output.Write("You don't have any clothing to improve.\n");
            //         silk.NumUses += 1;
            //     }
            // };
            return silk;

        }

        public static Weapon MakeGoblinSword()
        {
            Weapon sword = new Weapon(WeaponType.Sword, WeaponMaterial.Iron)
            {
                Name = "Goblin Sword"
            };
            return sword;
        }

        public static Armor MakeTatteredCloth()
        {
            Armor cloth = new Armor("Tattered Cloth", .3, EquipSpots.Head, .5);
            return cloth;
        }

        public static Item MakeDragonScale()
        {
            Item scale = new ArmorModifierItem("Dragon Scale", [EquipSpots.Chest])
            {
                Description = "A large scale from a dragon. Can be used to improve armor.",
                NumUses = 1,
                Rating = 6
            };

            return scale;
        }

        public static Item MakeDragonTooth()
        {
            Item tooth = new WeaponModifierItem("Dragon Tooth")
            {
                Description = "A large tooth from a dragon. Can be used to improve a weapon.",
                NumUses = 1,
                Damage = 6
            };
            return tooth;
        }

        // public static Item MakeLargeCoinPouch()
        // {
        //     Item item = new Item("Large Coin Pouch");
        //     item.UseEffect = (player) =>
        //     {
        //         int num = Utils.RandInt(3, 5);
        //         Output.Write("It contained " + num + " coins\n");
        //         for (int i = 0; i < num; i++)
        //         {
        //             player.TakeItem(MakeCoin());
        //         }
        //     };
        //     item.NumUses = 1;
        //     return item;
        // }

        //public static Item MakeBoneFragments()
        //{
        //    var item = new Item("Bone Fragments");
        //    return item;
        //}

        public static Weapon MakeRustySword()
        {
            Weapon sword = new Weapon(WeaponType.Sword, WeaponMaterial.Iron, "Rusty Sword", 20)
            {
                Description = "A rusty sword.",
                Weight = 2.0F
            };
            return sword;
        }

        public static Armor MakeClothShirt()
        {
            Armor shirt = new Armor("Cloth Shirt", .03, EquipSpots.Chest, 3)
            {
                EquipSpot = EquipSpots.Chest
            };
            return shirt;
        }
        public static Armor MakeClothPants()
        {
            Armor pants = new Armor("Cloth Pants", .02, EquipSpots.Legs, 2)
            {
                EquipSpot = EquipSpots.Legs
            };
            return pants;
        }

        public static Armor MakeBoots()
        {
            Armor shoes = new Armor("Boots", .01, EquipSpots.Feet, 1)
            {
                EquipSpot = EquipSpots.Feet
            };
            return shoes;
        }
    }

}
================================================================================

File: ./obj/Debug/net8.0/text_survival.GlobalUsings.g.cs
--------------------------------------------------------------------------------
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
================================================================================

File: ./obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
--------------------------------------------------------------------------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
================================================================================

File: ./obj/Debug/net8.0/text_survival.AssemblyInfo.cs
--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("text_survival")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+c17b2f94c0b6a34a272476030a20f7142443bec1")]
[assembly: System.Reflection.AssemblyProductAttribute("text_survival")]
[assembly: System.Reflection.AssemblyTitleAttribute("text_survival")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

================================================================================

File: ./Level/Attributes.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Level
{
    public class Attributes
    {
        public enum PrimaryAttributes
        {
            Strength,
            Speed,
            Endurance,
            Luck
        }
        // base
        private double _baseStrength;
        private double _baseSpeed;
        private double _baseEndurance;
        private double _baseLuck;

        // buffs
        private double StrengthBuff { get; set; }
        private double SpeedBuff { get; set; }
        private double EnduranceBuff { get; set; }
        private double LuckBuff { get; set; }

        // total
        public double Strength => _baseStrength + StrengthBuff;
        public double Speed => _baseSpeed + SpeedBuff;
        public double Endurance => _baseEndurance + EnduranceBuff;
        public double Luck => _baseLuck + LuckBuff;


        public Attributes(int STR = 40, int SPD = 40, int END = 40, int LUC = 50)
        {
            _baseStrength = STR;
            _baseSpeed = SPD;
            _baseEndurance = END;
            _baseLuck = LUC;
        }

        public void IncreaseBase(PrimaryAttributes primaryAttribute, int amount)
        {
            switch (primaryAttribute)
            {
                case PrimaryAttributes.Strength:
                    _baseStrength += amount;
                    break;
                case PrimaryAttributes.Speed:
                    _baseSpeed += amount;
                    break;
                case PrimaryAttributes.Endurance:
                    _baseEndurance += amount;
                    break;
                case PrimaryAttributes.Luck:
                    _baseLuck += amount;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(primaryAttribute), primaryAttribute, null);
            }
        }
    }
}
================================================================================

File: ./Level/Skill.cs
--------------------------------------------------------------------------------
﻿

using text_survival.IO;

namespace text_survival.Level
{
    public class Skill
    {
        public int Xp;
        public int Level { get; private set; }
        public string Name { get; set; }
        public int LevelUpThreshold => (Level) * 10;

        public Skill(string name)
        {
            Name = name;
            Xp = 0;
            Level = 0;
        }
        public void GainExperience(int xp)
        {
            Xp += xp;

            if (Xp < LevelUpThreshold) return;
            // else level up
            Xp -= LevelUpThreshold;
            LevelUp();
        }

        public void LevelUp()
        {
            Level++;
            Output.WriteLine("You leveled up ", this, " to level ", Level, "!");
        }

        public override string ToString() => Name;

        public void Describe()
        {
            Output.Write(this, ": ", Level, " (", Xp, "/", LevelUpThreshold, ")");
        }



    }
}
================================================================================

File: ./Level/SkillRegistry.cs
--------------------------------------------------------------------------------
﻿
using text_survival.IO;

namespace text_survival.Level
{
    public class SkillRegistry
    {
        private readonly Dictionary<string, Skill> skills;

        public SkillRegistry(bool fullSkills = true)
        {
            skills = [];
            if (fullSkills)
            {
                skills.Add("Fighting", new Skill("Fighting"));
                skills.Add("Hunting", new Skill("Hunting"));
                skills.Add("Endurance", new Skill("Endurance"));
                skills.Add("Defense", new Skill("Defense"));
                skills.Add("Agility", new Skill("Reflexes"));
                skills.Add("Toolmaking", new Skill("Toolmaking"));
                skills.Add("Foraging", new Skill("Foraging"));
                skills.Add("Firecraft", new Skill("Firecraft"));
                skills.Add("Mending", new Skill("Mending"));
                skills.Add("Healing", new Skill("Healing"));
                skills.Add("Shamanism", new Skill("Shamanism"));
            }
            else
            {
                skills.Add("Melee", new Skill("Melee"));
                skills.Add("Endurance", new Skill("Endurance"));
                skills.Add("Agility", new Skill("Reflexes"));
                skills.Add("Defense", new Skill("Defense"));
            }
        }

        public void AddExperience(string skillName, int xp)
        {
            if (skills.ContainsKey(skillName))
                skills[skillName].GainExperience(xp);
        }

        public int GetLevel(string skillName) => skills.TryGetValue(skillName, out Skill? value) ? value.Level : 1;

        public Skill? GetSkill(string skillName) => skills.TryGetValue(skillName, out Skill? value) ? value : null;

        public void Describe()
        {
            Output.WriteLine("Skills:");
            foreach (var skill in skills.Values)
            {
                Output.WriteLine($"{skill.Name}: {skill.Level} ({skill.Xp}/{skill.LevelUpThreshold})");
            }
        }
    }
}================================================================================

File: ./Level/Perk.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Level
{
    internal class Perk
    {
    }
}
================================================================================

File: ./PlayerComponents/LocationManger.cs
--------------------------------------------------------------------------------
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

class LocationManager : ILocationSystem
{
    public LocationManager(Location startingLocation)
    {
        Map = new WorldMap(startingLocation.ParentZone);
        _currentLocation = startingLocation;
        startingLocation.Visited = true;
    }
    private WorldMap Map { get; }
    public Location CurrentLocation
    {
        get
        {
            return _currentLocation;
        }
        set
        {
            Output.WriteLine("You go to the ", value);
            int minutes = Utils.RandInt(1, 10);
            World.Update(minutes);
            Output.WriteLine("You arrive at the ", value, " after walking ", minutes, " minutes.");
            _currentLocation = value;
            Output.WriteLine("You should probably look around.");
        }
    }
    private Location _currentLocation;

    public Zone CurrentZone
    {
        get
        {
            return Map.CurrentZone;
        }
        set
        {
            if (CurrentZone == value)
            {
                Output.WriteLine("There's nowhere to leave. Travel instead.");
                return;
            }
            if (Map.North == value)
            {
                Output.WriteLine("You go north.");
                Map.MoveNorth();
            }
            else if (Map.East == value)
            {
                Output.WriteLine("You go east.");
                Map.MoveEast();
            }
            else if (Map.South == value)
            {
                Output.WriteLine("You go south.");
                Map.MoveSouth();
            }
            else if (Map.West == value)
            {
                Output.WriteLine("You go west.");
                Map.MoveWest();
            }
            else
                throw new Exception("Invalid zone.");
            Location? newLocation = Utils.GetRandomFromList(value.Locations);

            CurrentLocation = newLocation ?? throw new Exception("No Locations In Zone");
            Output.WriteLine("You enter ", value);
            Output.WriteLine(value.Description);
        }
    }

    public void Leave()
    {
        if (CurrentLocation.Parent is null)
        {
            Output.WriteLine("There's nowhere to leave. Travel instead.");
        }
        else if (CurrentLocation.Parent is Location l)
        {
            CurrentLocation = l;
        }
    }

    public bool RemoveItemFromLocation(Item item)
    {
        if (_currentLocation.Items.Contains(item))
        {
            _currentLocation.RemoveThing(item);
            return true;
        }
        return false;
    }

    public void AddItemToLocation(Item item)
    {
        _currentLocation.Items.Add(item);
    }

    public void TravelToAdjacentZone()
    {
        Output.WriteLine("Where would you like to go?");

        Output.WriteLine(1, ". North: ", (Map.North.Visited ? Map.North.Name : " Unknown"));
        Output.WriteLine(2, ". East: ", (Map.East.Visited ? Map.East.Name : " Unknown"));
        Output.WriteLine(3, ". South: ", (Map.South.Visited ? Map.South.Name : " Unknown"));
        Output.WriteLine(4, ". West: ", (Map.West.Visited ? Map.West.Name : " Unknown"));

        Output.WriteLine("0. Cancel");
        int input = Input.ReadInt(0, 4);

        if (input == 0) return;

        int minutes = Utils.RandInt(30, 60);
        Output.WriteLine("You travel for ", minutes, " minutes...");

        switch (input)
        {
            case 1:
                CurrentZone = Map.North;
                break;
            case 2:
                CurrentZone = Map.East;
                break;
            case 3:
                CurrentZone = Map.South;
                break;
            case 4:
                CurrentZone = Map.West;
                break;
        }

        World.Update(minutes);
    }

}================================================================================

File: ./PlayerComponents/CombatManager.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.PlayerComponents;
public class CombatManager
{
    public CombatManager(Actor owner)
    {
        Owner = owner;
    }

    public double CalculateAttackDamage(double baseDamage, double strength, double skillBonus, double otherModifiers)
    {
        double strengthModifier = (strength + 50) / 100;
        double damage = (baseDamage + skillBonus) * strengthModifier * otherModifiers;
        damage *= Utils.RandDouble(0.5, 2);
        return damage >= 0 ? damage : 0;
    }


    public double DetermineDamage()
    {
        double skillBonus = Owner._skillRegistry.GetLevel("Fighting");

        double conditionModifier = (2 - (Owner.ConditionPercent / 100)) / 2 + 0.1;
        return CalculateAttackDamage(
            Owner.ActiveWeapon.Damage, Owner.Body.CalculateStrength(), skillBonus, conditionModifier);
    }

    public double DetermineDodgeChance(Actor target)
    {
        double dodgeLevel = target._skillRegistry != null ? target._skillRegistry.GetLevel("Reflexes") : 0;
        double baseDodge = dodgeLevel / 100;
        double speedDiff = target.Body.CalculateSpeed() - Owner.Body.CalculateSpeed();
        double chance = baseDodge + speedDiff;
        // Output.WriteLine("Debug: Dodge Chance = ", chance);
        chance = Math.Clamp(chance, 0, .95);
        return chance;
    }

    public bool DetermineDodge(Actor target)
    {
        double dodgeChance = DetermineDodgeChance(target);
        if (Utils.DetermineSuccess(dodgeChance))
        {
            Output.WriteLine($"{Owner} dodged the attack!");
            return true;
        }
        return false;
    }

    public bool DetermineHit()
    {
        // Output.WriteLine("Debug: hit Chance: ", Owner.ActiveWeapon.Accuracy);
        double hitChance = Math.Clamp(Owner.ActiveWeapon.Accuracy, .01, .95);
        if (!Utils.DetermineSuccess(hitChance))
        {
            Output.WriteLine($"{Owner} missed!");
            return false;
        }
        return true;
    }

    public bool DetermineBlock(Actor target)
    {
        double blockLevel = target._skillRegistry != null ? target._skillRegistry.GetLevel("Defense") : 0;
        double skillBonus = blockLevel / 100;
        double attributeAvg =  target.Body.CalculateStrength(); // todo 
        double blockAtbAvg = target.ActiveWeapon.BlockChance + attributeAvg / 2;
        double blockChance = blockAtbAvg + skillBonus;
        if (Utils.DetermineSuccess(blockChance))
        {
            Output.WriteLine($"{target} blocked the attack!");
            return true;
        }
        return false;
    }

    public void Attack(Actor target)
    {
        double damage = DetermineDamage();
        if (DetermineDodge(target))
            return;
        if (!DetermineHit())
            return;
        if (DetermineBlock(target))
            return;

        DamageInfo damageInfo = new(
            damage,
            source: Owner.Name,
            isSharp: Owner.ActiveWeapon.Class == Items.WeaponClass.Blade,
            isBlunt: Owner.ActiveWeapon.Class == Items.WeaponClass.Blunt || Owner.ActiveWeapon.Class == Items.WeaponClass.Unarmed,
            accuracy: Owner.ActiveWeapon.Accuracy
        );

        Output.WriteLine($"{Owner} attacked {target} for {Math.Round(damage, 1)} damage!");
        target.Damage(damageInfo);
        // if (Utils.RandFloat(0, 1) < 0.1) // 10% critical hit chance
        //     target.ApplyEffect(new BleedEffect(1, 3));


        Owner._skillRegistry.AddExperience("Fighting", 1);
        Thread.Sleep(1000);
    }


    public Actor Owner { get; }
}
================================================================================

File: ./PlayerComponents/InventoryManager.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

public class InventoryManager
{
    public InventoryManager(EffectRegistry effectRegistry)
    {
        Armor = [];
        _unarmed = ItemFactory.MakeFists();
        Inventory = new Container("Bag", 10);
        _effectRegistry = effectRegistry;
    }
    private Container Inventory { get; }
    public List<Armor> Armor { get; }
    public Gear? HeldItem { get; private set; }
    private EffectRegistry _effectRegistry { get; }
    // weapon
    private Weapon? _weapon;
    private readonly Weapon _unarmed;
    public bool IsArmed => Weapon != _unarmed;
    public bool IsArmored => Armor.Count != 0;

    public Armor? GetArmorInSpot(EquipSpots spot) => Armor.FirstOrDefault(i => i.EquipSpot == spot);
    public Weapon Weapon
    {
        get => _weapon ?? _unarmed;
        set => _weapon = value;
    }

    public void AddToInventory(Item item)
    {
        Output.WriteLine("You put the ", item, " in your ", Inventory);
        Inventory.Add(item);
    }

    public void RemoveFromInventory(Item item)
    {
        Output.WriteLine("You take the ", item, " from your ", Inventory);
        Inventory.Remove(item);
    }

    public double ArmorRating
    {
        get
        {
            double rating = 0;
            foreach (Armor armor in Armor)
            {
                rating += armor.Rating;
                // rating += armor.Type switch
                // {
                //     ArmorClass.Light => Skills.LightArmor.Level * .01,
                //     ArmorClass.Heavy => Skills.HeavyArmor.Level * .01,
                //     _ => throw new ArgumentOutOfRangeException()
                // };
            }
            return rating;
        }
    }

    public double EquipmentWarmth => (HeldItem?.Warmth ?? 0) + Armor.Sum(a => a.Warmth);

    public void Equip(IEquippable item)
    {
        switch (item)
        {
            case Weapon weapon:
                Unequip(Weapon);
                Weapon = weapon;
                break;
            case Armor armor:
                var oldItem = Armor.FirstOrDefault(i => i.EquipSpot == armor.EquipSpot);
                if (oldItem != null) Unequip(oldItem);
                Armor.Add(armor);
                break;
            case Gear gear:
                if (HeldItem != null) Unequip(HeldItem);
                HeldItem = gear;
                break;
            default:
                Output.WriteLine("You can't equip that.");
                return;
        }
        Inventory.Remove((Item)item);
        item.EquipEffects.ForEach(_effectRegistry.AddEffect);
    }
    public void Unequip(IEquippable item)
    {
        if (item is not Gear gear) return;
        if (item == _unarmed) return;

        switch (gear)
        {
            case Weapon weapon:
                Weapon = _unarmed;
                break;
            case Armor armor:
                Armor.Remove(armor);
                break;
            case Gear g:
                HeldItem = null;
                break;
            default:
                Output.WriteLine("You can't unequip that.");
                return;
        }
        Output.WriteLine("You unequip ", gear);
        Inventory.Add(gear);
        gear.EquipEffects.ForEach(_effectRegistry.RemoveEffect);
    }
    public void CheckGear()
    {
        Describe.DescribeGear(this);
        Output.WriteLine("Would you like to unequip an item?");
        if (Input.ReadYesNo()) return;

        Output.WriteLine("Which item would you like to unequip?");
        // get list of all equipment
        var equipment = new List<IEquippable>();
        equipment.AddRange(Armor);
        if (IsArmed) equipment.Add(Weapon);
        if (HeldItem != null) equipment.Add(HeldItem);

        var choice = Input.GetSelectionFromList(equipment, true);
        if (choice == null) return;
        Unequip(choice);
    }

    public void Open(Player player)
    {
        while (!Inventory.IsEmpty)
        {
            Output.WriteLine(Inventory, " (", Inventory.Weight(), "/", Inventory.MaxWeight, "):");

            var options = ItemStack.CreateStacksFromItems(Inventory.Items);
            var selection = Input.GetSelectionFromList(options, true, "Close " + Inventory);
            if (selection == null) return;

            Item item = selection.Take();

            Output.WriteLine("What would you like to do with ", item);
            string? choice = Input.GetSelectionFromList(["Use", "Inspect", "Drop"], true);

            switch (choice)
            {
                case null:
                    continue;
                case "Use":
                    player.UseItem(item);
                    break;
                case "Inspect":
                    Describe.DescribeItem(item);
                    break;
                case "Drop":
                    player.DropItem(item);
                    break;
            }
        }
        Output.WriteLine(Inventory, " is empty.");
    }
}
================================================================================

File: ./PlayerComponents/ComponentInterfaces.cs
--------------------------------------------------------------------------------
using text_survival.Items;
using text_survival.Effects;
using text_survival.Actors;
using text_survival.Environments;
using text_survival.Bodies;

namespace text_survival.PlayerComponents;


public interface ISurvivalSystem
{
    bool IsAlive { get; }
    double ConditionPercent { get; }
    void Update();
    void Damage(DamageInfo damageInfo);
    void Heal(HealingInfo healingInfo);
    void Sleep(int minutes);
    void ConsumeFood(FoodItem food);
    void Describe();
}


public interface ILocationSystem
{
    Location CurrentLocation { get; set; }
    Zone CurrentZone { get; set; }
    void Leave();
    bool RemoveItemFromLocation(Item item);
    void AddItemToLocation(Item item);
}
================================================================================

File: ./PlayerComponents/SpellManager.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.IO;
using text_survival.Level;
using text_survival.Magic;

namespace text_survival.PlayerComponents;

class SpellManager
{
    public SpellManager(SkillRegistry skills)
    {
        _skills = skills;
        _spells.Add(SpellFactory.Bleeding);
        _spells.Add(SpellFactory.Poison);
        _spells.Add(SpellFactory.MinorHeal);
    }
    private readonly List<Spell> _spells = [];
    private readonly SkillRegistry _skills;
    public void SelectSpell(List<Actor> targets)
    {
        //get spell
        Output.WriteLine("Which spell would you like to cast?");
        var spell = Input.GetSelectionFromList(_spells, true);
        if (spell == null) return;

        // get target
        Output.WriteLine("Who would you like to cast ", spell.Name, " on?");
        var target = Input.GetSelectionFromList(targets, true);
        if (target == null) return;

        CastSpell(spell, target);
    }

    public void CastSpell(Spell spell, Actor target)
    {
        spell.Cast(target);
        _skills.AddExperience("Shamanism", 2);
    }
}================================================================================

File: ./PlayerComponents/SurvivalManager.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
using text_survival.Items;
using text_survival.Survival;
using text_survival.Effects;

namespace text_survival.PlayerComponents;

public class SurvivalManager : ISurvivalSystem
{
    public SurvivalManager(Actor owner, EffectRegistry effectRegistry, bool enableSurvivalMechanics, Body body)
    {
        Owner = owner;
        EnableSurvivalMechanics = enableSurvivalMechanics;
        HungerModule = new HungerModule();
        ThirstModule = new ThirstModule();
        ExhaustionModule = new ExhaustionModule();
        TemperatureModule = new TemperatureModule();
        Body = body;
        _effectRegistry = effectRegistry;
    }

    private readonly EffectRegistry _effectRegistry;
    // public void AddEffect(IEffect effect) => _effectRegistry.AddEffect(effect);
    // public void RemoveEffect(string effectType) => _effectRegistry.RemoveEffect(effectType);

    public void Heal(HealingInfo heal) => Body.Heal(heal);
    public void Damage(DamageInfo damage)
    {
        Body.Damage(damage);

        if (Body.IsDestroyed)
        {
            Output.WriteLine(Owner, " died!");
        }
    }


    public void Sleep(int minutes)
    {
        int minutesSlept = 0;
        while (minutesSlept < minutes)
        {
            ExhaustionModule.Rest(1);
            World.Update(1);
            minutesSlept++;
            if (ExhaustionModule.IsFullyRested)
            {
                Output.Write("You wake up feeling refreshed.\n");
                break;
            }
        }
        HealingInfo healing = new HealingInfo()
        {
            Amount = minutesSlept / 10,
            Type = "natural",
            TargetPart = "Body",
            Quality = ExhaustionModule.IsFullyRested ? 1 : .7, // healing quality is better after a full night's sleep
        };

        Heal(healing);
    }


    public void ConsumeFood(FoodItem food)
    {
        // if (HungerModule.Amount - food.Calories < 0)
        // {
        //     Output.Write("You are too full to finish it.\n");
        //     int percentageEaten = (int)(HungerModule.Amount / food.Calories) * 100;
        //     double calories = food.Calories * (100 - percentageEaten);
        //     double waterContent = food.WaterContent * (100 - percentageEaten);
        //     double weight = food.Weight * (100 - percentageEaten);
        //     food.calories = (int)calories;
        //     food.waterContent = (int)waterContent;
        //     food.weight
        //     // food = new FoodItem(food.Name, (int)calories, (int)waterContent, weight);
        //     HungerModule.Amount = 0;
        //     return;
        // }
        HungerModule.AddCalories(food.Calories);
        ThirstModule.AddHydration(food.WaterContent);

        if (food.HealthEffect != null)
        {
            Heal(food.HealthEffect);
        }
        if (food.DamageEffect != null)
        {
            Damage(food.DamageEffect);
        }
    }



    public void Update()
    {
        if (EnableSurvivalMechanics)
        {
            double feelsLikeTemp = Owner.CurrentZone.GetTemperature() + Owner.EquipmentWarmth;

            HungerModule.Update();
            ThirstModule.Update();
            ExhaustionModule.Update();
            TemperatureModule.Update(feelsLikeTemp);

            if (HungerModule.IsStarving || TemperatureModule.IsDangerousTemperature)
            {
                var damage = new DamageInfo()
                {
                    Amount = 1,
                    Type = TemperatureModule.IsDangerousTemperature ? "thermal" : "starvation",
                    IsPenetrating = HungerModule.IsStarving,
                };
                Owner.Damage(damage);
            }
        }
    }

    private Actor Owner { get; }
    private bool EnableSurvivalMechanics { get; }
    public Body Body { get; }
    private HungerModule HungerModule { get; }
    private ThirstModule ThirstModule { get; }
    private ExhaustionModule ExhaustionModule { get; }
    private TemperatureModule TemperatureModule { get; }

    // general condition, for now avg of exhaustion and body health
    public double ConditionPercent => (ExhaustionModule.ExhaustionPercent + (Body.Health / Body.MaxHealth * 100)) / 2;
    public bool IsAlive => !Body.IsDestroyed;


    public void Describe()
    {
        HungerModule.Describe();
        ThirstModule.Describe();
        ExhaustionModule.Describe();
        TemperatureModule.Describe();
    }

}
================================================================================

File: ./Effects/BleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects;

public class BleedEffect : Effect
{
    private float _damagePerHour;
    
    public BleedEffect(BodyPart targetPart, string source, float severity, float damagePerHour, int durationMin = -1)
        : base("Bleeding", source, targetPart, severity)
    {
        _damagePerHour = damagePerHour;
        
        // Configure effect properties
        SeverityChangeRate = -0.05f; // Natural clotting
        IsStackable = true; // Multiple cuts can stack
        
        // Configure capacity modifiers
        CapacityModifiers["BloodPumping"] = 0.2f; // Reduces blood pumping capacity by 20%
        CapacityModifiers["Consciousness"] = 0.1f; // Minor consciousness impact
    }
    
    protected override void OnApply(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"{target}'s {location} is bleeding!");
    }
    
    protected override void OnUpdate(Actor target)
    {
        // Calculate damage for one minute based on severity
        double damage = _damagePerHour / 60.0 * Severity;
        
        // Apply damage to the specific body part
        var damageInfo = new DamageInfo
        {
            Amount = damage,
            Type = "bleed",
            Source = Source,
            IsPenetrating = true, // Bleeding damage always penetrates
            TargetPart = TargetBodyPart?.Name
        };
        
        target.Damage(damageInfo);
        
        // Occasionally remind player of bleeding
        if (Utils.DetermineSuccess(0.05f) && Severity > 0.3f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"Blood continues to flow from {target}'s {location}...");
        }
    }
    
    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        if (updatedSeverity < 0.2f && oldSeverity >= 0.2f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"The bleeding on {target}'s {location} is slowing.");
        }
    }
    
    protected override void OnRemove(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"The bleeding on {target}'s {location} has stopped.");
    }
}================================================================================

File: ./Effects/RemoveBleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects
{
    public class RemoveBleedEffect : Effect
    {
        public RemoveBleedEffect(string source, BodyPart? targetBodyPart) : base("RemoveBleed", source, targetBodyPart, severity: 1.0f)
        {
        }

        protected override void OnApply(Actor target)
        {
            target.RemoveEffect("Bleed");
            Output.WriteLine(target, " stopped bleeding.");
            IsActive = false;
        }
    }
}================================================================================

File: ./Effects/HealEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;
public class HealEffect : Effect
{
    private float _healAmountPerHour;
    private string _targetPartName;

    public HealEffect(string source, BodyPart targetPart, float healAmount, int durationMin = 60)
        : base("Healing", source, targetPart, 1.0f)
    {
        _healAmountPerHour = healAmount;
        _targetPartName = targetPart?.Name ?? "body";

        // Configure effect properties
        IsStackable = false; // Healing doesn't stack
        SeverityChangeRate = -1.0f / durationMin; // Decreases to 0 over duration
    }

    protected override void OnApply(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"{Source} begins healing {target}'s {location}.");
    }

    protected override void OnUpdate(Actor target)
    {
        // Calculate healing for one minute
        float healAmount = _healAmountPerHour / 60.0f;

        // Apply healing
        var healInfo = new HealingInfo
        {
            Amount = healAmount,
            Quality = 1.0,
            Source = Source,
            TargetPart = _targetPartName
        };

        target.Heal(healInfo);

        // Visual effect based on severity (how much healing is left)
        if (Utils.DetermineSuccess(0.05f))
        {
            string location = _targetPartName;
            if (Severity > 0.7f)
            {
                Output.WriteLine($"Fresh healing is occurring in {target}'s {location}.");
            }
            else if (Severity > 0.3f)
            {
                Output.WriteLine($"The healing in {target}'s {location} continues steadily.");
            }
            else
            {
                Output.WriteLine($"The healing in {target}'s {location} is nearly complete.");
            }
        }
    }

    protected override void OnRemove(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"The healing process on {target}'s {location} is complete.");
    }
}================================================================================

File: ./Effects/EffectRegistry.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;
public class EffectRegistry(Actor owner)
{
    public IReadOnlyList<Effect> GetActiveEffects() => _effects.AsReadOnly();

    public void AddEffect(Effect effect)
    {
        if (_effects.Contains(effect)) return;

        BodyPart? part = effect.TargetBodyPart;
        if (part != null)
        {
            if (!effect.IsStackable)
            {
                var existingEffect = _effects.FirstOrDefault(e => e.TargetBodyPart == part && e.EffectKind == effect.EffectKind);
                if (existingEffect != null)
                {
                    double newSeverity = Math.Max(existingEffect.Severity, effect.Severity);
                    existingEffect.UpdateSeverity(_owner, newSeverity);
                    return;
                }
            }
        }

        _effects.Add(effect);
        effect.Apply(_owner);
    }

    public void RemoveEffect(Effect effect)
    {
        if (_effects.Remove(effect))
        {
            effect.Remove(_owner);
        }
        else
        {
            Output.WriteWarning("ERROR: couldn't find effect to remove.");
        }
    }
    public void Update()
    {
        _effects.ForEach(e => e.Update(_owner));
        // Clean up inactive effects
        _effects.RemoveAll(e => !e.IsActive);
    }


    public double GetPartCapacityModifier(string capacity, BodyPart part) => GetEffectsOnBodyPart(part).Sum(e => e.CapacityModifiers.GetValueOrDefault(capacity) * e.Severity);
    public double GetBodyCapacityModifier(string capacity) => _effects.Where(e => e.TargetBodyPart == null).Sum(e => e.CapacityModifiers.GetValueOrDefault(capacity) * e.Severity);


    public IEnumerable<Effect> GetEffectsOnBodyPart(BodyPart part) => _effects.Where(e => e.TargetBodyPart == part);
    public IEnumerable<Effect> GetEffectsByKind(string kind) => _effects.Where(e => e.EffectKind == kind);


    private readonly Actor _owner = owner;
    private List<Effect> _effects = [];
}================================================================================

File: ./Effects/PoisonEffect.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

public class PoisonEffect : Effect
{
    private float _damagePerHour;
    private string _poisonType;
    
    public PoisonEffect(string poisonType, string source, float severity, float damagePerHour, int durationMin = 60)
        : base("Poison", source, null, severity) // Poison is typically whole-body
    {
        _damagePerHour = damagePerHour;
        _poisonType = poisonType;
        
        // Configure effect properties
        SeverityChangeRate = -0.02f; // Slow natural detoxification
        IsStackable = true; // Multiple poison sources can stack
        
        // Configure capacity modifiers - affect whole body
        CapacityModifiers["Consciousness"] = 0.3f * severity;
        CapacityModifiers["Manipulation"] = 0.2f * severity;
        CapacityModifiers["Moving"] = 0.2f * severity;
        CapacityModifiers["BloodFiltration"] = 0.4f * severity;
    }
    
    protected override void OnApply(Actor target)
    {
        Output.WriteLine($"{target} has been poisoned with {_poisonType}!");
    }
    
    protected override void OnUpdate(Actor target)
    {
        // Calculate damage for one minute based on severity
        double damage = _damagePerHour / 60.0 * Severity;
        
        // Apply poison damage randomly to internal organs
        // Get list of internal parts
        var internalParts = target.Body.GetAllParts()
            .Where(p => p.IsInternal && !p.IsDestroyed)
            .ToList();
            
        if (internalParts.Count > 0)
        {
            // Target a random internal organ for damage
            var targetPart = internalParts[Utils.RandInt(0, internalParts.Count - 1)];
            
            var damageInfo = new DamageInfo
            {
                Amount = damage,
                Type = "poison",
                Source = Source,
                IsPenetrating = true, // Poison always penetrates
                TargetPart = targetPart.Name
            };
            
            target.Damage(damageInfo);
        }
        else
        {
            // Fallback to general damage
            var damageInfo = new DamageInfo
            {
                Amount = damage,
                Type = "poison",
                Source = Source,
                IsPenetrating = true
            };
            
            target.Damage(damageInfo);
        }
        
        // Symptoms based on severity
        if (Severity > 0.7 && Utils.DetermineSuccess(0.2))
        {
            Output.WriteLine($"{target} vomits violently from the {_poisonType} poisoning.");
        }
        else if (Severity > 0.4f && Utils.DetermineSuccess(0.1))
        {
            Output.WriteLine($"{target} trembles from the effects of the {_poisonType} poison.");
        }
    }
    
    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update capacity modifiers based on new severity
        CapacityModifiers["Consciousness"] = 0.3 * updatedSeverity;
        CapacityModifiers["Manipulation"] = 0.2 * updatedSeverity;
        CapacityModifiers["Moving"] = 0.2 * updatedSeverity;
        
        if (updatedSeverity < 0.3 && oldSeverity >= 0.3)
        {
            Output.WriteLine($"The {_poisonType} poisoning is becoming less severe.");
        }
    }
    
    protected override void OnRemove(Actor target)
    {
        Output.WriteLine($"{target} has recovered from {_poisonType} poisoning.");
    }
}================================================================================

File: ./Effects/Effect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects
{
    // public interface IEffect
    // {
    //     string EffectType { get; }
    //     bool IsActive { get; }
    //     // float Severity { get; }
    //     // int DurationMin { get; } // Total duration in minutes
    //     // int RemainingDurationMin { get; } // Remaining duration in minutes

    //     void Apply(IActor target);
    //     void Update(IActor target);
    //     void Remove(IActor target);
    // }

    public abstract class Effect
    {
        protected Effect(string effectKind, string source, BodyPart? targetBodyPart = null, double severity = 1, double severityChangeRate = 0)
        {
            EffectKind = effectKind;
            Source = source;
            TargetBodyPart = targetBodyPart;
            Severity = severity;
            SeverityChangeRate = severityChangeRate;

            IsActive = true;
            IsStackable = false;
            RequiresTreatment = false;
        }

        public string EffectKind { get; protected set; }
        public string Source { get; } // what caused this effect (e.g., cold, wound poison)
        public BodyPart? TargetBodyPart { get; }
        public bool IsStackable { get; protected set; }
        public bool IsActive { get; protected set; }
        public double Severity { get; protected set; }
        public double SeverityChangeRate { get; protected set; } // per severity reduction per hour
        public bool RequiresTreatment { get; protected set; }
        public Dictionary<string, double> CapacityModifiers { get; } = [];
        // public List<TreatmentOption> TreatmentOptions {get;}

        // main algorithm methods - typically don't override
        public void Apply(Actor target)
        {
            IsActive = true;
            OnApply(target);
        }

        public void Update(Actor target)
        {
            if (!IsActive) return;

            if (!RequiresTreatment && SeverityChangeRate > 0)
            {
                double minuteChange = SeverityChangeRate / 60;
                double oldSeverity = Severity;
                Severity = Math.Max(0, Severity + minuteChange);

                if (Math.Abs(Severity - oldSeverity) > .01)
                {
                    OnSeverityChange(target, oldSeverity, Severity);
                }

                if (Severity <= 0)
                {
                    Remove(target);
                    return;
                }
            }

            OnUpdate(target);
        }
        public void Remove(Actor target)
        {
            if (!IsActive) return;
            OnRemove(target);
            IsActive = false;
        }
        public virtual void UpdateSeverity(Actor target, double severityChange)
        {
            if (!IsActive) return;

            double oldSeverity = Severity;

            Severity = Math.Clamp(Severity + severityChange, 0, 1);

            if (Math.Abs(oldSeverity - Severity) > 0.01)
            {
                OnSeverityChange(target, oldSeverity, Severity);
            }
        }


        // hook methods that can be implemented by sub classes
        protected virtual void OnApply(Actor target) { }
        protected virtual void OnUpdate(Actor target) { }
        protected virtual void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity) { }
        protected virtual void OnRemove(Actor target) { }


        // UI methods
        public string GetSeverityDescription()
        {
            if (Severity < 0.3f) return "Minor";
            if (Severity < 0.7f) return "Moderate";
            if (Severity < 0.9f) return "Severe";
            return "Critical";
        }
        public virtual string Describe()
        {
            string severityDesc = GetSeverityDescription();
            string locationDesc = TargetBodyPart != null ? $" on {TargetBodyPart.Name}" : "";
            return $"{severityDesc} {EffectKind}{locationDesc}";
        }
    }
}================================================================================

File: ./Body/Injury.cs
--------------------------------------------------------------------------------
using text_survival.Effects;

namespace text_survival.Bodies;
public class Injury : Effect
{
    public eInjuryType InjuryType { get; }

    public enum eInjuryType
    {
        Cut,
        Bruise,
        Break,
        Burn,
        Frostbite,
        Infection
    }

    public Injury(eInjuryType type, string source, BodyPart bodyPart, float severity) : base(type.ToString(), source, bodyPart, severity)
    {
        InjuryType = type;
        Severity = Math.Clamp(severity, 0, 1);

        // Configure based on type
        switch (type)
        {
            case eInjuryType.Cut:
                EffectKind = "Cut";
                SeverityChangeRate = -0.05; // Per day
                CapacityModifiers["Manipulation"] = 0.3;
                CapacityModifiers["Moving"] = 0.1;
                break;

            case eInjuryType.Bruise:
                EffectKind = "Bruise";
                SeverityChangeRate = -0.1; // Per day
                CapacityModifiers["Manipulation"] = 0.1;
                CapacityModifiers["Moving"] = 0.1;
                break;

            case eInjuryType.Break:
                EffectKind = "Broken";
                SeverityChangeRate = -0.01; // Very slow healing
                CapacityModifiers["Manipulation"] = 0.8;
                CapacityModifiers["Moving"] = 0.8;
                break;

            case eInjuryType.Burn:
                EffectKind = "Burn";
                SeverityChangeRate = -0.03;
                CapacityModifiers["Manipulation"] = 0.4;
                break;

            case eInjuryType.Frostbite:
                EffectKind = "Frostbite";
                SeverityChangeRate = -0.02;
                CapacityModifiers["Manipulation"] = 0.5;
                CapacityModifiers["Moving"] = 0.5;
                break;

            case eInjuryType.Infection:
                EffectKind = "Infection";
                SeverityChangeRate = 0.02; // Gets worse over time
                CapacityModifiers["Manipulation"] = 0.2;
                CapacityModifiers["Vitality"] = 0.4;
                break;
        }
    }

    // public override void ApplyTreatment(TreatmentInfo treatment)
    // {
    //     // Different treatments have different effectiveness
    //     double effectiveAmount = 0;

    //     switch (treatment.Type)
    //     {
    //         case "bandage":
    //             if (InjuryType == eInjuryType.Cut || InjuryType == eInjuryType.Burn)
    //             {
    //                 effectiveAmount = 0.2;
    //             }
    //             break;

    //         case "splint":
    //             if (InjuryType == eInjuryType.Break)
    //             {
    //                 effectiveAmount = 0.1;
    //             }
    //             break;

    //         case "antibiotics":
    //             if (InjuryType == eInjuryType.Infection)
    //             {
    //                 effectiveAmount = 0.5;
    //             }
    //             break;

    //         case "warmth":
    //             if (InjuryType == eInjuryType.Frostbite)
    //             {
    //                 effectiveAmount = 0.3;
    //             }
    //             break;
    //     }

    //     // Apply quality factor
    //     effectiveAmount *= treatment.Quality;

    //     // Reduce severity
    //     Severity -= effectiveAmount;
    //     Severity = Math.Clamp(Severity, 0, 1);
    // }
}================================================================================

File: ./Body/BodyPart.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Bodies;
public class BodyPart
{
    // Core properties
    public string Name { get; }
    public double Health { get; private set; }
    public double MaxHealth { get; }
    public bool IsVital { get; }
    public bool IsInternal { get; }
    public bool IsDamaged => Health < MaxHealth;
    public bool IsDestroyed => Health <= 0;

    public double Coverage { get; set; } // Percentage of parent this part covers
    public double EffectiveCoverage { get; private set; }

    // Hierarchy
    public BodyPart? Parent { get; private set; }
    private List<BodyPart> _parts = new();
    public IReadOnlyList<BodyPart> Parts => _parts.AsReadOnly();

    // Physical state
    private Dictionary<string, double> _baseCapacities = new();

    public BodyPart(string name, double maxHealth, bool isVital, bool isInternal, double coverage)
    {
        Name = name;
        MaxHealth = maxHealth;
        Health = maxHealth;
        IsVital = isVital;
        IsInternal = isInternal;
        Coverage = coverage;
        _baseCapacities = new Dictionary<string, double>();
    }

    // Capacity management
    public void SetBaseCapacity(string capacity, double value)
    {
        _baseCapacities[capacity] = value;
    }

    public double GetCapacity(string capacity)
    {
        if (!_baseCapacities.TryGetValue(capacity, out double baseValue))
        {
            return 0;
        }

        // Apply health scaling
        return baseValue * (Health / MaxHealth);
    }

    public IReadOnlyDictionary<string, double> GetCapacities()
    {
        var result = new Dictionary<string, double>();
        foreach (var pair in _baseCapacities)
        {
            result[pair.Key] = GetCapacity(pair.Key);
        }
        return result;
    }


    // Hierarchical structure
    public void AddPart(BodyPart part)
    {
        part.Parent = this;
        _parts.Add(part);
    }

    public void Heal(HealingInfo healingInfo)
    {
        if (IsDestroyed) return;

        // Handle targeted healing
        if (healingInfo.TargetPart != null && healingInfo.TargetPart != Name)
        {
            // Try to find the targeted part
            var targetPart = FindPartByName(healingInfo.TargetPart);
            if (targetPart != null)
            {
                targetPart.Heal(healingInfo);
                return;
            }
        }

        // Distribute healing
        if (_parts.Count > 0 && healingInfo.TargetPart == null)
        {
            // Prioritize damaged parts for healing
            var damagedParts = _parts.Where(p => p.IsDamaged).ToList();
            if (damagedParts.Count > 0)
            {
                damagedParts[Utils.RandInt(0, damagedParts.Count - 1)].Heal(healingInfo);
                return;
            }

            // Random distribution if no parts are damaged
            if (Utils.FlipCoin())
            {
                BodyPart p = _parts[Utils.RandInt(0, _parts.Count - 1)];
                p.Heal(healingInfo);
                return;
            }
        }

        // Apply healing to this part
        double adjustedAmount = healingInfo.Amount * healingInfo.Quality;
        Health += adjustedAmount;
        if (Health > MaxHealth)
        {
            Health = MaxHealth;
        }
    }

    public void CalculateEffectiveCoverage()
    {
        if (Parent == null)
        {
            EffectiveCoverage = 1.0; // Root part has 100% chance
            return;
        }

        // My coverage of parent × parent's effective coverage
        EffectiveCoverage = (Coverage / 100.0) * Parent.EffectiveCoverage;

        // Calculate for all children
        foreach (var part in _parts)
        {
            part.CalculateEffectiveCoverage();
        }
    }

    public void Damage(DamageInfo damageInfo)
    {
        if (IsDestroyed) return;

        if (damageInfo.TargetPart == null)
        {
            // Standard untargeted damage
            DamageUntargeted(damageInfo);
            return;
        }

        // Handle targeted damage - but still allow for sub-part hits
        if (damageInfo.TargetPart == Name)
        {
            if (_parts.Count == 0)
            {
                ApplyDamage(damageInfo);
                return;
            }


            if (Utils.DetermineSuccess(damageInfo.Accuracy))
            {
                // Direct hit on the targeted part
                ApplyDamage(damageInfo);
                return;
            }

            // Even when targeting, there's a chance to hit sub-parts
            // Higher accuracy for targeted hits - use 75% of normal child coverage
            var partChances = new Dictionary<BodyPart, double>();
            double totalChildCoverage = 0;

            foreach (var part in _parts)
            {
                // Reduce child coverage to make it more likely to hit the targeted part
                double adjustedCoverage = part.Coverage * 0.75;
                partChances[part] = adjustedCoverage;
                totalChildCoverage += adjustedCoverage;
            }

            // Add self with remaining coverage - more likely than with random hits
            double selfCoverage = 100 - totalChildCoverage;
            partChances[this] = selfCoverage;

            BodyPart hit = Utils.GetRandomWeighted(partChances);
            if (hit == this)
            {
                ApplyDamage(damageInfo);
            }
            else
            {
                // When hitting a child on a targeted attack, we should
                // propagate that this was intentional targeting
                damageInfo.TargetPart = hit.Name; // Update target to child part
                damageInfo.Accuracy *= 0.8; // Reduce accuracy for child hit
                hit.Damage(damageInfo);
            }
            return;
        }
        else // Handle targeted damage for a different part (searching)
        {
            // Look for the targeted part among children
            var targetedPart = FindPartByName(damageInfo.TargetPart);

            if (targetedPart != null && Utils.DetermineSuccess(damageInfo.Accuracy)) // chance to miss based on accuracy
            {
                // Found the part - propagate damage to it
                targetedPart.Damage(damageInfo);
                return;
            }

            // Target not found as a descendant - try to hit this part instead
            // But with reduced damage since the intended target was missed
            damageInfo.Amount = damageInfo.Amount * 0.7; // Reduced damage for missing intended target
            damageInfo.TargetPart = null; // Clear targeting since we're defaulting

            // Process as untargeted hit
            DamageUntargeted(damageInfo);
        }
    }

    // Separate method for untargeted damage distribution
    private void DamageUntargeted(DamageInfo damageInfo)
    {
        // Distribute damage based on coverage
        if (_parts.Count > 0)
        {
            // Get all parts with their coverage values
            var partChances = new Dictionary<BodyPart, double>();
            double totalChildCoverage = 0;

            foreach (var part in _parts)
            {
                partChances[part] = part.Coverage;
                totalChildCoverage += part.Coverage;
            }

            // Add self with remaining coverage
            double selfCoverage = 100 - totalChildCoverage;
            partChances[this] = selfCoverage;

            BodyPart hit = Utils.GetRandomWeighted(partChances);
            if (hit == this)
            {
                ApplyDamage(damageInfo);
            }
            else
            {
                hit.Damage(damageInfo);
            }
            return;

        }

        // Default if no children or calculation issue
        ApplyDamage(damageInfo);
    }

    // Helper method to find a part by name in the hierarchy
    private BodyPart? FindPartByName(string partName)
    {
        if (Name == partName) return this;

        foreach (var part in _parts)
        {
            var foundPart = part.FindPartByName(partName);
            if (foundPart != null) return foundPart;
        }

        return null;
    }

    // Method to actually apply damage
    private void ApplyDamage(DamageInfo damageInfo)
    {
        // Apply damage reduction for internal parts if damage is not penetrating
        double damageAmount = damageInfo.Amount;
        if (IsInternal && !damageInfo.IsPenetrating)
        {
            damageAmount *= 0.5; // 50% damage reduction for internal parts
        }

        Health -= damageAmount;
        Output.WriteLine(this, " took ", damageAmount, " damage");
        // Handle destruction
        if (IsDestroyed)
        {
            Health = 0;
            if (IsVital && Parent != null)
            {
                var criticalDamage = new DamageInfo
                {
                    Amount = Parent.MaxHealth * 0.5,
                    Type = "critical",
                    Source = damageInfo.Source,
                    IsPenetrating = true // Critical damage always penetrates
                };
                Parent.Damage(criticalDamage);
            }
        }
    }
    public override string ToString() => Name;
}================================================================================

File: ./Body/Body.cs
--------------------------------------------------------------------------------
using text_survival.Effects;

namespace text_survival.Bodies;
public class Body
{
    // Root part and core properties
    private readonly BodyPart _rootPart;
    public string Name => _rootPart.Name;
    public double Health => _rootPart.Health;
    public double MaxHealth => _rootPart.MaxHealth;
    public bool IsDestroyed => _rootPart.IsDestroyed;

    private EffectRegistry _effectRegistry;

    // Physical composition
    private double _bodyFat;
    private double _muscle;
    private double _weight;
    private readonly double _baseWeight;

    // Physical systems
    private double _coreTemperature = 98.6; // Fahrenheit
    private double _targetMetabolismRate = 2000; // Calories per day

    public Body(BodyPart rootPart, double overallWeight, double fatPercent, double musclePercent, EffectRegistry effectRegistry)
    {
        _rootPart = rootPart;
        _effectRegistry = effectRegistry;

        // Initialize physical composition
        _bodyFat = overallWeight * (fatPercent / 100);
        _muscle = overallWeight * (musclePercent / 100);
        _baseWeight = overallWeight - _bodyFat - _muscle;
        UpdateWeight();
    }

    // Physical composition properties
    public double BodyFat
    {
        get => _bodyFat;
        set
        {
            _bodyFat = Math.Max(value, 0);
            UpdateWeight();
        }
    }

    public double Muscle
    {
        get => _muscle;
        set
        {
            _muscle = Math.Max(value, 0);
            UpdateWeight();
        }
    }

    public double BodyFatPercentage => _bodyFat / Weight;
    public double MusclePercentage => _muscle / Weight;
    public double Weight => _weight;

    // Core temperature and metabolism
    public double CoreTemperature => _coreTemperature;
    public double BasalMetabolicRate => CalculateMetabolicRate();

    // Update physical state
    private void UpdateWeight()
    {
        _weight = _baseWeight + _bodyFat + _muscle;
    }

    // Calculate metabolic rate based on composition
    private double CalculateMetabolicRate()
    {
        // Base BMR uses the Harris-Benedict equation (simplified)
        double bmr = 370 + (21.6 * _muscle) + (6.17 * _bodyFat);

        // Adjust for injuries and conditions
        double healthFactor = _rootPart.Health / _rootPart.MaxHealth;
        bmr *= 0.7 + (0.3 * healthFactor); // Injured bodies need more energy to heal

        return bmr;
    }

    // Forwarding methods to root part
    public void Damage(DamageInfo damageInfo) => _rootPart.Damage(damageInfo);
    public void Heal(HealingInfo healingInfo) => _rootPart.Heal(healingInfo);

    // Update body state over time
    public void Update(TimeSpan timePassed, EnvironmentInfo environment)
    {
        // Handle temperature regulation
        UpdateTemperature(environment.Temperature, environment.EquipmentWarmth, timePassed);

        // Handle metabolism and energy expenditure
        UpdateMetabolism(environment.ActivityLevel, timePassed);
    }

    // Temperature regulation
    private void UpdateTemperature(double environmentalTemp, double insulationFactor, TimeSpan timePassed)
    {
        // Calculate temperature differential
        double tempDifferential = environmentalTemp - _coreTemperature;

        // Body fat provides natural insulation
        double naturalInsulation = 0.1 + (BodyFatPercentage / 2);

        // Combined insulation factor
        double totalInsulation = naturalInsulation + insulationFactor;

        // Calculate temperature change rate (degrees per hour)
        double hourlyChange = tempDifferential * (1.0 - totalInsulation) / 5.0;

        // Apply for the time that has passed
        double hoursElapsed = timePassed.TotalHours;
        _coreTemperature += hourlyChange * hoursElapsed;

        // Trigger shivering or sweating based on temperature
        if (_coreTemperature < 97.0)
        {
            // Shivering increases metabolism to generate heat
            _targetMetabolismRate *= 1.2;
        }
        else if (_coreTemperature > 100.0)
        {
            // Sweating increases water loss
            // This would connect to the thirst system
        }
    }

    // Metabolism updates
    private void UpdateMetabolism(double activityLevel, TimeSpan timePassed)
    {
        // Calculate calorie burn based on BMR, activity, and time
        double hourlyBurn = BasalMetabolicRate / 24.0 * activityLevel;
        double calories = hourlyBurn * timePassed.TotalHours;

        // If calories aren't provided externally, burn fat
        double fatBurnRate = calories / 7700.0; // ~7700 calories per kg of fat
        BodyFat -= fatBurnRate;

        // If completely out of fat, burn muscle
        if (BodyFat <= 0 && _muscle > 0)
        {
            double muscleBurnRate = calories / 7700.0 * 0.8; // Muscle burns less efficiently
            Muscle -= muscleBurnRate;
        }
    }

    // Calculate derived attributes
    public double CalculateStrength()
    {
        double manipulationCapacity = GetCapacity("Manipulation");
        double bloodPumping = GetCapacity("BloodPumping"); // Energy delivery

        // Base strength that everyone has
        double baseStrength = 0.3; // 30% strength from structural aspects

        // Muscle contribution with diminishing returns
        double muscleContribution;
        if (MusclePercentage < 0.2) // Below normal
            muscleContribution = MusclePercentage * 2.5; // Rapid gains when building from low muscle
        else if (MusclePercentage < 0.4) // Normal to athletic
            muscleContribution = 0.5 + (MusclePercentage - 0.2) * 1.0; // Moderate gains
        else // Athletic+
            muscleContribution = 0.7 + (MusclePercentage - 0.4) * 0.5; // Diminishing returns

        // Energy state affects strength expression
        double energyFactor = Math.Min(bloodPumping, 1.0);

        // Very low body fat impairs strength
        double fatPenalty = (BodyFatPercentage < 0.05) ? (0.05 - BodyFatPercentage) * 3.0 : 0;

        return manipulationCapacity * (baseStrength + muscleContribution * energyFactor - fatPenalty);
    }

    public double CalculateSpeed()
    {
        double movingCapacity = GetCapacity("Moving");
        double muscleBonus = Math.Min(MusclePercentage * 0.5, 0.2); // Up to 20% bonus from muscle
        double fatPenalty;

        // Minimal fat has no penalty, excess has increasing penalties
        if (BodyFatPercentage < 0.1) // 10% is minimal necessary fat
            fatPenalty = 0;
        else
            fatPenalty = (BodyFatPercentage - 0.1) * 1.2; // Steeper penalty for excess fat

        // Weight ratio with diminishing penalty
        double weightRatio = Math.Pow(_baseWeight / Weight, 0.7); // Less severe exponent

        return movingCapacity * (1 + muscleBonus - fatPenalty) * weightRatio;
    }
    private double CalculateVitality()
    {
        double breathing = GetCapacity("Breathing");
        double bloodPumping = GetCapacity("BloodPumping");
        double digestion = GetCapacity("Digestion");

        // Base vitality that scales more gently with body composition
        double baseMultiplier = 0.7;  // Everyone gets 70% baseline
        double muscleContribution = MusclePercentage * 0.25;  // Up to 25% from muscle
        double fatContribution;

        // Essential fat is beneficial, excess isn't
        if (BodyFatPercentage < .10)
            fatContribution = BodyFatPercentage * 0.5;  // Fat is very important when low
        else if (BodyFatPercentage < .25)
            fatContribution = 0.05;  // Optimal fat gives 5%
        else
            fatContribution = 0.05 - (BodyFatPercentage - .25) * 0.1;  // Excess fat penalizes slightly

        return (breathing + bloodPumping + digestion) / 3 * (baseMultiplier + muscleContribution + fatContribution);
    }

    private double CalculatePerception()
    {
        double sight = GetCapacity("Sight");
        double hearing = GetCapacity("Hearing");

        return (sight + hearing) / 2;
    }

    private double CalculateColdResistance()
    {
        // Base cold resistance that everyone has
        double baseColdResistance = 0.5;
        double fatInsulation;

        if (BodyFatPercentage < 0.05)
            fatInsulation = (BodyFatPercentage / 0.05) * 0.1;  // Linear up to 5%
        else if (BodyFatPercentage < 0.15)
            fatInsulation = 0.1 + ((BodyFatPercentage - 0.05) / 0.1) * 0.15;  // From 0.1 to 0.25
        else
            fatInsulation = 0.25 + ((BodyFatPercentage - 0.15)) * 0.15;  // Diminishing returns after 15%

        return baseColdResistance + fatInsulation;
    }


    private double GetCapacity(string capacity)
    {
        var parts = GetAllParts().Where(p => p.GetCapacity(capacity) > 0);
        var values = parts.Select(p => GetEffectivePartCapacity(p, capacity)).ToList();
        if (values.Sum() <= 0) return 0;

        double result;
        if (capacity is "Moving" or "Manipulation" or "Breathing" or "Consciousness"
        or "BloodPumping" or "Digestion" or "Eating" or "Talking")
        {
            result = values.Min();
        }
        else if (capacity is "Sight" or "Hearing" or "BloodFiltration")
        {
            result = values.Average();
        }
        else
        {
            result = values.Min();
        }
        double bodyModifier = _effectRegistry.GetBodyCapacityModifier(capacity);
        result *= (1 + bodyModifier);
        result = Math.Max(0, result);
        return result;
    }

    private double GetEffectivePartCapacity(BodyPart part, string capacityName)
    {
        if (part.IsDestroyed) return 0;

        // Get base capacity (already includes health scaling)
        double baseCapacity = part.GetCapacity(capacityName);
        if (baseCapacity <= 0) return 0;

        // Apply effect modifiers for this part
        double modifier = _effectRegistry.GetPartCapacityModifier(capacityName, part);
        return Math.Max(0, baseCapacity * (1.0 + modifier));
    }


    // Helper to get all body parts
    private List<BodyPart> GetAllParts()
    {
        var result = new List<BodyPart>();
        CollectBodyParts(_rootPart, result);
        return result;
    }

    private void CollectBodyParts(BodyPart part, List<BodyPart> result)
    {
        result.Add(part);
        foreach (var child in part.Parts)
        {
            CollectBodyParts(child, result);
        }
    }

    // Environment info for updates
    public class EnvironmentInfo
    {
        public double Temperature { get; set; } = 70.0; // Fahrenheit
        public double EquipmentWarmth { get; set; } = 0.0;
        public double ActivityLevel { get; set; } = 1.0; // 1.0 = normal
    }
}================================================================================

File: ./Body/BodyInterfaces.cs
--------------------------------------------------------------------------------

namespace text_survival.Bodies;


// Comprehensive damage information
public class DamageInfo
{
    public DamageInfo() { }
    public DamageInfo(double amount,
                      string type = "physical",
                      string? source = null,
                      string? targetPart = null,
                      bool isPenetrating = false,
                      bool isBlunt = false,
                      bool isSharp = false,
                      double accuracy = .9)
    {
        Amount = amount;
        Type = type;
        Source = source;
        TargetPart = targetPart;
        IsPenetrating = isPenetrating;
        IsBlunt = isBlunt;
        IsSharp = isSharp;
        Accuracy = accuracy;
    }

    public double Amount { get; set; }
    public string Type { get; set; } = "physical"; // physical, thermal, poison, etc.
    public string? Source { get; set; }
    public string? TargetPart { get; set; } // Optional specific target
    public bool IsPenetrating { get; set; } = false;
    public bool IsSharp { get; set; } = false;
    public bool IsBlunt { get; set; } = false;
    public double Accuracy { get; set; } = .9;
}

// Comprehensive healing information
public class HealingInfo
{
    public double Amount { get; set; }
    public string Type { get; set; } = "natural"; // natural, medical, magical
    public string? TargetPart { get; set; }
    public double Quality { get; set; } = 1.0; // Effectiveness multiplier
    public string? Source { get; set; }
}

================================================================================

File: ./Body/BodyPartFactory.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Bodies
{
    public static class BodyPartFactory
    {
        public static BodyPart CreateHumanBody(string name, double hp)
        {
            BodyPart body = new BodyPart(name, hp, true, false, 100);
            
            // Torso (main part)
            BodyPart torso = new BodyPart("Torso", hp * 0.8, true, false, 100);
            body.AddPart(torso);
            
            // Neck (7.5% of torso)
            BodyPart neck = CreateNeck(hp * 0.625);
            torso.AddPart(neck);
            
            // Spine (2.5% of torso)
            BodyPart spine = CreateSpine(hp * 0.625);
            torso.AddPart(spine);
            
            // Ribcage (3.6% of torso)
            BodyPart ribcage = CreateRibcage(hp * 0.75);
            torso.AddPart(ribcage);
            
            // Sternum (1.5% of torso)
            BodyPart sternum = CreateSternum(hp * 0.5);
            torso.AddPart(sternum);
            
            // Internal organs
            // Stomach (2.5% of torso)
            BodyPart stomach = CreateStomach(hp * 0.5);
            torso.AddPart(stomach);
            
            // Heart (2.0% of torso)
            BodyPart heart = CreateHeart(hp * 0.375);
            torso.AddPart(heart);
            
            // Lungs (2.5% each, total 5.0% of torso)
            BodyPart leftLung = CreateLungs(hp * 0.375, "Left Lung");
            torso.AddPart(leftLung);
            
            BodyPart rightLung = CreateLungs(hp * 0.375, "Right Lung");
            torso.AddPart(rightLung);
            
            // Kidneys (1.7% each, total 3.4% of torso)
            BodyPart leftKidney = CreateKidney(hp * 0.375, "Left Kidney");
            torso.AddPart(leftKidney);
            
            BodyPart rightKidney = CreateKidney(hp * 0.375, "Right Kidney");
            torso.AddPart(rightKidney);
            
            // Liver (2.5% of torso)
            BodyPart liver = CreateLiver(hp * 0.5);
            torso.AddPart(liver);
            
            // Pelvis (2.5% of torso)
            BodyPart pelvis = CreatePelvis(hp * 0.625);
            torso.AddPart(pelvis);
            
            // Shoulders (12% of torso, 6% each)
            BodyPart leftShoulder = CreateShoulder(hp * 0.75, "Left Shoulder");
            torso.AddPart(leftShoulder);
            
            BodyPart rightShoulder = CreateShoulder(hp * 0.75, "Right Shoulder");
            torso.AddPart(rightShoulder);
            
            // Legs (14% of torso, 7% each)
            BodyPart leftLeg = CreateLeg(hp * 0.75, "Left Leg");
            torso.AddPart(leftLeg);
            
            BodyPart rightLeg = CreateLeg(hp * 0.75, "Right Leg");
            torso.AddPart(rightLeg);
            
            // Calculate effective coverage
            body.CalculateEffectiveCoverage();
            
            return body;
        }
        
        public static BodyPart CreateAnimalBody(string name, double hp)
        {
            BodyPart body = new BodyPart(name, hp, true, false, 100);
            
            // Torso
            BodyPart torso = new BodyPart("Torso", hp * 0.8, true, false, 100);
            body.AddPart(torso);
            
            // Head (10% of torso)
            BodyPart head = CreateHead(hp * 0.625);
            torso.AddPart(head);
            
            // Internal organs with appropriate coverage
            BodyPart heart = CreateHeart(hp * 0.375);
            torso.AddPart(heart);
            
            BodyPart leftLung = CreateLungs(hp * 0.375, "Left Lung");
            torso.AddPart(leftLung);
            
            BodyPart rightLung = CreateLungs(hp * 0.375, "Right Lung");
            torso.AddPart(rightLung);
            
            // Legs (higher coverage for quadrupeds)
            BodyPart frontLeftLeg = CreateLeg(hp * 0.75, "Front Left Leg");
            torso.AddPart(frontLeftLeg);
            
            BodyPart frontRightLeg = CreateLeg(hp * 0.75, "Front Right Leg");
            torso.AddPart(frontRightLeg);
            
            BodyPart rearLeftLeg = CreateLeg(hp * 0.75, "Rear Left Leg");
            torso.AddPart(rearLeftLeg);
            
            BodyPart rearRightLeg = CreateLeg(hp * 0.75, "Rear Right Leg");
            torso.AddPart(rearRightLeg);
            
            // Calculate effective coverage
            body.CalculateEffectiveCoverage();
            
            return body;
        }
        
        public static BodyPart CreateGenericBody(string name, double hp)
        {
            return new BodyPart(name, hp, true, false, 100);
        }
        
        public static BodyPart CreateNeck(double hp)
        {
            BodyPart neck = new BodyPart("Neck", hp, true, false, 7.5);
            neck.SetBaseCapacity("Eating", 0.5);
            neck.SetBaseCapacity("Talking", 0.5);
            neck.SetBaseCapacity("Breathing", 0.5);
            
            // Head (80% of neck)
            BodyPart head = CreateHead(hp);
            neck.AddPart(head);
            
            return neck;
        }
        
        public static BodyPart CreateHead(double hp)
        {
            BodyPart head = new BodyPart("Head", hp, true, false, 80.0);
            
            // Skull (18% of head)
            BodyPart skull = new BodyPart("Skull", hp * 0.625, false, true, 18.0);
            head.AddPart(skull);
            
            // Brain (80% of skull)
            BodyPart brain = CreateBrain(hp * 0.25);
            skull.AddPart(brain);
            
            // Eyes (7% each, total 14% of head)
            BodyPart rightEye = CreateEye(hp * 0.25, "Right Eye");
            head.AddPart(rightEye);
            
            BodyPart leftEye = CreateEye(hp * 0.25, "Left Eye");
            head.AddPart(leftEye);
            
            // Ears (7% each, total 14% of head)
            BodyPart leftEar = CreateEar(hp * 0.3, "Left Ear");
            head.AddPart(leftEar);
            
            BodyPart rightEar = CreateEar(hp * 0.3, "Right Ear");
            head.AddPart(rightEar);
            
            // Nose (10% of head)
            BodyPart nose = new BodyPart("Nose", hp * 0.25, false, false, 10.0);
            head.AddPart(nose);
            
            // Jaw (15% of head)
            BodyPart jaw = CreateJaw(hp * 0.5);
            head.AddPart(jaw);
            
            return head;
        }
        
        public static BodyPart CreateShoulder(double hp, string name = "Shoulder")
        {
            BodyPart shoulder = new BodyPart(name, hp, false, false, 6.0);
            shoulder.SetBaseCapacity("Manipulation", 0.5);
            
            // Clavicle (9% of shoulder)
            BodyPart clavicle = CreateClavicle(hp * 0.625);
            shoulder.AddPart(clavicle);
            
            // Arm (77% of shoulder)
            BodyPart arm = CreateArm(hp * 0.75, name.Replace("Shoulder", "Arm"));
            shoulder.AddPart(arm);
            
            return shoulder;
        }
        
        public static BodyPart CreateArm(double hp, string name = "Arm")
        {
            BodyPart arm = new BodyPart(name, hp, false, false, 77.0);
            arm.SetBaseCapacity("Manipulation", 0.5);
            
            // Humerus (10% of arm)
            BodyPart humerus = CreateHumerus(hp * 0.625);
            arm.AddPart(humerus);
            
            // Radius (10% of arm)
            BodyPart radius = CreateRadius(hp * 0.5);
            arm.AddPart(radius);
            
            // Hand (14% of arm)
            BodyPart hand = CreateHand(hp * 0.5, name.Replace("Arm", "Hand"));
            arm.AddPart(hand);
            
            return arm;
        }
        
        public static BodyPart CreateHand(double hp, string name = "Hand")
        {
            BodyPart hand = new BodyPart(name, hp, false, false, 14.0);
            hand.SetBaseCapacity("Manipulation", 0.5);
            
            // Fingers (each with appropriate coverage of hand)
            BodyPart thumb = CreateFinger(hp * 0.2, name.Replace("Hand", "Thumb"));
            hand.AddPart(thumb);
            
            BodyPart indexFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Index Finger"));
            hand.AddPart(indexFinger);
            
            BodyPart middleFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Middle Finger"));
            hand.AddPart(middleFinger);
            
            BodyPart ringFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Ring Finger"));
            hand.AddPart(ringFinger);
            
            BodyPart pinky = CreateFinger(hp * 0.2, name.Replace("Hand", "Pinky"));
            hand.AddPart(pinky);
            
            return hand;
        }
        
        public static BodyPart CreateFinger(double hp, string name = "Finger")
        {
            BodyPart finger = new BodyPart(name, hp, false, false, 7.0); // Average coverage
            finger.SetBaseCapacity("Manipulation", 0.08);
            return finger;
        }
        
        public static BodyPart CreateLeg(double hp, string name = "Leg")
        {
            BodyPart leg = new BodyPart(name, hp, false, false, 7.0);
            leg.SetBaseCapacity("Moving", 0.5);
            
            // Femur (10% of leg)
            BodyPart femur = CreateFemur(hp * 0.625);
            leg.AddPart(femur);
            
            // Tibia (10% of leg)
            BodyPart tibia = CreateTibia(hp * 0.625);
            leg.AddPart(tibia);
            
            // Foot (10% of leg)
            BodyPart foot = CreateFoot(hp * 0.625, name.Replace("Leg", "Foot"));
            leg.AddPart(foot);
            
            return leg;
        }
        
        public static BodyPart CreateFoot(double hp, string name = "Foot")
        {
            BodyPart foot = new BodyPart(name, hp, false, false, 10.0);
            foot.SetBaseCapacity("Moving", 0.5);
            
            // Toes (each with appropriate coverage of foot)
            BodyPart bigToe = CreateToe(hp * 0.2, name.Replace("Foot", "Big Toe"));
            foot.AddPart(bigToe);
            
            BodyPart secondToe = CreateToe(hp * 0.2, name.Replace("Foot", "Second Toe"));
            foot.AddPart(secondToe);
            
            BodyPart middleToe = CreateToe(hp * 0.2, name.Replace("Foot", "Middle Toe"));
            foot.AddPart(middleToe);
            
            BodyPart fourthToe = CreateToe(hp * 0.2, name.Replace("Foot", "Fourth Toe"));
            foot.AddPart(fourthToe);
            
            BodyPart littleToe = CreateToe(hp * 0.2, name.Replace("Foot", "Little Toe"));
            foot.AddPart(littleToe);
            
            return foot;
        }
        
        public static BodyPart CreateToe(double hp, string name = "Toe")
        {
            BodyPart toe = new BodyPart(name, hp, false, false, 7.0); // Average coverage
            toe.SetBaseCapacity("Moving", 0.04);
            return toe;
        }
        
        public static BodyPart CreateBrain(double hp)
        {
            BodyPart brain = new BodyPart("Brain", hp, true, true, 80.0);
            brain.SetBaseCapacity("Consciousness", 1.0);
            return brain;
        }
        
        public static BodyPart CreateEye(double hp, string name = "Eye")
        {
            BodyPart eye = new BodyPart(name, hp, false, false, 7.0);
            eye.SetBaseCapacity("Sight", 0.5);
            return eye;
        }
        
        public static BodyPart CreateMouth(double hp)
        {
            BodyPart mouth = new BodyPart("Mouth", hp, false, false, 15.0);
            mouth.SetBaseCapacity("Eating", 0.5);
            mouth.SetBaseCapacity("Talking", 0.5);
            return mouth;
        }
        
        public static BodyPart CreateJaw(double hp)
        {
            BodyPart jaw = new BodyPart("Jaw", hp, false, false, 15.0);
            jaw.SetBaseCapacity("Eating", 0.5);
            jaw.SetBaseCapacity("Talking", 0.5);
            
            // Tongue (0.1% of jaw as per RimWorld)
            BodyPart tongue = CreateTongue(hp * 0.25);
            jaw.AddPart(tongue);
            
            return jaw;
        }
        
        public static BodyPart CreateTongue(double hp)
        {
            BodyPart tongue = new BodyPart("Tongue", hp, false, true, 0.1);
            tongue.SetBaseCapacity("Talking", 0.5);
            return tongue;
        }
        
        public static BodyPart CreateLungs(double hp, string name = "Lungs")
        {
            BodyPart lungs = new BodyPart(name, hp, true, true, 2.5);
            lungs.SetBaseCapacity("Breathing", 0.5);
            return lungs;
        }
        
        public static BodyPart CreateEar(double hp, string name = "Ear")
        {
            BodyPart ear = new BodyPart(name, hp, false, false, 7.0);
            ear.SetBaseCapacity("Hearing", 0.5);
            return ear;
        }
        
        public static BodyPart CreateHeart(double hp)
        {
            BodyPart heart = new BodyPart("Heart", hp, true, true, 2.0);
            heart.SetBaseCapacity("BloodPumping", 1.0);
            return heart;
        }
        
        public static BodyPart CreateStomach(double hp)
        {
            BodyPart stomach = new BodyPart("Stomach", hp, true, true, 2.5);
            stomach.SetBaseCapacity("Digestion", 0.5);
            return stomach;
        }
        
        public static BodyPart CreateLiver(double hp)
        {
            BodyPart liver = new BodyPart("Liver", hp, true, true, 2.5);
            liver.SetBaseCapacity("Digestion", 0.5);
            return liver;
        }
        
        public static BodyPart CreateKidney(double hp, string name = "Kidney")
        {
            BodyPart kidney = new BodyPart(name, hp, true, true, 1.7);
            kidney.SetBaseCapacity("BloodFiltration", 0.5);
            return kidney;
        }
        
        public static BodyPart CreateSpine(double hp)
        {
            BodyPart spine = new BodyPart("Spine", hp, false, true, 2.5);
            spine.SetBaseCapacity("Moving", 1.0);
            return spine;
        }
        
        public static BodyPart CreateRibcage(double hp)
        {
            BodyPart ribcage = new BodyPart("Ribcage", hp, false, true, 3.6);
            ribcage.SetBaseCapacity("Breathing", 0.5);
            return ribcage;
        }
        
        public static BodyPart CreateSternum(double hp)
        {
            BodyPart sternum = new BodyPart("Sternum", hp, false, true, 1.5);
            sternum.SetBaseCapacity("Breathing", 0.5);
            return sternum;
        }
        
        public static BodyPart CreatePelvis(double hp)
        {
            BodyPart pelvis = new BodyPart("Pelvis", hp, false, true, 2.5);
            pelvis.SetBaseCapacity("Moving", 1.0);
            return pelvis;
        }
        
        public static BodyPart CreateClavicle(double hp)
        {
            BodyPart clavicle = new BodyPart("Clavicle", hp, false, true, 9.0);
            clavicle.SetBaseCapacity("Manipulation", 0.5);
            return clavicle;
        }
        
        public static BodyPart CreateHumerus(double hp)
        {
            BodyPart humerus = new BodyPart("Humerus", hp, false, true, 10.0);
            humerus.SetBaseCapacity("Manipulation", 0.5);
            return humerus;
        }
        
        public static BodyPart CreateRadius(double hp)
        {
            BodyPart radius = new BodyPart("Radius", hp, false, true, 10.0);
            radius.SetBaseCapacity("Manipulation", 0.5);
            return radius;
        }
        
        public static BodyPart CreateFemur(double hp)
        {
            BodyPart femur = new BodyPart("Femur", hp, false, true, 10.0);
            femur.SetBaseCapacity("Moving", 0.5);
            return femur;
        }
        
        public static BodyPart CreateTibia(double hp)
        {
            BodyPart tibia = new BodyPart("Tibia", hp, false, true, 10.0);
            tibia.SetBaseCapacity("Moving", 0.5);
            return tibia;
        }
    }
}================================================================================

File: ./Command.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public interface ICommand
    {
        public string Name { get; set; }
        public void Execute();
    }

    public class Command<TPlayer> : ICommand
    {
        public string Name { get; set; }
        public Action<TPlayer> Act { get; set; }
        public TPlayer? Player { get; set; }

        public Command(string name, Action<TPlayer> act)
        {
            Name = name;
            Act = act;
        }

        public void Execute()
        {
            if (Player == null)
            {
                throw new Exception("Player is null");
            }
            Act.Invoke(Player);
        }

        public override string ToString() => Name;
    }
}
================================================================================

File: ./IO/Input.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.IO
{
    public static class Input
    {
        private static ManualResetEvent manualResetEvent = new ManualResetEvent(false);
        // private static string userInput;
        // public static void OnUserInputReceived(string input)
        // {
        //     userInput = input;
        //     manualResetEvent.Set();
        // }
        public static string Read()
        {
            string? input = "";
            if (Config.io == Config.IOType.Console)
            {
                input = Console.ReadLine();
            }
            else if (Config.io == Config.IOType.Web)
            {
                // await user input from web
                //input = AwaitInput();
                throw new NotImplementedException();
            }

            return input ?? "";
        }

        // public static string AwaitInput()
        // {
        //     manualResetEvent.WaitOne();
        //     manualResetEvent.Reset();
        //     return userInput;
        // }

        public static int ReadInt()
        {
            while (true)
            {
                string? input = Read();
                if (int.TryParse(input, out int result))
                {
                    return result;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number.\n");
                }
            }
        }

        public static int ReadInt(int low, int high)
        {
            while (true)
            {
                int input = ReadInt();
                if (input >= low && input <= high)
                {
                    return input;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number between ", low, " and ", high, ".\n");
                }
            }
        }

        public static bool ReadYesNo()
        {
            while (true)
            {
                string? input = Read().Trim().ToLower();
                if (input == "y" || input == "yes")
                {
                    return true;
                }
                else if (input == "n" || input == "no")
                {
                    return false;
                }
                else
                {
                    Output.Write("Invalid input. Please enter 'y' or 'n'.\n");
                }
            }
        }

        public static T? GetSelectionFromList<T>(List<T> list, bool cancelOption = false, string cancelMessage = "Cancel")
        {
            list.ForEach(i =>
            {
                if (i != null) Output.WriteLine(list.IndexOf(i) + 1, ". ", i);
            });

            int input;
            if (cancelOption)
            {
                Output.WriteLine(0, ". ", cancelMessage);
                input = ReadInt(0, list.Count);
                if (input == 0)
                {
                    return default;
                }
            }
            else
            {
                input = ReadInt(1, list.Count);
            }

            return list[input - 1];
        }
    }
}
================================================================================

File: ./IO/Output.cs
--------------------------------------------------------------------------------
﻿using System.Text;
using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival.IO
{
    public static class Output
    {
        public static int SleepTime = 10;
        public static Queue<string> OutputQueue = new Queue<string>();

        public static ConsoleColor DetermineTextColor(object x)
        {
            return x switch
            {
                string => ConsoleColor.Gray,
                int or float or double => ConsoleColor.Green,
                Npc => ConsoleColor.Red,
                Item => ConsoleColor.Cyan,
                Container => ConsoleColor.Yellow,
                Player => ConsoleColor.Green,
                Zone => ConsoleColor.Blue,
                Location => ConsoleColor.DarkYellow,
                Enum => ConsoleColor.White,
                null => ConsoleColor.Red,
                _ => ConsoleColor.White,
            };
        }

        public static void Write(params object[] args)
        {

            if (Config.io == Config.IOType.Console)
            {
                foreach (var arg in args)
                {
                    string text = GetFormattedText(arg);
                    Console.ForegroundColor = DetermineTextColor(arg);
                    Console.Write(text);
                    Thread.Sleep(SleepTime);
                }
            }
            else if (Config.io == Config.IOType.Web)
            {
                throw new NotImplementedException();
                //EventHandler.Publish(new WriteEvent(text));
            }
            
        }

        private static string GetFormattedText(params object[] args)
        {
            string result = string.Empty;

            foreach (var arg in args)
            {
                switch (arg)
                {
                    case float f:
                        result += $"{f:F1}";
                        break;
                    case double d:
                        result += $"{d:F1}";
                        break;
                    case null:
                        result += "[NULL]";
                        break;
                    default:
                        result += arg.ToString();
                        break;
                }
            }
            return result;

        }

        public static void WriteLine(params object[] args)
        {
            Write(args);
            Write("\n");
        }


        public static void WriteWarning(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Yellow;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        public static void WriteDanger(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Red;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }
    }
}
================================================================================

File: ./Program.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;
using text_survival.Environments.Locations;
using text_survival.IO;
using text_survival.Items;

namespace text_survival
{
    public class Program
    {
        static void Main()
        {
            Output.SleepTime = 500;
            Output.WriteLine("You wake up in the forest, with no memory of how you got there.");
            Output.WriteLine("Light snow is falling, and you feel the air getting colder.");
            Output.WriteLine("You need to find shelter, food, and water to survive.");
            Output.SleepTime = 10;

            Zone startingArea = new Zone("Clearing", "A small clearing in the forest.");
            Container oldBag = new Container("Old bag", 10);
            Location log = new Location("Hollow log", startingArea);
            oldBag.Add(ItemFactory.MakeApple());
            oldBag.Add(ItemFactory.MakeClothShirt());
            oldBag.Add(ItemFactory.MakeClothPants());
            oldBag.Add(ItemFactory.MakeBoots());
            oldBag.Add(new Weapon(WeaponType.Dagger, WeaponMaterial.Iron, "Old dagger", 40));
            log.Containers.Add(oldBag);
            startingArea.PutLocation(log);
            Player player = new Player(log);
            World.Player = player;
            Actions actions = new(player);
            while (player.IsAlive)
            {
                actions.Act();
            }
        }
    }
}================================================================================

File: ./Survival/ThirstModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class ThirstModule
    {
        public bool IsParched => Amount >= Max;
        private double Rate = 4000F / (24F * 60F); // mL per minute
        private double Max = 3000.0F; // mL
        private double Amount { get; set; }
        public ThirstModule()
        {
            Amount = 0;
        }
        public void AddHydration(double mL){
            Amount -= mL;
            if (Amount < 0){
                Amount = 0;
            }
        }
        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
                Amount = Max;
        }
        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Thirst: ", percent, "%");
        }
    }
}================================================================================

File: ./Survival/TemperatureModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class TemperatureModule
    {
        public const double BaseBodyTemperature = 98.6F;
        public double BodyTemperature { get; private set; }
        public bool IsWarming { get; private set; }
        public TemperatureEnum TemperatureEffect { get; private set; }

        public bool IsDangerousTemperature { get; private set; }

        public TemperatureModule()
        {

            BodyTemperature = BaseBodyTemperature;
            TemperatureEffect = TemperatureEnum.Warm;
            IsDangerousTemperature = false;
        }
        public enum TemperatureEnum
        {
            Warm,
            Cool,
            Cold,
            Freezing,
            Hot,
            HeatExhaustion,
        }

        public void Update(double feelsLikeTemperature)
        {
            TemperatureEnum oldTemperature = TemperatureEffect;
            UpdateTemperatureTick(feelsLikeTemperature);
            if (oldTemperature != TemperatureEffect)
            {
                WriteTemperatureEffectMessage(TemperatureEffect);
            }
        }
        private void UpdateTemperatureEffect()
        {
            if (BodyTemperature >= 97.7 && BodyTemperature <= 99.5)
            {
                // Normal body temperature, no effects
                TemperatureEffect = TemperatureEnum.Warm;
            }
            else if (BodyTemperature >= 95.0 && BodyTemperature < 97.7)
            {
                // Mild hypothermia effects
                TemperatureEffect = TemperatureEnum.Cool;
            }
            else if (BodyTemperature >= 89.6 && BodyTemperature < 95.0)
            {
                // Moderate hypothermia effects
                TemperatureEffect = TemperatureEnum.Cold;
            }
            else if (BodyTemperature < 89.6)
            {
                // Severe hypothermia effects
                TemperatureEffect = TemperatureEnum.Freezing;
            }
            else if (BodyTemperature > 99.5 && BodyTemperature <= 104.0)
            {
                // Heat exhaustion effects
                TemperatureEffect = TemperatureEnum.Hot;
            }
            else if (BodyTemperature > 104.0)
            {
                // Heat stroke effects
                TemperatureEffect = TemperatureEnum.HeatExhaustion;
            }
        }

        public static void WriteTemperatureEffectMessage(TemperatureEnum tempEnum)
        {
            switch (tempEnum)
            {
                case TemperatureEnum.Warm:
                    Output.WriteLine("You feel normal.");
                    break;
                case TemperatureEnum.Cool:
                    Output.WriteWarning("You feel cool.");
                    break;
                case TemperatureEnum.Cold:
                    Output.WriteWarning("You feel cold.");
                    break;
                case TemperatureEnum.Freezing:
                    Output.WriteDanger("You are freezing cold.");
                    break;
                case TemperatureEnum.Hot:
                    Output.WriteWarning("You feel hot.");
                    break;
                case TemperatureEnum.HeatExhaustion:
                    Output.WriteDanger("You are burning up.");
                    break;
                default:
                    Output.WriteDanger("Error: Temperature effect not found.");
                    break;
            }
        }
        private void UpdateTemperatureTick(double feelsLikeTemperature)
        {
            BodyTemperature += .1;

            double skinTemp = BodyTemperature - 8.4;
            float rate = 1F / 120F;

            double tempChange = (feelsLikeTemperature - skinTemp) * rate;
            BodyTemperature += tempChange;

            IsWarming = tempChange > 0;

            UpdateTemperatureEffect();

            if (BodyTemperature < 89.6)
            {
                IsDangerousTemperature = true;
            }
            else if (BodyTemperature >= 104.0)
            {
                IsDangerousTemperature = true;
            }
            else
            {
                IsDangerousTemperature = false;
            }
        }

        public void Describe()
        {
            string tempChange = IsWarming ? "Warming up" : "Getting colder";
            Output.WriteLine("Body Temperature: ", BodyTemperature, "°F (", TemperatureEffect, ")");
        }
    }
}
================================================================================

File: ./Survival/HungerModule.cs
--------------------------------------------------------------------------------
﻿
using text_survival.IO;

namespace text_survival.Survival
{
    public class HungerModule
    {
        public bool IsStarving => Amount >= Max;
        private double Rate = 2500.0 / (24.0 * 60.0); // calories per minute
        private double Max = 3500; // calories
        private double Amount { get; set; }


        public HungerModule()
        {
            Amount = 0;
        }

        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
                Amount = Max;
        }

        public void AddCalories(double calories)
        {
            Amount -= calories;
            if (Amount < 0)
            {
                Amount = 0;
            }
        }

        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Hunger: ", percent, "%");
        }
    }
}


================================================================================

File: ./Survival/ExhaustionModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class ExhaustionModule
    {
        public bool IsExhausted => Amount >= Max;
        public bool IsFullyRested => Amount <= 0;
        public double ExhaustionPercent => (Amount / Max) * 100;
        private float Rate = 480F / (24F * 60F); // minutes per minute (8 hours per 24)
        private float Max = 480.0F; // minutes (8 hours)
        public float Amount { get; private set; }

        public ExhaustionModule()
        {
            Amount = 0;
        }

        public void Rest(int minutes)
        {
            Amount -= minutes * Rate;
            if (Amount < 0)
            {
                Amount = 0;
            }
        }

        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
            {
                Amount = Max;
            }
        }

        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Exhaustion: ", percent, "%");
        }
    }
}================================================================================

File: ./Utils.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Utils
    {
        private static readonly Random random = new Random(DateTime.Now.Millisecond);

        static Utils()
        {
            random = new Random(DateTime.Now.Millisecond);
        }

        public static int Roll(int sides)
        {
            return random.Next(1, sides + 1);
        }

        public static bool DetermineSuccess(double chance)
        {
            return (random.NextDouble() < chance);
        }

        public static int RandInt(int low, int high)
        {
            return random.Next(low, high + 1);
        }

        public static float RandFloat(float low, float high)
        {
            return (float)random.NextDouble() * (high - low) + low;
        }

        public static double RandDouble(double low, double high)
        {
            return random.NextDouble() * (high - low) + low;
        }

        public static bool FlipCoin()
        {
            return random.Next(2) == 0;
        }

        public static T? GetRandomEnum<T>() where T : Enum
        {
            Array values = Enum.GetValues(typeof(T));
            return (T?)values.GetValue(Roll(values.Length) - 1);
        }

        public static T GetRandomFromList<T>(List<T> list)
        {
            if (list.Count == 0)
            {
                throw new Exception("List is empty.");
            }
            return list[Roll(list.Count) - 1];
        }
        
    public static T GetRandomWeighted<T>(IDictionary<T, double> choices)
    {
        if (choices == null || choices.Count == 0)
            throw new ArgumentException("Cannot select from an empty collection", nameof(choices));
            
        double totalWeight = choices.Sum(pair => pair.Value);
        if (totalWeight <= 0)
            throw new ArgumentException("Total weight must be positive", nameof(choices));
            
        double roll = random.NextDouble() * totalWeight;
        
        double cumulativeWeight = 0;
        foreach (var pair in choices)
        {
            cumulativeWeight += pair.Value;
            if (roll <= cumulativeWeight)
                return pair.Key;
        }
        
        // This should never happen if weights are positive
        return choices.Keys.Last();
    }
    }
}
================================================================================

File: ./Interfaces/IForageable.cs
--------------------------------------------------------------------------------
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using text_survival.Environments;

namespace text_survival.Interfaces
{
    internal interface IForageable
    {
        ForageModule ForageModule { get; }
    }
}
================================================================================

File: ./Interfaces/IInteractable.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Interfaces
{
    public interface IInteractable
    {
        string Name { get; }
        public void Interact(Player player);
        public Command<Player> InteractCommand { get; }
        public bool IsFound { get; set; }
    }
}
================================================================================

File: ./World.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;

namespace text_survival
{
    public static class World
    {
        public static TimeOnly Time { get; set; } = new TimeOnly(hour: 9, minute: 0);

        public static Player Player { get; set; }
        public static Zone CurrentArea => Player.CurrentZone;

        public static void Update(int minutes)
        {
            for (int i = 0; i < minutes; i++)
            {
                Player.Update();
                CurrentArea.Update();
                Time = Time.AddMinutes(1);
            }
        }

        public enum TimeOfDay
        {
            Night,
            Dawn,
            Morning,
            Afternoon,
            Noon,
            Evening,
            Dusk
        }

        public static TimeOfDay GetTimeOfDay()
        {
            return Time.Hour switch
            {
                < 5 => TimeOfDay.Night,
                < 6 => TimeOfDay.Dawn,
                < 11 => TimeOfDay.Morning,
                < 13 => TimeOfDay.Noon,
                < 17 => TimeOfDay.Afternoon,
                < 20 => TimeOfDay.Evening,
                < 21 => TimeOfDay.Dusk,
                _ => TimeOfDay.Night
            };
        }

    }
}
================================================================================

File: ./Magic/SpellFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;

namespace text_survival.Magic
{
    public static class SpellFactory
    {
        public static Spell MinorHeal => new Spell(
            "Minor Heal",
            10,
            new HealEffect(new Bodies.HealingInfo() { Amount = 10, Quality = 1, Type = "magic" }),
            Spell.SpellFamily.Restoration);

        public static Spell Bleeding => new Spell(
            "Bleeding",
            10,
            new BleedEffect(10, 90),
            Spell.SpellFamily.Destruction);
        public static Spell Poison => new Spell(
                "Poison",
                10,
                new PoisonEffect(5, 180),
                Spell.SpellFamily.Destruction
                );
    }
}
================================================================================

File: ./Magic/Spell.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Effects;

namespace text_survival.Magic
{
    public class Spell
    {
        public enum SpellFamily
        {
            Destruction,
            Restoration,
        }
        public string Name { get; private set; }
        //public string Description { get; set; }
        public double PsychCost { get; private set; }
        private Effect Effect { get; }
        public SpellFamily Family { get; }

        public Spell(string name, double psychCost, Effect effect, SpellFamily family)
        {
            Name = name;
            PsychCost = psychCost;
            Effect = effect;
            Family = family;
        }

        public void Cast(Actor target)
        {
            target.ApplyEffect(Effect);
        }


    }
}
================================================================================

File: ./Combat.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.IO;

namespace text_survival
{
    public static class Combat
    {
        public static void CombatLoop(Player player, Actor enemy)
        {
            Output.WriteLine("You encounter: ", enemy, "!");
            player.IsEngaged = true;
            enemy.IsEngaged = true;
            if (enemy.Body.CalculateSpeed() > player.Body.CalculateSpeed())
            {
                enemy.Attack(player);
            }
            while (player.IsAlive && enemy.IsAlive)
            {
                if (!player.IsEngaged || !player.IsAlive) break;
                PlayerTurn(player, enemy);

                if (!enemy.IsEngaged || !enemy.IsAlive) break;
                enemy.Attack(player);

                World.Update(1);
            }
            player.IsEngaged = false;
            enemy.IsEngaged = false;

            if (!player.IsAlive)
                Output.WriteDanger("You died!");
            else if (!enemy.IsAlive)
            {
                Output.WriteLine("You killed ", enemy, "!");
            }
        }



        public static void PlayerTurn(Player player, Actor enemy)
        {
            Output.WriteLine("What do you want to do?");

            List<string> options = ["Attack", "Cast Spell", "Flee"];

            string? choice = Input.GetSelectionFromList(options);

            switch (choice)
            {
                case "Attack":
                    player.Attack(enemy);
                    break;
                case "Cast Spell":
                    player.SelectSpell();
                    break;
                case "Flee":
                    if (SpeedCheck(player, enemy))
                    {
                        Output.WriteLine("You got away!");
                        enemy.IsEngaged = false;
                        player.IsEngaged = false;
                    }
                    else
                    {
                        Output.WriteLine("You weren't fast enough to get away from ", enemy, "!");
                        player._skillRegistry.AddExperience("Athletics", 1); // XP for flee attempt
                    }
                    break;
                default:
                    throw new InvalidOperationException("Invalid Selection");
            }
        }

        public static bool SpeedCheck(Player player, Actor? enemy = null)
        {
            if (player.CurrentLocation.IsSafe) return true;

            enemy ??= GetFastestNpc(player.CurrentLocation);

            double playerCheck = CalcSpeedCheck(player);
            double enemyCheck = CalcSpeedCheck(enemy);

            return playerCheck >= enemyCheck;
        }

        public static Npc GetFastestNpc(Location location)
        {
            double enemyCheck = 0;
            Npc fastestNpc = location.Npcs.First();
            foreach (Npc npc in location.Npcs)
            {
                if (npc == fastestNpc) continue;
                if (!npc.IsAlive) continue;
                var currentNpcCheck = CalcSpeedCheck(npc);
                if (currentNpcCheck < enemyCheck) continue;
                fastestNpc = npc;
                enemyCheck = currentNpcCheck;
            }
            return fastestNpc;
        }

        public static double CalcSpeedCheck(Actor actor)
        {
            double athleticsBonus = actor._skillRegistry.GetLevel("Agility");
            return actor.Body.CalculateSpeed() + athleticsBonus;
        }
    }
}================================================================================

File: ./Config.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival
{
    public static class Config
    {
        public enum IOType
        {
            Console,
            Web
        }
        public static IOType io = IOType.Console;
    }
}
================================================================================

File: ./Environments/Location.cs
--------------------------------------------------------------------------------
﻿using System.Reflection.Metadata.Ecma335;
using text_survival.Actors;
using text_survival.Environments.Locations;
using text_survival.Interfaces;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.Environments;

public class Location : Place
{
    public LocationType Type { get; set; }
    public enum LocationType
    {
        None,
        Cave,
        Trail,
        River,
        FrozenLake,
    }
    public double TemperatureModifier { get; protected set; }
    public const bool IsShelter = false;
    public bool IsFound { get; set; } = false;
    public virtual bool IsSafe => !Npcs.Any(npc => npc.IsHostile);
    public List<Npc> Npcs = [];
    public List<Item> Items = [];
    public List<Container> Containers = [];
    virtual public Location? Parent { get; set; }
    public List<IInteractable> Things
    {
        get 
        {
            var things = new List<IInteractable>();
            things.AddRange(Npcs.OfType<IInteractable>());
            things.AddRange(Locations.OfType<IInteractable>());
            things.AddRange(Containers.OfType<IInteractable>());
            things.AddRange(Items.OfType<IInteractable>());
            return things;
        }
    }
    public Zone ParentZone { get; }
    protected virtual ForageModule ForageModule { get; set; } = new();
    protected LootTable LootTable;


    #region Initialization
    public Location(string name, Place parent, int numItems = 0, int numNpcs = 0) : this(parent, numItems, numNpcs)
    {
        Name = name;
        InitializeLoot(numItems);
        InitializeNpcs(numNpcs);
    }
    public Location(Place parent, int numItems = 0, int numNpcs = 0)
    {
        if (parent is Zone z)
        {
            ParentZone = z;
            Parent = null;
        }
        else if (parent is Location l)
        {
            Parent = l;
            ParentZone = l.ParentZone;
        }
        else throw new NotImplementedException("Unknown parent type");

        Name = "Location Placeholder Name";
        LootTable = new();
        NpcSpawner = new();
        InitializeLoot(numItems);
        InitializeNpcs(numNpcs);
    }

    public static readonly List<string> genericLocationAdjectives = ["", "Old", "Dusty", "Cool", "Breezy", "Quiet", "Ancient", "Ominous", "Sullen", "Forlorn", "Desolate", "Secret", "Hidden", "Forgotten", "Cold", "Dark", "Damp", "Wet", "Dry", "Warm", "Icy", "Snowy", "Frozen"];

    protected void InitializeLoot(int numItems)
    {
        if (!LootTable.IsEmpty())
        {
            for (int i = 0; i < numItems; i++)
            {
                Items.Add(LootTable.GenerateRandomItem());
            }
        }
    }
    protected void InitializeNpcs(int numNpcs)
    {
        for (int i = 0; i < numNpcs; i++)
        {
            var npc = NpcSpawner.GenerateRandomNpc();
            if (npc is not null)
                Npcs.Add(npc);
        }
    }
    protected virtual NpcSpawner NpcSpawner { get; }


    #endregion Initialization
    public void Interact(Player player)
    {
        Output.WriteLine("You consider heading to the " + Name + "...");
        Output.WriteLine("It is a " + Type + ".");
        Output.WriteLine("Do you want to go there? (y/n)");
        if (Input.ReadYesNo())
        {
            player.CurrentLocation = this;
        }
        else
        {
            Output.WriteLine("You decide to stay.");
        }
    }
    public Command<Player> InteractCommand => new("Go to " + Name + (Visited ? " (Visited)" : ""), Interact);


    public override double GetTemperature() => GetTemperature(IsShelter);

    protected double GetTemperature(bool indoors = false)
    {
        if (!indoors) // only check if no child so far is indoors otherwise it propagates all the way up
        {
            indoors = IsShelter;
        }
        double temperature;
        if (Parent is null) // base case - the parent is the area root node
        {
            double modifier = ParentZone.GetTemperatureModifer();
            modifier = indoors ? modifier / 2 : modifier;
            temperature = ParentZone.BaseTemperature + modifier;
        }
        else  // recursive case - the parent is another location
        {
            temperature = Parent.GetTemperature(indoors);
        }
        return temperature + TemperatureModifier;
    }


    public static void GenerateSubLocation(Place parent, LocationType type, int numItems = 0, int numNpcs = 0)
    {
        Location location = type switch
        {
            LocationType.Cave => new Cave(parent, numItems, numNpcs),
            LocationType.Trail => new Trail(parent, numItems, numNpcs),
            LocationType.River => new River(parent, numItems, numNpcs),
            LocationType.FrozenLake => new FrozenLake(parent, numItems, numNpcs),
            _ => throw new Exception("Invalid LocationType")
        };
        parent.PutLocation(location);
    }

    public override void Update()
    {
        Locations.ForEach(i => i.Update());
        Npcs.ForEach(n => n.Update());
    }


    public void Forage(int hours)
    {
        ForageModule.Forage(hours);
        var itemsFound = ForageModule.GetItemsFound();
        if (itemsFound.Any())
        {
            foreach (var item in itemsFound)
            {
                Items.Add(item);
                item.IsFound = true;
            }
        }
    }

    public override string ToString() => Name;
}================================================================================

File: ./Environments/Zone.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Interfaces;
using text_survival.Items;
using static text_survival.Environments.Location;

namespace text_survival.Environments
{
    public class Zone : Place
    {
        public string Description { get; set; }
        public double BaseTemperature { get; protected set; }
        public virtual List<Item> ItemList { get; } = [];
        public virtual List<Npc> NpcList { get; } = [];

        public enum EnvironmentType
        {
            Forest,
        }
        public Zone(string name, string description, double baseTemp = 70, int subLocations = 1)
        {
            Name = name;
            Description = description;
            BaseTemperature = baseTemp;
            for (int i = 0; i < subLocations; i++)
            {
                GenerateRandomSubLocation(1, 1);
            }
        }

        public double GetTemperatureModifer()
        {
            double modifier = 0;
            if (World.GetTimeOfDay() == World.TimeOfDay.Morning)
            {
                modifier -= 5;
            }
            else if (World.GetTimeOfDay() == World.TimeOfDay.Afternoon)
            {
                modifier += 10;
            }
            else if (World.GetTimeOfDay() == World.TimeOfDay.Evening)
            {
                modifier += 5;
            }
            else if (World.GetTimeOfDay() == World.TimeOfDay.Night)
            {
                modifier -= 10;
            }
            modifier += Utils.RandInt(-3, 3);
            return modifier;
        }
        public override double GetTemperature()
        {
            double effect = GetTemperatureModifer();
            return effect + BaseTemperature;
        }

        public void GenerateRandomSubLocation(int maxItems = 0, int maxNpcs = 0)
        {

            LocationType type = LocationType.None;
            while (type == LocationType.None)
            {
                type = Utils.GetRandomEnum<LocationType>();
            }
            int items = Utils.RandInt(0, maxItems);
            int npcs = Utils.RandInt(0, maxNpcs);
            Location.GenerateSubLocation(this, type, items, npcs);
        }

        public override void Update()
        {
            
        }

        protected static readonly List<string> genericAdjectives = ["", "Open", "Dark", "Ominous", "Shady", "Lonely", "Ancient",];
        public override string ToString() => Name;

    }
}
================================================================================

File: ./Environments/Locations/Trail.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments.Locations
{
    internal class Trail : Location
    {
        new public const bool IsShelter = false;
        public Trail(Place parent, int numItems = 0, int numNpcs = 0) : base(parent, numItems, numNpcs)
        {
            Type = LocationType.Trail;
            TemperatureModifier = 0;

            var descriptors = new List<string>();
            descriptors.AddRange(trailAdjectives);
            descriptors.AddRange(genericLocationAdjectives);
            Name = Utils.GetRandomFromList(descriptors) + " " + Utils.GetRandomFromList(trailNames);
            Name = Name.Trim();
        }

        protected new LootTable LootTable = new([ItemFactory.MakeRock, ItemFactory.MakeStick, ItemFactory.MakeBandage]);
        protected new NpcSpawner NpcSpawner = new([NpcFactory.MakeSnake]);

        private static readonly List<string> trailNames = ["Path", "Trail", "Pass"];
        private static readonly List<string> trailAdjectives = ["Dirt", "Gravel", "Stone", "Animal", "Hunter's", "Winding", "Straight", "Curved", "Twisting", "Bumpy", "Smooth", "Narrow", "Wide", "Long", "Short", "Steep", "Flat", "Sloping", "Rough", "Smooth", "Muddy",];

    }
}
================================================================================

File: ./Environments/Locations/LocationTemplate.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments.Locations
{
    internal class LocationTemplate : Location
    {
        new public const bool IsShelter = false;
        public LocationTemplate(Place parent, int numItems = 0, int numNpcs = 0) : base(parent, numItems, numNpcs)
        {
            Type = LocationType.Cave;
            TemperatureModifier = 0;

            var descriptors = new List<string>();
            descriptors.AddRange(LocationTemplateAdjectives);
            descriptors.AddRange(genericLocationAdjectives);
            Name = Utils.GetRandomFromList(descriptors) + " " + Utils.GetRandomFromList(LocationTemplateNames);
            Name = Name.Trim();
        }

        protected new LootTable LootTable = new();
        protected new NpcSpawner NpcSpawner = new();

        private static readonly List<string> LocationTemplateNames = ["LocationTemplate"];
        private static readonly List<string> LocationTemplateAdjectives = [""];
    }
}
================================================================================

File: ./Environments/Locations/FrozenLake.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments.Locations
{
    internal class FrozenLake : Location
    {
        new public const bool IsShelter = false;
        public FrozenLake(Place parent, int numItems = 0, int numNpcs = 0) : base(parent, numItems, numNpcs)
        {
            Type = LocationType.FrozenLake;
            TemperatureModifier = -3;

            var descriptors = new List<string>();
            descriptors.AddRange(frozenLakeAdjectives);
            descriptors.AddRange(genericLocationAdjectives);
            Name = Utils.GetRandomFromList(descriptors) + " " + Utils.GetRandomFromList(frozenLakeNames);
            Name = Name.Trim();
        }

        protected new LootTable LootTable = new();

        private static readonly List<string> frozenLakeNames = ["Lake", "Pond", "Water"];
        private static readonly List<string> frozenLakeAdjectives = ["", "Shallow", "Deep", "Still", "Quiet", "Calm", "Rippling", "Misty", "Foggy", "Murky", "Dark", "Shimmering"];
    }
}
================================================================================

File: ./Environments/Locations/River.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments.Locations
{
    internal class River : Location
    {
        new public const bool IsShelter = false;
        public River(Place parent, int numItems = 0, int numNpcs = 0) : base(parent, numItems, numNpcs)
        {
            Type = LocationType.River;
            TemperatureModifier = 0;

            var descriptors = new List<string>();
            descriptors.AddRange(riverAdjectives);
            descriptors.AddRange(genericLocationAdjectives);
            Name = Utils.GetRandomFromList(descriptors) + " " + Utils.GetRandomFromList(riverNames);
            Name = Name.Trim();
        }


        protected new LootTable LootTable = new([ItemFactory.MakeWater, ItemFactory.MakeFish]);

        private static readonly List<string> riverNames =
        [
            "River", "Stream", "Creek", "Waterfall", "Brook",
             "Rapids",
        ];

        private static readonly List<string> riverAdjectives = ["", "Shallow", "Deep", "Still", "Quiet", "Calm", "Rippling", "Misty", "Foggy", "Murky", "Dark", "Shimmering", "Quick", "Loud", "Slow", "Lazy"];
    }
}
================================================================================

File: ./Environments/Locations/Cave.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments.Locations
{
    public class Cave : Location
    {
        new public const bool IsShelter = true;

        public Cave(Place parent, int numItems = 0, int numNpcs = 0) : base(parent, numItems, numNpcs)
        {
            // set type and temperature
            Type = LocationType.Cave;
            TemperatureModifier = -5;

            // create name
            var descriptors = new List<string>();
            descriptors.AddRange(caveAdjectives);
            descriptors.AddRange(genericLocationAdjectives);
            Name = Utils.GetRandomFromList(descriptors) + " " + Utils.GetRandomFromList(caveNames);
            Name = Name.Trim();

            // add forageable resources
            ForageModule.AddResource(ItemFactory.MakeMushroom, 0.5);
            ForageModule.AddResource(ItemFactory.MakeRock, 0.5);
        }

        protected new LootTable LootTable = new([ItemFactory.MakeMushroom, ItemFactory.MakeRock, ItemFactory.MakeGemstone, ItemFactory.MakeTorch, Weapon.GenerateRandomWeapon]);
        protected new NpcSpawner NpcSpawner = new NpcSpawner([NpcFactory.MakeSpider, NpcFactory.MakeRat, NpcFactory.MakeSnake, NpcFactory.MakeBat, NpcFactory.MakeCaveBear]);

        private static readonly List<string> caveNames = ["Cave", "Cavern", "Ravine"];
        private static readonly List<string> caveAdjectives = ["", "Abandoned", "Collapsed", "Shallow", "Deep", "Echoing", "Painted", "Sparkling", "Dim", "Icy"];


    }
}
================================================================================

File: ./Environments/IPlace.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Environments;

public abstract class Place
{
    public string Name { get; set; } = "";
    public bool Visited { get; set; }
    public virtual List<Location> Locations { get; } = [];

    public abstract double GetTemperature();
    public virtual void Update() { Locations.ForEach(x => x.Update()); }
    public void PutLocation(Location location) => Locations.Add(location);
}
================================================================================

File: ./Environments/ForageModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.Items;

namespace text_survival.Environments
{
    public class ForageModule(double resourceDensity = 1)
    {
        private double baseResourceDensity = resourceDensity;
        private int numberOfHoursForaged = 0;
        private List<Func<Item>> resources => [.. resourceRarities.Keys];
        private Dictionary<Func<Item>, double> resourceRarities = [];
        private double ResourceDensity => baseResourceDensity / (numberOfHoursForaged + 1);
        private List<Item> itemsFound = [];

        public void Forage(int hours)
        {
            foreach (Func<Item> factory in resources)
            {
                double chance = ResourceDensity * resourceRarities[factory];
               
                for (int i = 0; i < hours; i++)
                {
                    if (Utils.DetermineSuccess(chance))
                    {
                        itemsFound.Add(factory());
                        numberOfHoursForaged++;
                    }
                }
            }
            World.Update(hours * 60);
        }
        public List<Item> GetItemsFound()
        {
            var items = itemsFound;
            itemsFound = [];
            return items;
        }

        public void AddResource(Func<Item> factory, double rarity)
        {
            // todo switch to factory methods instead of the items themselves like the location loot tables
            resourceRarities.Add(factory, rarity);
        }
    }
}
================================================================================

File: ./Environments/WorldMap.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments.Zones;
using static text_survival.Environments.Zone;

namespace text_survival.Environments
{
    public class WorldMap
    {
        private Dictionary<(int, int), Zone> map = new();

        private int X;
        private int Y;

        public WorldMap(Zone startingZone)
        {
            X = 0;
            Y = 0;
            map.Add((X, Y), startingZone);
            startingZone.Visited = true;
        }

        public Zone CurrentZone => GetZone(X, Y);
        public Zone North => GetZone(X, Y + 1);
        public Zone South => GetZone(X, Y - 1);
        public Zone East => GetZone(X + 1, Y);
        public Zone West => GetZone(X - 1, Y);


        public void MoveNorth() => MoveTo(X, Y + 1);
        public void MoveSouth() => MoveTo(X, Y - 1);
        public void MoveEast() => MoveTo(X + 1, Y);
        public void MoveWest() => MoveTo(X - 1, Y);


        private void MoveTo(int x, int y)
        {
            Zone zone = GetZone(x, y) ?? throw new Exception("Invalid zone.");
            X = x;
            Y = y;
            zone.Visited = true;
        }

        private Zone GetZone(int x, int y)
        {
            Zone? zone = map.GetValueOrDefault((x, y));
            if (zone == null)
            {
                zone = GenerateRandomZone();
                map.Add((x, y), zone);
            }
            return zone;
        }

        private Zone GenerateRandomZone()
        {
            EnvironmentType type = Utils.GetRandomEnum<EnvironmentType>();
            Zone zone = (type) switch
            {
                EnvironmentType.Forest => new Forest(),
                _ => throw new Exception("Invalid zone type.")
            };
            return zone;
        }

    }
}
================================================================================

File: ./Environments/Zones/Forest.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments.Zones
{
    internal class Forest : Zone
    {
        public Forest() : base("Forest", "")
        {
            BaseTemperature = 65;

            var descriptors = new List<string>();
            descriptors.AddRange(ForestAdjectives);
            descriptors.AddRange(genericAdjectives);
            Name = Utils.GetRandomFromList(descriptors) + " " + Utils.GetRandomFromList(ForestNames);
            Name = Name.Trim();
        }

        public override List<Item> ItemList => [ItemFactory.MakeBerry(), ItemFactory.MakeWater(), ItemFactory.MakeMushroom(), ItemFactory.MakeStick(), ItemFactory.MakeWood()]; // Add EdibleRoot
        public override List<Npc> NpcList => [NpcFactory.MakeWolf(), NpcFactory.MakeBear()];

        private static readonly List<string> ForestNames = ["Forest", "Clearing", "Grove", "Woods", "Hollow"];
        private static readonly List<string> ForestAdjectives = ["Old Growth", "Overgrown"];
    }
}
================================================================================

