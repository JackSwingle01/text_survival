File: ./Describe.cs
--------------------------------------------------------------------------------
﻿
using text_survival.IO;
using text_survival.Items;
using text_survival.PlayerComponents;

namespace text_survival
{
    public static class Describe
    {
        public static void DescribeGear(InventoryManager inv)
        {
            if (inv.IsArmed)
            {
                Output.Write("Weapon => ");
                DescribeItem(inv.Weapon);
            }
            foreach (Armor armor in inv.Armor)
            {
                Output.Write(armor.EquipSpot, " => ");
                DescribeItem(armor);
            }
            if (inv.HeldItem is not null)
            {
                Output.Write("Held Item => ");
                DescribeItem(inv.HeldItem);
            }
        }

        public static void DescribeItem(Item item)
        {
            Output.Write(item, " => ", item.Description, " ");
            if (item is Weapon weapon)
            {
                Output.Write("Damage: ", weapon.Damage, " hp, ");
                Output.Write("Hit Chance: ", weapon.Accuracy * 100, "%, ");
                if (weapon.BlockChance != 0)
                {
                    Output.Write(", BlockChance: ", weapon.BlockChance * 100, "%, ");
                }
            }
            else if (item is Armor armor)
            {
                if (armor.Rating != 0)
                    Output.Write("Defense: ", armor.Rating * 100, "%, ");

                if (armor.Warmth != 0)
                    Output.Write("Warmth: ", armor.Warmth, "F, ");
            }

            if (item.Weight != 0)
            {
                Output.Write("Weight: ", item.Weight, "kg");
            }
            Output.WriteLine();
        }

        public static void DescribeSkills(Player player)
        {
            player._skillRegistry.Describe();

        }
    }
}
================================================================================

File: ./Actions.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival
{

    public class Actions
    {
        private readonly Player _player;
        public List<ICommand> AvailableActions { get; private set; }

        public Actions(Player player)
        {
            _player = player;
            AvailableActions = [];
        }

        private Command<Player> LookAroundCommand => new Command<Player>($"Look Around {_player.CurrentLocation}", LookAround);
        private Command<Player> CheckStatsCommand => new Command<Player>("Check Stats", CheckStats);
        private Command<Player> OpenInventoryCommand => new Command<Player>("Open Inventory", OpenInventory);
        private Command<Player> TravelCommand => new Command<Player>("Travel", Travel);
        private Command<Player> SleepCommand => new Command<Player>("Sleep", Sleep);
        private Command<Player> CheckGearCommand => new Command<Player>("Check Gear", CheckGear);
        private Command<Player> ForageCommand => new Command<Player>("Forage", Forage);
        public void UpdatePossibleActions()
        {
            // Clear the available actions
            AvailableActions.Clear();

            // always available actions
            var lookCommand = LookAroundCommand;
            lookCommand.Player = _player;
            AvailableActions.Add(lookCommand);

            var forageFeature = _player.CurrentLocation.GetFeature<ForageFeature>();
            if (forageFeature != null)
            {
                var forageCommand = ForageCommand;
                forageCommand.Player = _player;
                AvailableActions.Add(forageCommand);
            }


            // conditional actions
            foreach (Item item in _player.CurrentLocation.Items)
            {
                if (item.IsFound)
                {
                    var interactCommand = item.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Container container in _player.CurrentLocation.Containers)
            {
                if (container.IsFound)
                {
                    var interactCommand = container.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Npc npc in _player.CurrentLocation.Npcs)
            {
                if (npc.IsFound)
                {
                    var interactCommand = npc.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Location location in GetNearbyLocations(_player))
            {
                if (location.IsFound)
                {
                    var interactCommand = location.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }

            var openInventoryCommand = OpenInventoryCommand;
            openInventoryCommand.Player = _player;
            AvailableActions.Add(openInventoryCommand);

            var travelCommand = TravelCommand;
            travelCommand.Player = _player;
            AvailableActions.Add(travelCommand);


            var sleepCommand = SleepCommand;
            sleepCommand.Player = _player;
            AvailableActions.Add(sleepCommand);

            // var checkGearCommand = CheckGearCommand;
            // checkGearCommand.Player = _player;
            // AvailableActions.Add(checkGearCommand);

            var checkStats = CheckStatsCommand;
            checkStats.Player = _player;
            AvailableActions.Add(checkStats);

            // if (_player.SkillPoints > 0)
            // {
            //     var levelUpCommand = LevelUpCommand;
            //     levelUpCommand.Player = _player;
            //     AvailableActions.Add(levelUpCommand);
            // }
        }

        public void DisplayActions()
        {
            int i = 1;
            Dictionary<int, ICommand> actions = new();

            // always available actions
            var lookCommand = LookAroundCommand;
            lookCommand.Player = _player;
            actions[i++] = lookCommand;

            var forageFeature = _player.CurrentLocation.GetFeature<ForageFeature>();
            if (forageFeature != null)
            {
                var forageCommand = ForageCommand;
                forageCommand.Player = _player;
                actions[i++] = forageCommand;
            }


            // conditional actions
            foreach (Item item in _player.CurrentLocation.Items)
            {
                if (item.IsFound)
                {
                    var interactCommand = item.InteractCommand;
                    interactCommand.Player = _player;
                    actions[i++] = interactCommand;
                }
            }
            foreach (Container container in _player.CurrentLocation.Containers)
            {
                if (container.IsFound)
                {
                    var interactCommand = container.InteractCommand;
                    interactCommand.Player = _player;
                    actions[i++] = interactCommand;
                    
                }
            }
            foreach (Npc npc in _player.CurrentLocation.Npcs)
            {
                if (npc.IsFound)
                {
                    var interactCommand = npc.InteractCommand;
                    interactCommand.Player = _player;
                    actions[i++] = interactCommand;
                }
            }
            foreach (Location location in GetNearbyLocations(_player))
            {
                if (location.IsFound)
                {
                    var interactCommand = location.InteractCommand;
                    interactCommand.Player = _player;
                    actions[i++] = interactCommand;
                }
            }

            var openInventoryCommand = OpenInventoryCommand;
            openInventoryCommand.Player = _player;
            actions[i++] = openInventoryCommand;

            var travelCommand = TravelCommand;
            travelCommand.Player = _player;
            actions[i++] = travelCommand;

            var sleepCommand = SleepCommand;
            sleepCommand.Player = _player;
            actions[i++] = sleepCommand;

            // var checkGearCommand = CheckGearCommand;
            // checkGearCommand.Player = _player;
            // AvailableActions.Add(checkGearCommand);

            var checkStats = CheckStatsCommand;
            checkStats.Player = _player;
            actions[i++] = checkStats;

            Output.WriteLine();
            _player.DescribeSurvivalStats();
            Output.WriteLine();
            Output.WriteLine("What would you like to do?");
        }

        private void Forage(Player player)
        {
            var forageFeature = player.CurrentLocation.GetFeature<ForageFeature>();
            if (forageFeature == null)
            {
                Output.WriteLine("You can't forage here");
                return;
            }

            // Output.WriteLine("How many hours would you like to forage?");
            // int hours = Input.ReadInt(); 
            Output.WriteLine("You forage for 1 hour");
            forageFeature.Forage(1);
        }

        public void Act()
        {
            UpdatePossibleActions();
            Output.WriteLine();
            _player.DescribeSurvivalStats();
            Output.WriteLine();
            Output.WriteLine("What would you like to do?");
            ICommand? command = Input.GetSelectionFromList(AvailableActions);
            command?.Execute();
        }

        private void CheckStats(Player player)
        {
            // Describe.DescribeLevel(player);
            player.Body.Describe();
            Describe.DescribeSkills(player);
            Output.WriteLine("Press any key to continue...");
            Console.ReadKey(true);
        }

        private void OpenInventory(Player player)
        {
            player.OpenInventory();
        }

        private void Travel(Player player)
        {
            player.Travel();
        }
        private void Sleep(Player player)
        {
            Output.WriteLine("How many hours would you like to sleep?");
            player.Sleep(Input.ReadInt() * 60);
        }

        private void CheckGear(Player player)
        {
            // player.in();
            //todo
        }

        private void LookAround(Player player)
        {
            Output.WriteLine("You look around the ", player.CurrentLocation);
            Output.WriteLine("You are in a ", player.CurrentLocation, " in a ", player.CurrentZone);
            Output.WriteLine("Its ", World.GetTimeOfDay(), " and ", player.CurrentLocation.GetTemperature(), " degrees.");
            Output.WriteLine("You see:");
            foreach (var thing in player.CurrentLocation.Items)
            {
                Output.WriteLine(thing);
                thing.IsFound = true;
            }
            foreach (var thing in player.CurrentLocation.Containers)
            {
                Output.WriteLine(thing);
                thing.IsFound = true;
            }
            foreach (var thing in player.CurrentLocation.Npcs)
            {
                Output.WriteLine(thing);
                thing.IsFound = true;
            }


            var nearbyLocations = GetNearbyLocations(player);
            if (nearbyLocations.Count == 0)
                return;
            Output.WriteLine("Nearby, you see some other places: ");
            foreach (var location in nearbyLocations)
            {
                Output.WriteLine(location);
                location.IsFound = true;
            }
        }
        private List<Location> GetNearbyLocations(Player player)
        {
            List<Location> nearbyLocations = [];
            if (player.CurrentZone.Locations.Count > 0)
            {
                foreach (var location in player.CurrentZone.Locations)
                {
                    if (location == player.CurrentLocation)
                        continue;
                    nearbyLocations.Add(location);
                }
            }
            return nearbyLocations;
        }
    }
}
================================================================================

File: ./Physics.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Physics
    {
        public static float DeltaCelsiusToDeltaFahrenheit(float celsius)
        {
            return (celsius * (9.0F / 5.0F));
        }
        public static float TempChange(float mass, float specificHeat, float joules)
        {
            float deltaT = joules / (mass * specificHeat);
            return deltaT;
        }
        public static float CaloriesToJoules(float calories)
        {
            return calories * 4184.0F;
        }

    }
}
================================================================================

File: ./Player.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.PlayerComponents;


namespace text_survival;

public class Player : Actor
{

    private readonly LocationManager locationManager;
    private readonly SpellManager spellManager;
    private readonly InventoryManager inventoryManager;
    public double EquipmentWarmth => inventoryManager.EquipmentWarmth;
    public void Sleep(int minutes)
    {
        bool fullyRested = Body.Rest(1);
        if (fullyRested)
        {
            Output.Write("You wake up feeling refreshed.\n");
        }

    }
    public void OpenInventory() => inventoryManager.Open(this);
    public override Weapon ActiveWeapon
    {
        get => inventoryManager.Weapon; protected set
        {
            inventoryManager.Weapon = value;
        }
    }

    // Location-related methods
    public Location CurrentLocation
    {
        get => locationManager.CurrentLocation;
        set => locationManager.CurrentLocation = value;
    }

    public Zone CurrentZone => locationManager.CurrentZone;

    #region Constructor

    public Player(Location startingLocation) : base("Player", Body.BaseLineHumanStats)
    {
        Name = "Player";
        locationManager = new LocationManager(startingLocation);
        spellManager = new(_skillRegistry);
        inventoryManager = new(_effectRegistry);
    }


    #endregion Constructor

    public void DropItem(Item item)
    {
        inventoryManager.RemoveFromInventory(item);
        Output.WriteLine("You drop the ", item);
        locationManager.AddItemToLocation(item);
    }

    public void TakeItem(Item item)
    {
        locationManager.RemoveItemFromLocation(item);
        Output.WriteLine("You take the ", item);
        inventoryManager.AddToInventory(item);
    }

    public void SelectSpell()
    {
        List<Actor> targets = [this];
        CurrentLocation.Npcs.ForEach(targets.Add);
        spellManager.SelectSpell(targets);
    }



    public override BodyPart? Damage(DamageInfo damageInfo)
    {
        var part = Body.Damage(damageInfo);
        if (!IsAlive)
        {
            // end program
            Output.WriteDanger("You died!");
            Environment.Exit(0);
        }
        return part;
    }

    public void DescribeSurvivalStats()
    {
        Body.DescribeSurvivalStats();
    }

    public void UseItem(Item item)
    {
        // handle special logic for each item type
        if (item is FoodItem food)
        {
            string eating_type = food.WaterContent > food.Calories ? "drink" : "eat";
            Output.Write($"You {eating_type} the ", food, "...");
            Body.Consume(food);
        }
        else if (item is ConsumableItem consumable)
        {
            foreach (Effect e in consumable.Effects)
            {
                ApplyEffect(e);
            }
        }
        else if (item is Gear gear)
        {
            Output.WriteLine("You equip the ", gear);
            inventoryManager.Equip(gear);
            foreach (Effect effect in gear.EquipEffects)
            {
                ApplyEffect(effect);
            }
        }

        else if (item is WeaponModifierItem weaponMod)
        {
            if (ModifyWeapon(weaponMod.Damage))
            {
                Output.WriteLine("You use the ", weaponMod, " to modify your ", inventoryManager.Weapon);
            }
            else
            {
                Output.WriteLine("You don't have a weapon equipped to modify.");
                return;
            }
        }
        else if (item is ArmorModifierItem armorMod)
        {
            if (ModifyArmor(armorMod.ValidArmorTypes[0], armorMod.Rating, armorMod.Warmth))
            {
                Output.WriteLine("You use the ", armorMod, " to modify your armor.");
            }
            else
            {
                Output.WriteLine("You don't have any armor you can use that on.");
                return;
            }
        }
        else
        {
            Output.Write("You don't know what to use the ", item, " for...\n");
            return;
        }
        // shared logic for all item types
        if (item.NumUses != -1)
        {
            item.NumUses -= 1;
            if (item.NumUses == 0)
            {
                inventoryManager.RemoveFromInventory(item);
            }
        }
        World.Update(1);
    }

    public bool ModifyWeapon(double damage)
    {
        if (!inventoryManager.IsArmed) return false;

        inventoryManager.Weapon.Damage += damage;
        return true;
    }
    public bool ModifyArmor(EquipSpots spot, double rating = 0, double warmth = 0)
    {
        Armor? armor = inventoryManager.GetArmorInSpot(spot);
        if (armor is null) return false;

        armor.Rating += rating;
        armor.Warmth += warmth;
        return true;
    }

    public void Travel() => locationManager.TravelToAdjacentZone();
}




public class SurvivalStatsUpdate
{
    public double Temperature;
    public double Calories;
    public double Hydration;
    public double Exhaustion;
}================================================================================

File: ./Actors/Animal.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;
using text_survival.IO;

namespace text_survival.Actors
{
    public class Animal : Npc
    {
        // public string Description { get; set; } = "";
        // public bool IsFound { get; set; } = false;
        // public bool IsHostile { get; set; } = true;
        public override Weapon ActiveWeapon { get ; protected set; }
        private Container Loot { get; }
    
    
        public Animal(string name, Weapon weapon, BodyStats bodyStats) : base(name, weapon, bodyStats)
        {
            Name = name;
            ActiveWeapon = weapon;

            // Set up loot container
            Loot = new Container(name, 10);
        }

  
        public override string ToString() => Name;
    }
}================================================================================

File: ./Actors/IBuffable.cs
--------------------------------------------------------------------------------
﻿// using text_survival.Magic;

// namespace text_survival.Actors
// {
//     public interface IBuffable //: IActor
//     {
//         public List<Buff> Buffs { get; }

//         public void AddBuff(Buff buff)
//         {
//             if (buff.Target == null)
//                 buff.ApplyTo(this);
//             Buffs.Add(buff);
//         }
//         public void RemoveBuff(Buff buff)
//         {
//             if (buff.Target == this)
//                 buff.Remove();
//             Buffs.Remove(buff);
//         }

//     }
// }
================================================================================

File: ./Actors/ICombatant.cs
--------------------------------------------------------------------------------
﻿
// using text_survival.Items;
// using text_survival.Level;

// namespace text_survival.Actors
// {
//     public interface ICombatant
//     {
//         bool IsAlive { get; }
//         bool IsEngaged { get; set; }
//         Weapon ActiveWeapon { get; }
//         Attributes Attributes { get; }
//         SkillRegistry _skillRegistry {get;}
//         double ConditionPercent { get; }
//         void Attack(ICombatant target);
//         // double DetermineDamage();
//         // double DetermineHitChance(ICombatant defender);
//         // double DetermineDodgeChance(ICombatant attacker);
//         // double DetermineBlockChance(ICombatant attacker);

//     }
// }
================================================================================

File: ./Actors/NPCFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;

namespace text_survival.Actors
{
    public static class NpcFactory
    {
        public static Animal MakeRat()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 0.5, // 0.5 kg for a rat
                fatPercent = 0.15,   // 15% fat
                musclePercent = 0.40 // 40% muscle
            };

            // Create a natural weapon for the rat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Rodent Teeth", 100)
            {
                Damage = 2,
                Accuracy = 1.2
            };

            Animal rat = new("Rat", weapon, bodyStats)
            {
                Description = "A rat with fleas."
            };
            rat.AddLoot(ItemFactory.MakeSmallMeat());
            return rat;
        }

        public static Animal MakeWolf()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 40,   // 40 kg - average wolf
                fatPercent = 0.20,    // 20% fat
                musclePercent = 0.60  // 60% muscle - wolves are muscular
            };

            // Create a natural weapon for the wolf
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Wolf Fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.1
            };

            Animal wolf = new("Wolf", weapon, bodyStats)
            {
                Description = "A wolf."
            };
            wolf.AddLoot(ItemFactory.MakeLargeMeat());
            return wolf;
        }

        public static Animal MakeBear()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 250,  // 250 kg - large bear
                fatPercent = 0.30,    // 30% fat - bears have more fat reserves
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "Bear Claws", 100)
            {
                Damage = 20,
                Accuracy = 0.9
            };

            Animal bear = new("Bear", weapon, bodyStats)
            {
                Description = "A bear."
            };
            bear.AddLoot(ItemFactory.MakeLargeMeat());
            return bear;
        }

        public static Animal MakeSnake()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Serpentine,
                overallWeight = 5,    // 5 kg - medium sized snake
                fatPercent = 0.10,    // 10% fat
                musclePercent = 0.80  // 80% muscle - snakes are almost all muscle
            };

            // Create a natural weapon for the snake
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.0
            };

            Animal snake = new("Snake", weapon, bodyStats)
            {
                Description = "A venomous snake."
            };

            LootTable loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSmallMeat, 2);
            loot.AddItem(ItemFactory.MakeVenomSac);
            snake.AddLoot(loot.GenerateRandomItem());

            // TODO: Apply venom effect
            // snake.ApplyEffect(new PoisonEffect("venom", "natural", 0.8, 2, 180));

            return snake;
        }

        public static Animal MakeBat()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Flying,
                overallWeight = 0.2,   // 200g - small bat
                fatPercent = 0.20,     // 20% fat 
                musclePercent = 0.65   // 65% muscle - flying requires strong muscles
            };

            // Create a natural weapon for the bat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Tiny Teeth", 100)
            {
                Damage = 2,
                Accuracy = 0.9
            };

            Animal bat = new("Bat", weapon, bodyStats)
            {
                Description = "A small bat with leathery wings."
            };

            return bat;
        }

        public static Animal MakeSpider()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Arachnid,
                overallWeight = 0.1,   // 100g - large spider
                fatPercent = 0.05,     // 5% fat
                musclePercent = 0.45   // 45% muscle
            };

            // Create a natural weapon for the spider
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Mandibles", 100)
            {
                Damage = 5,
                Accuracy = 1.2
            };

            Animal spider = new("Spider", weapon, bodyStats)
            {
                Description = "A venomous spider with long hairy legs."
            };

            // TODO: Apply venom effect
            // spider.ApplyEffect(new PoisonEffect("venom", "natural", 0.6, 1, 120));

            var loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSpiderSilk);
            loot.AddItem(ItemFactory.MakeVenomSac);
            spider.AddLoot(loot.GenerateRandomItem());

            return spider;
        }

        public static Animal MakeCaveBear()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 350,  // 350 kg - larger than a regular bear
                fatPercent = 0.35,    // 35% fat - more for cave survival
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the cave bear - stronger than regular bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "Massive Cave Bear Claws", 100)
            {
                Damage = 25,
                Accuracy = 0.85
            };

            Animal caveBear = new("Cave Bear", weapon, bodyStats)
            {
                Description = "An enormous cave bear with massive claws. It's adapted to cave dwelling and hunting in darkness."
            };

            // Add more meat due to larger size
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());

            return caveBear;
        }

        public static Animal MakeWoollyMammoth()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 6000,  // 6 tons - enormous
                fatPercent = 0.35,     // 35% fat for cold protection
                musclePercent = 0.50   // 50% muscle
            };

            // Create a natural weapon for the mammoth
            var weapon = new Weapon(WeaponType.Horns, WeaponMaterial.Organic, "Mammoth Tusks", 100)
            {
                Damage = 35,
                Accuracy = 0.7
            };

            Animal mammoth = new("Woolly Mammoth", weapon, bodyStats)
            {
                Description = "A massive woolly mammoth with long curved tusks and a thick fur coat."
            };

            // Add large amount of meat and other rare resources
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());

            return mammoth;
        }

        public static Animal MakeSaberToothTiger()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 300,   // 300 kg - large cat
                fatPercent = 0.15,     // 15% fat
                musclePercent = 0.70   // 70% muscle - extremely powerful
            };

            // Create a natural weapon for the saber-tooth
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Massive Fangs", 100)
            {
                Damage = 30,
                Accuracy = 1.0
            };

            Animal saberTooth = new("Saber-Tooth Tiger", weapon, bodyStats)
            {
                Description = "A fearsome predator with long saber-like canine teeth."
            };

            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());
            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());

            return saberTooth;
        }

        // Human NPCs with various weapons
        public static Npc MakeTribalHunter()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 65,
                fatPercent = 0.15,
                musclePercent = 0.60
            };

            // Create a hunting spear
            var weapon = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Hunter's Wooden Spear", 75)
            {
                Damage = 8,
                Accuracy = 1.2
            };

            // Create hunter with spear
            Npc hunter = new("Tribal Hunter", weapon, bodyStats)
            {
                Description = "A lean, muscular hunter from a nearby tribe."
            };

            // Add some basic equipment to loot
            hunter.AddLoot(ItemFactory.MakeSmallMeat());

            return hunter;
        }

        public static Npc MakeTribalWarrior()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 70,
                fatPercent = 0.15,
                musclePercent = 0.65
            };

            // Create a war club
            var weapon = new Weapon(WeaponType.Club, WeaponMaterial.Stone, "Warrior's War-Club", 80)
            {
                Damage = 12,
                Accuracy = 0.9
            };

            // Create warrior with club
            Npc warrior = new("Tribal Warrior", weapon, bodyStats)
            {
                Description = "A fierce warrior with ritual paint markings."
            };

            // Add some loot
            warrior.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Knapped-Flint Scraper", 60));

            return warrior;
        }

        public static Npc MakeTribalShaman()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 60,
                fatPercent = 0.20,
                musclePercent = 0.45
            };

            // Create a ritual staff
            var weapon = new Weapon(WeaponType.Knife, WeaponMaterial.Bone, "Shamanic Bone-Knife", 90)
            {
                Damage = 6,
                Accuracy = 1.1
            };

            // Create shaman with staff
            Npc shaman = new("Tribal Shaman", weapon, bodyStats)
            {
                Description = "An elderly shaman adorned with animal bones and feathers."
            };

            // Add some rare loot
            shaman.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Obsidian, "Night-Glass Ritual Knife", 95));

            return shaman;
        }
    }
}================================================================================

File: ./Actors/NpcSpawner.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Actors
{
    public class NpcSpawner
    {
        private List<Func<Npc>> _factories { get; set; }

        public NpcSpawner()
        {
            _factories = [];
        }

        public NpcSpawner(List<Func<Npc>> factories)
        {
            _factories = factories;
        }

        public void Add(Func<Npc> factory)
        {
            _factories.Add(factory);
        }

        public Npc? GenerateRandomNpc()
        {
            if (_factories.Count == 0)
            {
                throw new Exception("No factories");
            }
            var fac = Utils.GetRandomFromList(_factories);
            return fac();
        }
    }
}================================================================================

File: ./Actors/Actor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Items;
using text_survival.Level;
using text_survival.PlayerComponents;

namespace text_survival.Actors;

public abstract class Actor
{
    public string Name;
    public virtual void Attack(Actor target, string? bodyPart = null) => combatManager.Attack(target, bodyPart);

    public virtual BodyPart? Damage(DamageInfo damage) => Body.Damage(damage);
    public virtual void Heal(HealingInfo heal) => Body.Heal(heal);

    public bool IsEngaged { get; set; }
    public bool IsAlive => !Body.IsDestroyed;
    public abstract Weapon ActiveWeapon { get; protected set; }

    public virtual void ApplyEffect(Effect effect) => _effectRegistry.AddEffect(effect);
    public virtual void RemoveEffect(Effect effect) => _effectRegistry.RemoveEffect(effect);
    public virtual List<Effect> GetEffectsByKind(string kind) => _effectRegistry.GetEffectsByKind(kind);
    public virtual void Update()
    {
        _effectRegistry.Update();
        Body.Update(TimeSpan.FromMinutes(1));
    }

    public SkillRegistry _skillRegistry { get; init; }
    public Body Body { get; init; }
    protected EffectRegistry _effectRegistry { get; init; }
    protected CombatManager combatManager { get; init; }

    public override string ToString() => Name;

    protected Actor(string name, BodyStats stats)
    {
        Name = name;
        _effectRegistry = new EffectRegistry(this);
        _skillRegistry = new SkillRegistry();
        this.combatManager = new CombatManager(this);
        Body = new Body(Name, stats, _effectRegistry);
    }
}


================================================================================

File: ./Actors/NPC.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.Bodies;
using text_survival.Events;

namespace text_survival.Actors
{
    public class Npc : Actor
    {
        #region Properties

        // Basic properties
        public string Description { get; set; }
        public bool IsFound { get; set; }
        public bool IsHostile { get; private set; }
        public override Weapon ActiveWeapon { get; protected set; }

        // IPhysicalEntity implementation
        public double Health => Body.Health;
        public double MaxHealth => Body.MaxHealth;
        public bool IsDestroyed => Body.IsDestroyed;

        // Internal components

        private Container Loot { get; }

        #endregion

        #region Constructor

        public Npc(string name, Weapon weapon, BodyStats stats) : base(name, stats)
        {
            Description = "";
            IsHostile = true;
            ActiveWeapon = weapon;

            _skillRegistry = new SkillRegistry(false);
            Loot = new Container(name, 10);
        }

        #endregion


        #region IInteractable Interface Implementation

        public void Interact(Player player)
        {
            if (IsAlive)
            {
                Combat.CombatLoop(player, this);
            }
            else
            {
                if (Loot.IsEmpty)
                {
                    Output.WriteLine("There is nothing to loot.");
                    return;
                }
                Loot.Open(player);
            }
        }

        public Command<Player> InteractCommand
        {
            get
            {
                string name = IsAlive ? "Fight " + Name : "Loot " + Name;
                return new Command<Player>(name, Interact);
            }
        }

        #endregion



        #region Inventory and Loot Methods

        public void AddLoot(Item item) => Loot.Add(item);

        #endregion

        public override string ToString() => Name;
    }
}================================================================================

File: ./Items/Container.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Items
{
    public class Container
    {
        private string _name;
        public string Name { get => (IsEmpty && HasBeenOpened) ? _name + " (Empty)" : _name; set => _name = value; }
        public double Weight() => Items.Sum(item => item.Weight);
        public float MaxWeight { get; set; }
        public List<Item> Items { get; }
        public bool IsEmpty => Items.Count == 0;
        protected bool HasBeenOpened { get; set; }
        public bool IsFound { get; set; }

        public Container(string name, float maxWeight)
        {
            _name = name;
            MaxWeight = maxWeight;
            Items = [];
        }

        public Item GetItem(int index) => Items[index];
        public Item GetItemByName(string itemName) => Items.First(i => i.Name.Equals(itemName));

        public void Interact(Player player)
        {
            if (!Combat.SpeedCheck(player))
            {
                Npc npc = Combat.GetFastestNpc(player.CurrentLocation);
                Output.WriteLine("You couldn't get past the ", npc, "!");
                npc.Interact(player);
                return;
            }
            Output.WriteLine("You open the ", this);
            Open(player);
        }

        public Command<Player> InteractCommand => new("Look in " + Name, Interact);

        public virtual void Open(Player player)
        {
            HasBeenOpened = true;
            while (!IsEmpty)
            {
                Output.WriteLine(this, ":");

                var items = new List<Item>(Items);
                Item takeAll = new Item("Take all");
                if (items.Count > 1)
                {
                    items.Add(takeAll);
                }

                var itemStacks = ItemStack.CreateStacksFromItems(items);

                var selection = Input.GetSelectionFromList(itemStacks, true, "Close " + this);
                if (selection == null) return;

                Item selectedItem = selection.Take();

                if (selectedItem == takeAll)
                {
                    TakeAll(player);
                    return;
                }

                Output.WriteLine("What would you like to do with ", selectedItem);
                string? choice = Input.GetSelectionFromList(["Take", "Inspect"], true);
                switch (choice)
                {
                    case null:
                        continue;
                    case "Take":
                        Remove(selectedItem);
                        player.TakeItem(selectedItem);
                        break;
                    case "Inspect":
                        Describe.DescribeItem(selectedItem);
                        break;
                    case "Use":
                        Remove(selectedItem);
                        player.TakeItem(selectedItem);
                        player.UseItem(selectedItem);
                        break;
                }
            }
            Output.WriteLine(this, " is empty.");
        }


        private void TakeAll(Player player)
        {
            while (!IsEmpty)
            {
                var item = Items.First();
                Remove(item);
                player.TakeItem(item);
            }
        }

        public override string ToString() => Name;

        public void Add(Item item)
        {
            if (item.Weight + Weight() > MaxWeight)
            {
                Output.Write("The ", this, "is full!\n");
                return;
            }
            Items.Add(item);
        }

        public void Remove(Item item) => Items.Remove(item);
        public int Count() => Items.Count;

    }
}
================================================================================

File: ./Items/Item.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;

using text_survival.IO;

namespace text_survival.Items
{
    //public interface IItem
    //{
    //    string Name { get; set; }
    //    double Weight { get; set; } // in kg
    //    Action<Player> UseEffect { get; set; }
    //    string Description { get; set; }
    //    int Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
    //    string ToString();
    //    void Use(Player player);
    //}

    public class Item
    {
        public string Name { get; set; }
        public double Weight { get; set; } // in kg
        public string Description { get; set; } = "";
        public double Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
        public bool IsFound { get; set; }
        public int NumUses { get; set; }

        public Item(string name, double weight = 1, int quality = 50)
        {
            Name = name;
            Weight = weight;
            Quality = quality;
            NumUses = -1; // not consumable
        }

        public override string ToString()
        {
            return Name;
        }
        

        public void Interact(Player player)
        {
            if (!Combat.SpeedCheck(player))
            {
                Npc npc = Combat.GetFastestNpc(player.CurrentLocation);
                Output.WriteLine("You couldn't get past the ", npc, "!");
                npc.Interact(player);
                return;
            }
            player.TakeItem(this);
        }
        public Command<Player> InteractCommand => new Command<Player>("Pick up " + Name, Interact);

    }
}
================================================================================

File: ./Items/FoodItem.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;

namespace text_survival.Items
{
    public interface IEdible
    {
        int WaterContent { get; }
        int Calories { get; }
    }

    public class FoodItem : Item, IEdible
    {
        public FoodItem(string name, int calories, int waterContent = 0, double weight = .5) : base(name, weight)
        {
            Quality = 100;
            Calories = calories;
            WaterContent = waterContent;
            NumUses = 1;
        }

        public int WaterContent { get; }
        public int Calories { get; }
        public HealingInfo? HealthEffect {get; set;}
        public DamageInfo? DamageEffect {get; set;}
        public void Update()
        {
            Quality -= .1; //TODO: Add spoilage
        }
        public override string ToString() => Name;
    }
}
================================================================================

File: ./Items/IEquippable.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Effects;

namespace text_survival.Items
{
    public interface IEquippable
    {
        // public List<Buff> GetEquipBuffs();
        // public void AddEquipBuff(Buff buff);
        // public void RemoveEquipBuff(Buff buff);
        public List<Effect> EquipEffects { get; }
    }

}================================================================================

File: ./Items/ItemStack.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class ItemStack
{
    public string DisplayName => Items.Count == 1 ? FirstItem.Name : $"{FirstItem.Name} x{Items.Count}";
    public Item FirstItem { get; private set; }
    public Stack<Item> Items { get; private set; }
    public int Count => Items.Count;
    
    public ItemStack(Item item)
    {
        FirstItem = item;
        Items = new Stack<Item>();
        Items.Push(item);
    }
    
    public void Add(Item item)
    {
        if (item.Name != FirstItem.Name)
        {
            throw new ArgumentException($"Cannot add item '{item.Name}' to stack of '{FirstItem.Name}'");
        }
        
        Items.Push(item);
    }
    
    public Item Take() => Items.Pop();
    
    public override string ToString() => DisplayName;
    
    public static List<ItemStack> CreateStacksFromItems(IEnumerable<Item> items)
    {
        var stacksByName = new Dictionary<string, ItemStack>();
        
        foreach (var item in items)
        {
            if (stacksByName.TryGetValue(item.Name, out var stack))
            {
                stack.Add(item);
            }
            else
            {
                stacksByName[item.Name] = new ItemStack(item);
            }
        }
        
        return stacksByName.Values.ToList();
    }
}================================================================================

File: ./Items/Gear.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Gear : Item, IEquippable
    {
        // private List<Buff> EquipBuffs { get; }
        // public List<Buff> GetEquipBuffs() => EquipBuffs;
        // public void AddEquipBuff(Buff buff) => EquipBuffs.Add(buff);
        // public void RemoveEquipBuff(Buff buff) => EquipBuffs.Remove(buff);
        public List<Effect> EquipEffects { get; set; }
        public double Warmth { get; set; }
        public Gear(string name, double weight = 1, int quality = 50) : base(name, weight, quality)
        {
            EquipEffects = [];
        }
    }

}

================================================================================

File: ./Items/ConsumableItem.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.Items;

namespace text_survival.Actors;

class ConsumableItem : Item
{
    public ConsumableItem(string name, int numUses=1) : base(name)
    {
        Effects = [];
        NumUses = numUses;
    }

    public List<Effect> Effects;
}
================================================================================

File: ./Items/ModifierItem.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class WeaponModifierItem : Item
{
    public double Damage { get; set; }
    public WeaponModifierItem(string name) : base(name)
    {
        Damage = 0;
    }

}

public class ArmorModifierItem : Item
{
    public List<EquipSpots> ValidArmorTypes;
    public double Warmth { get; set; }
    public double Rating { get; set; }
    public ArmorModifierItem(string name, List<EquipSpots> validArmorTypes) : base(name)
    {
        ValidArmorTypes = validArmorTypes;
        Warmth = 0;
        Rating = 0;
    }

}================================================================================

File: ./Items/Armor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Armor : Gear
    {
        public EquipSpots EquipSpot { get; set; }
        public double Rating { get; set; }
        public ArmorClass Type { get; set; }

        public Armor(string name, double rating, EquipSpots equipSpot, double warmth = 0, ArmorClass type = ArmorClass.Light) : base(name)
        {
            EquipEffects = [];
            Rating = rating;
            EquipSpot = equipSpot;
            Warmth = warmth;
            Type = type;
        }


    }
}================================================================================

File: ./Items/ItemEnums.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum EquipSpots
    {
        Head,
        Chest,
        Legs,
        Feet,
        Hands,
        Weapon
    }

    public enum ArmorClass
    {
        Light,
        Heavy
    }







}================================================================================

File: ./Items/Weapon.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum WeaponType
    {
        // Crafted weapons
        Spear,          // Long distance hunting/combat
        Club,           // Heavy blunt force
        HandAxe,        // Cutting tool and weapon
        Knife,          // Sharp tool made of flint or similar
        SharpStone,     // Primitive cutting tool

        // Natural weapons
        Unarmed,        // Human fists
        Claws,          // Bear, large feline
        Fangs,          // Wolf, snake
        Horns           // Mammoth tusks, deer antlers
    }

    public enum WeaponClass
    {
        Blade,          // Cutting damage
        Blunt,          // Impact damage
        Pierce,         // Stabbing damage
        Claw,           // Tearing damage
        Unarmed         // Basic damage
    }

    public enum WeaponMaterial
    {
        Wood,           // Sticks, branches
        Stone,          // Basic stone
        Bone,           // Animal bones
        Antler,         // Deer/elk antlers
        Flint,          // Knapped flint
        Obsidian,       // Volcanic glass
        Organic,        // Natural animal weapons
        Other           // Miscellaneous
    }
    public class Weapon : Gear
    {
        public WeaponClass Class { get; set; }
        public WeaponMaterial Material { get; set; }
        public WeaponType Type { get; set; }
        public double Damage { get; set; }
        public double Accuracy { get; set; }
        public double BlockChance { get; set; }
        public double Craftsmanship { get; set; }

        public Weapon(WeaponType type, WeaponMaterial material, string name = "", int craftsmanship = 50)
            : base(name, quality: craftsmanship)
        {
            Craftsmanship = craftsmanship;
            SetBaseStats(type);
            ApplyMaterialModifier(material);
            ApplyCraftsmanshipModifier();
            Class = GetDamageTypeFromWeaponType(type);

            if (string.IsNullOrWhiteSpace(name))
                Name = $"{GetCraftsmanshipDescription(Craftsmanship)} {GetMaterialDescription(material)} {GetWeaponTypeDescription(type)}";

            Type = type;
            Material = material;
            EquipEffects = [];
        }

        private void ApplyCraftsmanshipModifier()
        {
            // The better crafted the weapon, the more effective it is
            Damage *= (Craftsmanship * 1.5) / 100;
            BlockChance *= Craftsmanship / 100;
        }

        private void ApplyMaterialModifier(WeaponMaterial material)
        {
            switch (material)
            {
                case WeaponMaterial.Wood:
                    Damage *= 0.6;
                    BlockChance *= 0.7;
                    Weight *= 0.5;
                    break;
                case WeaponMaterial.Stone:
                    Damage *= 1.0;
                    BlockChance *= 0.6;
                    Weight *= 1.2;
                    break;
                case WeaponMaterial.Bone:
                    Damage *= 0.8;
                    BlockChance *= 0.8;
                    Weight *= 0.7;
                    break;
                case WeaponMaterial.Antler:
                    Damage *= 0.9;
                    BlockChance *= 0.7;
                    Weight *= 0.8;
                    break;
                case WeaponMaterial.Flint:
                    Damage *= 1.2;
                    BlockChance *= 0.5;
                    Weight *= 1.0;
                    break;
                case WeaponMaterial.Obsidian:
                    Damage *= 1.4;
                    BlockChance *= 0.4;
                    Weight *= 0.9;
                    break;
                case WeaponMaterial.Organic:
                case WeaponMaterial.Other:
                default:
                    // No modifiers for natural/organic materials
                    break;
            }
        }

        private void SetBaseStats(WeaponType type)
        {
            switch (type)
            {
                case WeaponType.Spear:
                    Damage = 8;
                    BlockChance = 0.12;
                    Accuracy = 1.2;
                    Weight = 1.5;
                    break;
                case WeaponType.Club:
                    Damage = 10;
                    BlockChance = 0.08;
                    Accuracy = 0.9;
                    Weight = 2.0;
                    break;
                case WeaponType.HandAxe:
                    Damage = 12;
                    BlockChance = 0.05;
                    Accuracy = 0.8;
                    Weight = 1.8;
                    break;
                case WeaponType.Knife:
                    Damage = 6;
                    BlockChance = 0.02;
                    Accuracy = 1.4;
                    Weight = 0.5;
                    break;
                case WeaponType.SharpStone:
                    Damage = 4;
                    BlockChance = 0.01;
                    Accuracy = 1.1;
                    Weight = 0.3;
                    break;
                case WeaponType.Unarmed:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.5;
                    Weight = 0;
                    break;
                default:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.0;
                    Weight = 0.5;
                    break;
            }
        }

        public static Weapon GenerateRandomWeapon()
        {
            // Filter out unarmed and natural weapons when generating random weapons
            var validTypes = Enum.GetValues(typeof(WeaponType))
                .Cast<WeaponType>()
                .Where(t => t != WeaponType.Unarmed &&
                            t != WeaponType.Claws &&
                            t != WeaponType.Fangs &&
                            t != WeaponType.Horns)
                .ToArray();

            // Filter out organic and other from random generation
            var validMaterials = Enum.GetValues(typeof(WeaponMaterial))
                .Cast<WeaponMaterial>()
                .Where(m => m != WeaponMaterial.Organic && m != WeaponMaterial.Other)
                .ToArray();

            WeaponMaterial material = validMaterials[Utils.RandInt(0, validMaterials.Length - 1)];
            WeaponType type = validTypes[Utils.RandInt(0, validTypes.Length - 1)];

            int craftsmanship = Utils.RandInt(30, 80); // Primitive technology has limited upper quality

            return new Weapon(type, material, craftsmanship: craftsmanship);
        }

        private static WeaponClass GetDamageTypeFromWeaponType(WeaponType type)
        {
            return type switch
            {
                WeaponType.Knife => WeaponClass.Blade,
                WeaponType.SharpStone => WeaponClass.Blade,
                WeaponType.HandAxe => WeaponClass.Blade,
                WeaponType.Spear => WeaponClass.Pierce,
                WeaponType.Club => WeaponClass.Blunt,
                WeaponType.Unarmed => WeaponClass.Unarmed,
                WeaponType.Claws => WeaponClass.Claw,
                WeaponType.Fangs => WeaponClass.Pierce,
                WeaponType.Horns => WeaponClass.Pierce,
                _ => WeaponClass.Blunt,
            };
        }

        private string GetCraftsmanshipDescription(double craftsmanship)
        {
            return craftsmanship switch
            {
                0 => "Broken",
                < 20 => "Primitive",
                < 40 => "Rough",
                < 60 => "Simple",
                < 80 => "Sturdy",
                < 95 => "Master Crafted",
                <= 100 => "Flawless",
                _ => "Strange"
            };
        }

        private string GetMaterialDescription(WeaponMaterial material)
        {
            return material switch
            {
                WeaponMaterial.Wood => "Wooden",
                WeaponMaterial.Stone => "Stone",
                WeaponMaterial.Bone => "Bone",
                WeaponMaterial.Antler => "Antler",
                WeaponMaterial.Flint => "Flint",
                WeaponMaterial.Obsidian => "Obsidian",
                WeaponMaterial.Organic => "",
                WeaponMaterial.Other => "",
                _ => ""
            };
        }

        private string GetWeaponTypeDescription(WeaponType type)
        {
            return type switch
            {
                WeaponType.Spear => "Spear",
                WeaponType.Club => "Club",
                WeaponType.HandAxe => "Hand Axe",
                WeaponType.Knife => "Knife",
                WeaponType.SharpStone => "Sharp Stone",
                WeaponType.Unarmed => "Fists",
                WeaponType.Claws => "Claws",
                WeaponType.Fangs => "Fangs",
                WeaponType.Horns => "Horns",
                _ => "Tool"
            };
        }
    }
}================================================================================

File: ./Items/ItemFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Effects;


namespace text_survival.Items
{
    public class ItemFactory
    {
        public static readonly Dictionary<string, Func<Item>> ItemDefinitions = new()
        {
            { "Mushroom", MakeMushroom },
            { "Berries", MakeBerry },
            { "Roots", MakeRoots },
            { "Water", MakeWater },
            { "Stick", MakeStick },
            { "Firewood", MakeFirewood },
            { "Flint", MakeFlint },
            { "Clay", MakeClay },
            { "Stone", MakeStone },
            { "Bone", MakeBone },
            { "Spear", MakeSpear },
            { "Club", MakeClub },
            { "HandAxe", MakeHandAxe },
            { "Knife", MakeKnife },
            { "Hide Shield", MakeHideShield },
            { "Fur Armor", MakeFurArmor },
            { "Healing Herbs", MakeHealingHerbs },
            { "Bandage", MakeBandage },
            { "Torch", MakeTorch },
            { "Fish", MakeFish },
            { "Primitive Weapon", Weapon.GenerateRandomWeapon }
        };

        public static Weapon MakeFists()
        {
            return new Weapon(WeaponType.Unarmed, WeaponMaterial.Organic, "Bare Hands");
        }

        public static FoodItem MakeMushroom()
        {
            var mushroom = new FoodItem("Wild Mushroom", 25, 5)
            {
                Description = "A forest mushroom. Some varieties are nutritious, others are deadly.",
                Weight = 0.1F
            };

            double strength = Utils.RandDouble(1, 15);
            string targetOrgan = Utils.GetRandomFromList(["Stomach", "Liver", "Kidney"]);

            if (Utils.FlipCoin())
            {
                mushroom.HealthEffect = new()
                {
                    Amount = strength,
                    Type = "herbal",
                    TargetPart = targetOrgan,
                    Quality = Utils.RandDouble(0, 1.5)
                };
            }
            else
            {
                mushroom.DamageEffect = new()
                {
                    Amount = strength * .66,
                    IsPenetrating = true,
                    Type = "poison",
                    TargetPart = targetOrgan,
                    Accuracy = 1,
                };
            }
            return mushroom;
        }

        public static FoodItem MakeBerry()
        {
            var item = new FoodItem("Wild Berries", 120, 100);
            string color = Utils.GetRandomFromList(["red", "blue", "black", "purple"]);
            string season = Utils.GetRandomFromList(["autumn", "summer"]);
            item.Description = $"A handful of {color} {season} berries. Sweet and juicy.";
            item.Weight = 0.1F;
            return item;
        }

        public static FoodItem MakeRoots()
        {
            var item = new FoodItem("Foraged Roots", 100, 20)
            {
                Description = "Starchy roots dug from the ground. Tough but nutritious.",
                Weight = 0.3F
            };
            return item;
        }

        public static FoodItem MakeWater()
        {
            var item = new FoodItem("Fresh Water", 0, 1000)
            {
                Description = "Clear water collected from a stream. Stored in a water skin made from animal bladder.",
                Weight = 1
            };
            return item;
        }

        public static Item MakeStick()
        {
            Item stick = new Item("Sturdy Stick")
            {
                Description = "A strong branch, useful for making tools and weapons.",
                Weight = 0.5
            };
            return stick;
        }

        public static Item MakeFirewood()
        {
            var wood = new Item("Firewood")
            {
                Description = "Dry wood gathered for making fires. Essential for warmth and cooking.",
                Weight = 1.5
            };
            return wood;
        }

        public static Item MakeFlint()
        {
            var flint = new Item("Knapping Flint")
            {
                Description = "Sharp-edged stone perfect for making cutting tools and starting fires.",
                Weight = 0.2
            };
            return flint;
        }

        public static Item MakeClay()
        {
            var clay = new Item("River Clay")
            {
                Description = "Malleable clay gathered from a riverbank. Could be shaped into vessels.",
                Weight = 1.0
            };
            return clay;
        }

        public static Item MakeStone()
        {
            var item = new Item("River Stone")
            {
                Description = "A smooth river stone. Useful for tools or cooking.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeBone()
        {
            var bone = new Item("Animal Bone")
            {
                Description = "A sturdy bone from a large animal. Good material for tools and weapons.",
                Weight = 0.3
            };
            return bone;
        }

        public static Weapon MakeSpear()
        {
            Weapon spear = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Hunting Spear", 65)
            {
                Description = "A long wooden shaft with a sharpened flint point. Good for hunting and defense.",
                Weight = 1.5
            };
            return spear;
        }

        public static Weapon MakeClub()
        {
            Weapon club = new Weapon(WeaponType.Club, WeaponMaterial.Wood, "War Club", 60)
            {
                Description = "A heavy wooden club reinforced with stone. Brutal but effective.",
                Weight = 2.0
            };
            return club;
        }

        public static Weapon MakeHandAxe()
        {
            Weapon axe = new Weapon(WeaponType.HandAxe, WeaponMaterial.Stone, "Stone Hand Axe", 70)
            {
                Description = "A sharp stone blade bound to a wooden handle with animal sinew.",
                Weight = 1.8
            };
            return axe;
        }

        public static Weapon MakeKnife()
        {
            Weapon knife = new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Flint Knife", 75)
            {
                Description = "A razor-sharp flint blade with a bone handle. Essential for skinning and cutting.",
                Weight = 0.4
            };
            return knife;
        }

        public static Armor MakeHideShield()
        {
            Armor shield = new Armor("Hide Shield", .15, EquipSpots.Hands, 1)
            {
                Description = "A wooden frame covered with animal hide. Offers basic protection.",
                Weight = 2.0
            };
            return shield;
        }

        public static Armor MakeFurArmor()
        {
            Armor armor = new Armor("Fur Armor", .25, EquipSpots.Chest, 8)
            {
                Description = "A thick fur pelt worn as protection. Offers warmth and some defense against attacks.",
                Weight = 3.0
            };
            return armor;
        }

        public static FoodItem MakeLargeMeat()
        {
            var item = new FoodItem("Large Game Meat", 600, 0)
            {
                Description = "A substantial cut of meat from a large animal. Will need to be cooked.",
                Weight = 1.5
            };
            return item;
        }

        public static FoodItem MakeSmallMeat()
        {
            var item = new FoodItem("Small Game Meat", 200, 0)
            {
                Description = "A modest portion of meat from a small animal. Best cooked before eating.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeHealingHerbs()
        {
            var herbs = new FoodItem("Healing Herbs", 10, 5)
            {
                Description = "A bundle of medicinal plants known for their healing properties.",
                Weight = 0.2,
                NumUses = 1,
                HealthEffect = new()
                {
                    Amount = 15,
                    Type = "herbal",
                    Quality = 0.7,
                    TargetPart = null
                }
            };
            return herbs;
        }

        public static Item MakeBandage()
        {
            var bandage = new ConsumableItem("Bark Bandage")
            {
                Description = "Strips of inner tree bark pounded soft. Can bind wounds and stop bleeding.",
                Weight = 0.1,
                Effects = [
                    new RemoveBleedEffect("bandage", null)
                ]
            };
            return bandage;
        }

        public static Gear MakeTorch()
        {
            Gear torch = new Gear("Pine Torch", 0.8)
            {
                Description = "A branch wrapped with resin-soaked pine needles. Provides light and warmth.",
                Warmth = 5
            };
            return torch;
        }

        public static FoodItem MakeFish()
        {
            var item = new FoodItem("River Fish", 200, 0)
            {
                Description = "A freshly caught fish. Rich in nutrients and relatively easy to obtain near water.",
                Weight = 0.4
            };
            return item;
        }

        public static Item MakeVenomSac()
        {
            Item venom = new WeaponModifierItem("Venom Sac")
            {
                Description = "A fragile sac of venom extracted from a poisonous creature. Could coat a weapon.",
                Weight = 0.1,
                NumUses = 2,
                Damage = 2
            };
            return venom;
        }

        public static Item MakeSpiderSilk()
        {
            Item silk = new ArmorModifierItem("Spider Silk", [EquipSpots.Hands, EquipSpots.Feet, EquipSpots.Head])
            {
                Weight = 0.1,
                Description = "Fine, strong threads collected from giant spider webs. Useful for binding and insulation.",
                Warmth = 0.5
            };
            return silk;
        }

        public static Armor MakeFurHood()
        {
            Armor hood = new Armor("Fur Hood", .05, EquipSpots.Head, 3)
            {
                Description = "A hood made from animal fur. Keeps the head and ears warm in frigid weather.",
                Weight = 0.3
            };
            return hood;
        }

        public static Armor MakeLeatherTunic()
        {
            Armor tunic = new Armor("Leather Tunic", .10, EquipSpots.Chest, 4)
            {
                Description = "A simple tunic made from tanned animal hide. Basic protection from the elements.",
                Weight = 1.5
            };
            return tunic;
        }

        public static Armor MakeLeatherPants()
        {
            Armor leggings = new Armor("Leather Pants", .08, EquipSpots.Legs, 3)
            {
                Description = "Pants made from tanned animal hide. Protects the legs from brush and minor injuries.",
                Weight = 1.0
            };
            return leggings;
        }

        public static Armor MakeMoccasins()
        {
            Armor shoes = new Armor("Hide Moccasins", .03, EquipSpots.Feet, 2)
            {
                Description = "Soft footwear made from animal hide. More durable than bare feet on rough terrain.",
                Weight = 0.4
            };
            return shoes;
        }

        public static Item MakeMammothTusk()
        {
            Item tusk = new WeaponModifierItem("Mammoth Tusk")
            {
                Description = "A massive curved tusk from a woolly mammoth. Extremely valuable and rare.",
                Weight = 10.0,
                NumUses = 1,
                Damage = 5
            };
            return tusk;
        }

        public static Item MakeSaberToothFang()
        {
            Item fang = new WeaponModifierItem("Saber-Tooth Fang")
            {
                Description = "A long, curved fang from a saber-tooth tiger. Could be fashioned into a deadly weapon.",
                Weight = 0.3,
                NumUses = 1,
                Damage = 4
            };
            return fang;
        }

        public static Item MakeAntlerTine()
        {
            Item antler = new Item("Antler Tine")
            {
                Description = "A prong from a deer or elk antler. Useful for punching holes in hide or as a tool.",
                Weight = 0.2
            };
            return antler;
        }

        public static Item MakeSinew()
        {
            Item sinew = new Item("Animal Sinew")
            {
                Description = "Tough fibrous tissue from animal tendons. Essential for binding, sewing and bowstrings.",
                Weight = 0.1
            };
            return sinew;
        }

        public static Armor MakeBoneNecklace()
        {
            Armor necklace = new Armor("Bone Talisman", 0, EquipSpots.Chest, 0.5)
            {
                Description = "A primitive necklace made from small bones and stones. Said to bring good fortune.",
                Weight = 0.1
            };
            return necklace;
        }

        public static Item MakeObsidianShard()
        {
            Item obsidian = new Item("Obsidian Shard")
            {
                Description = "A piece of naturally occurring volcanic glass. Can be knapped into extremely sharp tools.",
                Weight = 0.2
            };
            return obsidian;
        }

        public static Item MakeOchrePigment()
        {
            Item ochre = new Item("Red Ochre")
            {
                Description = "Earthy clay pigment used for body decoration, cave paintings, and hide treatment.",
                Weight = 0.3
            };
            return ochre;
        }
    }
}================================================================================

File: ./obj/Debug/net8.0/text_survival.GlobalUsings.g.cs
--------------------------------------------------------------------------------
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
================================================================================

File: ./obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
--------------------------------------------------------------------------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
================================================================================

File: ./obj/Debug/net8.0/text_survival.AssemblyInfo.cs
--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("text_survival")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+f2aa2cc39de742459dd11c93fe3937af89f15d67")]
[assembly: System.Reflection.AssemblyProductAttribute("text_survival")]
[assembly: System.Reflection.AssemblyTitleAttribute("text_survival")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

================================================================================

File: ./Events/ThirstEvents.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Events;


public class DehydrationEvent(Actor target, bool isNew) : IGameEvent
{
    public Actor Target = target;
    public bool IsNew = isNew;
}
public class DehydrationEventHandler : IEventHandler<DehydrationEvent>
{
    public void Handle(DehydrationEvent gameEvent)
    {
        if (gameEvent.IsNew)
        {
            Output.WriteDanger($"{gameEvent.Target.Name} is dehydrated!\n");
        }
        else if (Utils.DetermineSuccess(.1))
        {
            Output.WriteWarning($"{gameEvent.Target.Name} is still dehydrated.\n");

        }
        var target = gameEvent.Target;
        var damage = new DamageInfo()
        {
            Amount = 1,
            Type = "dehydration",
            IsPenetrating = true
        };
        target.Damage(damage);
    }
}

public class StoppedDehydrationEvent(Actor target) : IGameEvent
{
    public Actor Target = target;
}
public class StoppedDehydrationEventHandler : IEventHandler<StoppedDehydrationEvent>
{
    public void Handle(StoppedDehydrationEvent gameEvent)
    {
        Output.WriteSuccess($"{gameEvent.Target.Name} is no longer dehydrated!\n");
    }
}
================================================================================

File: ./Events/CalorieSurplusEvent.cs
--------------------------------------------------------------------------------

using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Events;

public class CalorieSurplusEvent(Body target, double calories) : IGameEvent
{
    public Body Target = target;
    public double Calories = calories;
}

public class CalorieSurplusEventHandler : IEventHandler<CalorieSurplusEvent>
{
    private const double CALORIES_PER_KG_FAT = 7700.0; // Standard calories stored in 1kg of fat

    public void Handle(CalorieSurplusEvent gameEvent)
    {

        double fatGain = gameEvent.Calories / CALORIES_PER_KG_FAT;

        gameEvent.Target.BodyFat += fatGain;

        int gFatGain = (int)(fatGain * 1000);
        Output.WriteLine($"{gameEvent.Target.OwnerName} gains {gFatGain}g of body fat from excess calories.");

    }

}
================================================================================

File: ./Events/ColdEvents.cs
--------------------------------------------------------------------------------

using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

namespace text_survival.Events;

public class BodyColdEvent(Body target, bool isNew) : IGameEvent
{
    public Body Target = target;
    public bool IsNew = isNew;

}

public class BodyColdEventHandler : IEventHandler<BodyColdEvent>
{
    private const double ShiveringThreshold = 97.0; // °F
    private const double HypothermiaThreshold = 95.0;  // °F
    private const double SevereHypothermiaThreshold = 89.6; // °F
    public void Handle(BodyColdEvent evt)
    {
        var target = evt.Target;
        var bodyTemperature = target.BodyTemperature;


        if (evt.IsNew)
        {
            Output.WriteDanger($"{target.OwnerName} is cold!\n");
        }
        else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
        {
            Output.WriteWarning($"{target.OwnerName} is still cold.\n");
        }

        if (bodyTemperature < ShiveringThreshold)
        {
            ApplyShivering(target);
        }
        else
        {
            // Remove shivering effects when temperature normalizes
            target.EffectRegistry.RemoveEffectsByKind("Shivering");
        }

        if (bodyTemperature < HypothermiaThreshold)
        {
            ApplyHypothermia(target);
        }

        if (bodyTemperature < SevereHypothermiaThreshold)
        {
            ApplyFrostbite(target);
        }
    }


    private void ApplyShivering(Body target)
    {
        // Calculate severity based on temperature
        double intensity = (ShiveringThreshold - target.BodyTemperature) / 5.0;
        intensity = Math.Clamp(intensity, 0.01, 1.0);

        // Apply to whole body (will handle stacking through EffectRegistry)
        var shiveringEffect = new ShiveringEffect(intensity);

        target.EffectRegistry.AddEffect(shiveringEffect);
    }


    private void ApplyHypothermia(Body target)
    {
        // Calculate severity based on temperature
        double severity = Math.Clamp((HypothermiaThreshold - target.BodyTemperature) / 10.0, 0.01, 1.0);

        // Apply to whole body (will handle stacking through EffectRegistry)
        var hypothermia = new TemperatureInjury(
            TemperatureInjury.TemperatureInjuryType.Hypothermia,
            "Cold exposure",
            null,
            severity);

        target.EffectRegistry.AddEffect(hypothermia);

    }


    private void ApplyFrostbite(Body target)
    {
        // Get extremities (hands and feet)
        var extremities = target.GetAllParts()
            .Where(p => p.Name.Contains("Hand") || p.Name.Contains("Foot"))
            .ToList();

        foreach (var extremity in extremities)
        {
            // Calculate severity based on temperature
            double severity = Math.Clamp((SevereHypothermiaThreshold - target.BodyTemperature) / 5.0, 0.01, 1.0);

            // Apply frostbite to extremity (will handle stacking through EffectRegistry)
            var frostbite = new TemperatureInjury(
                TemperatureInjury.TemperatureInjuryType.Frostbite,
                "Extreme cold",
                extremity,
                severity);

            target.EffectRegistry.AddEffect(frostbite);
        }
    }

}================================================================================

File: ./Events/EventBus.cs
--------------------------------------------------------------------------------
namespace text_survival.Events;

public interface IGameEvent { }

public interface IEventHandler<T> where T : IGameEvent
{
    void Handle(T gameEvent);
}

public static class EventBus
{
    private static readonly Dictionary<Type, List<object>> _handlers = new();

    public static void Subscribe<T>(IEventHandler<T> handler) where T : IGameEvent
    {
        var eventType = typeof(T);
        if (!_handlers.TryGetValue(eventType, out List<object>? value))
        {
            value = [];
            _handlers[eventType] = value;
        }

        value.Add(handler);
    }

    public static void Publish<T>(T gameEvent) where T : IGameEvent
    {
        var eventType = typeof(T);
        if (_handlers.TryGetValue(eventType, out List<object>? eventHandlers))
        {
            eventHandlers.Cast<IEventHandler<T>>().ToList().ForEach(h => h.Handle(gameEvent));
        }
    }
}================================================================================

File: ./Events/StarvingEvent.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Events;

public class StarvingEvent(Body target, double calories, bool isNew) : IGameEvent
{
    public Body Target = target;
    public bool IsNew = isNew;
    public double Calories = calories;
}

public class StarvingEventHandler : IEventHandler<StarvingEvent>
{
    private const double CALORIES_PER_KG_MUSCLE = 5500.0; // Calories in 1kg of muscle (less than fat)
    private const double CALORIES_PER_KG_FAT = 7700.0;
    public void Handle(StarvingEvent gameEvent)
    {
        DisplayMessage(gameEvent);


        HandleBodyStarvation(gameEvent.Target, gameEvent.Calories);
        if (!ShouldApplyDamage(gameEvent.Target)) return; // has enough fat/muscle


        ApplyDamage(gameEvent.Target);
        // todo add more effects
    }

    // private methods //
    private static void DisplayMessage(StarvingEvent gameEvent)
    {
        if (gameEvent.IsNew)
        {
            Output.WriteDanger($"{gameEvent.Target.OwnerName} is starving!\n");
        }
        else if (Utils.DetermineSuccess(.1))
        {
            Output.WriteWarning($"{gameEvent.Target.OwnerName} is still starving.\n");
        }
    }

    private static void HandleBodyStarvation(Body body, double calories)
    {
        if (body.BodyFat > 0)
        {
            // Convert fat to energy
            double fatBurnRate = calories / CALORIES_PER_KG_FAT;
            body.BodyFat -= fatBurnRate;
        }
        else if (body.Muscle > 0)
        {
            // Convert muscle to energy
            double muscleBurnRate = calories / CALORIES_PER_KG_MUSCLE * 1.2; // Muscle burns less efficiently
            body.Muscle -= muscleBurnRate;
        }
    }

    private static bool ShouldApplyDamage(Body body)
    {
        // apply damage if fat and muscle are dangerously low
        return body.BodyFatPercentage <= 0.05 && body.MusclePercentage <= 0.05;
    }

    private static void ApplyDamage(Body target)
    {
        var damage = new DamageInfo()
        {
            Amount = 1,
            Type = "starvation",
            IsPenetrating = true
        };
        target.Damage(damage);
    }
}

public class StoppedStarvingEvent(Body target) : IGameEvent
{
    public Body Target = target;
}
public class StoppedStarvingEventHandler : IEventHandler<StoppedStarvingEvent>
{
    public void Handle(StoppedStarvingEvent gameEvent)
    {
        Output.WriteSuccess($"{gameEvent.Target.OwnerName} is no longer starving!\n");
    }
}================================================================================

File: ./Events/HeatEvents.cs
--------------------------------------------------------------------------------
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

namespace text_survival.Events;

public class BodyHotEvent(Body target, bool isNew) : IGameEvent
{
    public Body Target = target;
    public bool IsNew = isNew;
}


public class BodyHotEventHandler : IEventHandler<BodyHotEvent>
{
    private const double SweatingThreshold = 100.0; // °F
    private const double HyperthermiaThreshold = 99.5; // °F  
    public void Handle(BodyHotEvent evt)
    {
        var target = evt.Target;
        var bodyTemperature = target.BodyTemperature;


        if (evt.IsNew)
        {
            Output.WriteDanger($"{target.OwnerName} is hot!\n");
        }
        else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
        {
            Output.WriteWarning($"{target.OwnerName} is still hot.\n");
        }

        if (bodyTemperature > SweatingThreshold)
        {
            ApplySweating(target); // naturally resolves if not refreshed in 30 min
        }

        if (bodyTemperature > HyperthermiaThreshold)
        {
            ApplyHyperthermia(target);
        }
    }

    private void ApplyHyperthermia(Body target)
    {
        // Calculate severity based on temperature
        double severity = Math.Clamp((target.BodyTemperature - HyperthermiaThreshold) / 10.0, 0.01, 1.00);

        // Apply to whole body (will handle stacking through EffectRegistry)
        var hyperthermia = new TemperatureInjury(
            TemperatureInjury.TemperatureInjuryType.Hyperthermia,
            "Heat exposure",
            null,
            severity);

        target.EffectRegistry.AddEffect(hyperthermia);
    }

    private void ApplySweating(Body target)
    {
        // Calculate severity based on temperature
        double severity = Math.Clamp((target.BodyTemperature - SweatingThreshold) / 4.0, 0.10, 1.00);

        // Apply to whole body (will handle stacking through EffectRegistry)
        var sweatingEffect = new SweatingEffect(severity);

        target.EffectRegistry.AddEffect(sweatingEffect);
    }

}================================================================================

File: ./Events/ExhaustionEvents.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Events;
public class ExhaustionEvent(Actor target, bool isNew) : IGameEvent
{
    public Actor Target = target;
    public bool IsNew = isNew;
}
public class ExhaustionEventHandler : IEventHandler<ExhaustionEvent>
{
    public void Handle(ExhaustionEvent gameEvent)
    {
        if (gameEvent.IsNew)
        {
            Output.WriteDanger($"{gameEvent.Target.Name} is exhausted!\n");
        }
        else if (Utils.DetermineSuccess(.1))
        {
            Output.WriteWarning($"{gameEvent.Target.Name} is still exhausted.\n");
        }
        var target = gameEvent.Target;
        var damage = new DamageInfo()
        {
            Amount = 1,
            Type = "exhaustion",
            IsPenetrating = true
        };
        target.Damage(damage);
    }
}

public class StoppedExhaustionEvent(Actor target) : IGameEvent
{
    public Actor Target = target;
}
public class StoppedExhaustionEventHandler : IEventHandler<StoppedExhaustionEvent>
{
    public void Handle(StoppedExhaustionEvent gameEvent)
    {
        Output.WriteSuccess($"{gameEvent.Target.Name} is no longer exhausted!\n");
    }
}================================================================================

File: ./Level/Skill.cs
--------------------------------------------------------------------------------
﻿

using text_survival.IO;

namespace text_survival.Level
{
    public class Skill
    {
        public int Xp;
        public int Level { get; private set; }
        public string Name { get; set; }
        public int LevelUpThreshold => (Level) * 10;

        public Skill(string name)
        {
            Name = name;
            Xp = 0;
            Level = 0;
        }
        public void GainExperience(int xp)
        {
            Xp += xp;

            if (Xp < LevelUpThreshold) return;
            // else level up
            Xp -= LevelUpThreshold;
            LevelUp();
        }

        public void LevelUp()
        {
            Level++;
            Output.WriteLine("You leveled up ", this, " to level ", Level, "!");
        }

        public override string ToString() => Name;

        public void Describe()
        {
            Output.Write(this, ": ", Level, " (", Xp, "/", LevelUpThreshold, ")");
        }



    }
}
================================================================================

File: ./Level/SkillRegistry.cs
--------------------------------------------------------------------------------
﻿
using text_survival.IO;

namespace text_survival.Level
{
    public class SkillRegistry
    {
        private readonly Dictionary<string, Skill> skills;

        public SkillRegistry(bool fullSkills = true)
        {
            skills = [];
            if (fullSkills)
            {
                skills.Add("Fighting", new Skill("Fighting"));
                skills.Add("Endurance", new Skill("Endurance"));
                skills.Add("Agility", new Skill("Reflexes"));
                skills.Add("Defense", new Skill("Defense"));
                
                skills.Add("Hunting", new Skill("Hunting"));
                skills.Add("Toolmaking", new Skill("Toolmaking"));
                skills.Add("Foraging", new Skill("Foraging"));
                skills.Add("Firecraft", new Skill("Firecraft"));
                skills.Add("Mending", new Skill("Mending"));
                skills.Add("Healing", new Skill("Healing"));
                skills.Add("Shamanism", new Skill("Shamanism"));
            }
            else
            {
                skills.Add("Melee", new Skill("Fighting"));
                skills.Add("Endurance", new Skill("Endurance"));
                skills.Add("Agility", new Skill("Reflexes"));
                skills.Add("Defense", new Skill("Defense"));
            }
        }

        public void AddExperience(string skillName, int xp)
        {
            if (skills.ContainsKey(skillName))
                skills[skillName].GainExperience(xp);
        }

        public int GetLevel(string skillName) => skills.TryGetValue(skillName, out Skill? value) ? value.Level : 1;

        public Skill? GetSkill(string skillName) => skills.TryGetValue(skillName, out Skill? value) ? value : null;

        public void Describe()
        {
            Output.WriteLine("\nSkills:");
            foreach (var skill in skills.Values)
            {
                if (skill.Level > 0)
                {
                    Output.WriteLine($"{skill.Name}: {skill.Level} ({skill.Xp}/{skill.LevelUpThreshold})");
                }
            }
        }
    }
}================================================================================

File: ./Level/Perk.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Level
{
    internal class Perk
    {
    }
}
================================================================================

File: ./PlayerComponents/LocationManger.cs
--------------------------------------------------------------------------------
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

class LocationManager
{
    public LocationManager(Location startingLocation)
    {
        Map = new WorldMap(startingLocation.Parent);
        _currentLocation = startingLocation;
    }
    private WorldMap Map { get; }
    public Location CurrentLocation
    {
        get
        {
            return _currentLocation;
        }
        set
        {
            Output.WriteLine("You go to the ", value);
            int minutes = Utils.RandInt(1, 10);
            World.Update(minutes);
            Output.WriteLine("You arrive at the ", value, " after walking ", minutes, " minutes.");
            _currentLocation = value;
            _currentLocation.Visited = true;
            Output.WriteLine("You should probably look around.");
        }
    }
    private Location _currentLocation;

    public Zone CurrentZone
    {
        get
        {
            return Map.CurrentZone;
        }
        set
        {
            if (CurrentZone == value)
            {
                Output.WriteLine("There's nowhere to leave. Travel instead.");
                return;
            }
            if (Map.North == value)
            {
                Output.WriteLine("You go north.");
                Map.MoveNorth();
            }
            else if (Map.East == value)
            {
                Output.WriteLine("You go east.");
                Map.MoveEast();
            }
            else if (Map.South == value)
            {
                Output.WriteLine("You go south.");
                Map.MoveSouth();
            }
            else if (Map.West == value)
            {
                Output.WriteLine("You go west.");
                Map.MoveWest();
            }
            else
                throw new Exception("Invalid zone.");
            Location? newLocation = Utils.GetRandomFromList(value.Locations);

            CurrentLocation = newLocation ?? throw new Exception("No Locations In Zone");
            Output.WriteLine("You enter ", value);
            Output.WriteLine(value.Description);
        }
    }

    public bool RemoveItemFromLocation(Item item)
    {
        if (_currentLocation.Items.Contains(item))
        {
            _currentLocation.Items.Remove(item);
            return true;
        }
        return false;
    }

    public void AddItemToLocation(Item item)
    {
        _currentLocation.Items.Add(item);
    }

    public void TravelToAdjacentZone()
    {
        Output.WriteLine("Where would you like to go?");

        Output.WriteLine(1, ". North: ", (Map.North.Visited ? Map.North.Name : " Unknown"));
        Output.WriteLine(2, ". East: ", (Map.East.Visited ? Map.East.Name : " Unknown"));
        Output.WriteLine(3, ". South: ", (Map.South.Visited ? Map.South.Name : " Unknown"));
        Output.WriteLine(4, ". West: ", (Map.West.Visited ? Map.West.Name : " Unknown"));

        Output.WriteLine("0. Cancel");
        int input = Input.ReadInt(0, 4);

        if (input == 0) return;

        int minutes = Utils.RandInt(30, 60);
        Output.WriteLine("You travel for ", minutes, " minutes...");

        switch (input)
        {
            case 1:
                CurrentZone = Map.North;
                break;
            case 2:
                CurrentZone = Map.East;
                break;
            case 3:
                CurrentZone = Map.South;
                break;
            case 4:
                CurrentZone = Map.West;
                break;
        }

        World.Update(minutes);
    }

}================================================================================

File: ./PlayerComponents/CombatManager.cs
--------------------------------------------------------------------------------
using System.Runtime;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;
public class CombatManager
{
    public CombatManager(Actor owner)
    {
        Owner = owner;
    }



    public double DetermineDamage()
    {
        // base weapon and skill
        double baseDamage = Owner.ActiveWeapon.Damage;
        double skillBonus = Owner._skillRegistry.GetLevel("Fighting");

        // modifiers
        double strengthModifier = (Owner.Body.CalculateStrength() / 2) + .5; // str determines up to 50%
        // A smaller health modifier up to 30%
        double healthModifier = 0.7 + (0.3 * (Owner.Body.Health / Owner.Body.MaxHealth));
        // todo factor in any effects like adrenaline, etc.
        // This could be expanded based on your EffectRegistry
        double effectsModifier = 1.0;
        double randomModifier = Utils.RandDouble(.5, 1.5);
        double totalModifier = strengthModifier * healthModifier * effectsModifier * randomModifier;

        double damage = (baseDamage + skillBonus) * totalModifier;
        return damage >= 0 ? damage : 0;
    }

    public double DetermineDodgeChance(Actor target)
    {
        double dodgeLevel = target._skillRegistry != null ? target._skillRegistry.GetLevel("Reflexes") : 0;
        double baseDodge = dodgeLevel / 100;
        double speedDiff = target.Body.CalculateSpeed() - Owner.Body.CalculateSpeed();
        double chance = baseDodge + speedDiff;
        // Output.WriteLine("Debug: Dodge Chance = ", chance);
        chance = Math.Clamp(chance, 0, .95);
        return chance;
    }

    public bool DetermineDodge(Actor target)
    {
        double dodgeChance = DetermineDodgeChance(target);
        if (Utils.DetermineSuccess(dodgeChance))
        {
            Output.WriteLine($"{Owner} dodged the attack!");
            return true;
        }
        return false;
    }

    public bool DetermineHit()
    {
        // Output.WriteLine("Debug: hit Chance: ", Owner.ActiveWeapon.Accuracy);
        double hitChance = Math.Clamp(Owner.ActiveWeapon.Accuracy, .01, .95);
        if (!Utils.DetermineSuccess(hitChance))
        {
            Output.WriteLine($"{Owner} missed!");
            return false;
        }
        return true;
    }

    public bool DetermineBlock(Actor target)
    {
        double blockLevel = target._skillRegistry != null ? target._skillRegistry.GetLevel("Defense") : 0;
        double skillBonus = blockLevel / 100;
        double attributeAvg = target.Body.CalculateStrength(); // todo 
        double blockAtbAvg = target.ActiveWeapon.BlockChance + attributeAvg / 2;
        double blockChance = blockAtbAvg + skillBonus;
        if (Utils.DetermineSuccess(blockChance))
        {
            Output.WriteLine($"{target} blocked the attack!");
            return true;
        }
        return false;
    }

    public void Attack(Actor target, string? targetedPart=null)
    {
        bool isDodged = DetermineDodge(target);
        if (isDodged)
        {
            // Use our narrator for rich descriptions
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, targetedPart ?? "body", false, true, false);
            Output.WriteLine(description);
            return;
        }

        bool isHit = DetermineHit();
        if (!isHit)
        {
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, targetedPart ?? "body", false, false, false);
            Output.WriteLine(description);
            return;
        }

        // Check for block
        bool isBlocked = DetermineBlock(target);
        if (isBlocked)
        {
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, targetedPart ?? "body", true, false, true);
            Output.WriteLine(description);
            return;
        }

        double damage = DetermineDamage();

        if (targetedPart != null)
        {
            AdjustAccuracyForTargeting(targetedPart);
        }

        // todo add util methods to determine blunt/sharp/pierce
        DamageInfo damageInfo = new(
            damage,
            source: Owner.Name,
            isSharp: Owner.ActiveWeapon.Class == WeaponClass.Blade || Owner.ActiveWeapon.Class == WeaponClass.Claw,
            isBlunt: Owner.ActiveWeapon.Class == WeaponClass.Blunt || Owner.ActiveWeapon.Class == WeaponClass.Unarmed,
            isPenetrating: Owner.ActiveWeapon.Class == WeaponClass.Pierce,
            accuracy: Owner.ActiveWeapon.Accuracy,
            targetPart: targetedPart
        );

        BodyPart? hitPart = target.Damage(damageInfo);

        double partHealthPercent = 0;
        string hitPartName = "";
        if (hitPart != null)
        {
            partHealthPercent = hitPart.Health / hitPart.MaxHealth;
            hitPartName = hitPart.Name;
        }
        string attackDescription = CombatNarrator.DescribeAttack(Owner, target, damage, hitPartName, true, false, false);
        Output.WriteLine(attackDescription);

        // Add part status if it's significantly damaged
        if (partHealthPercent < 0.9)
        {
            string statusDesc = CombatNarrator.DescribeTargetStatus(hitPartName, partHealthPercent);
            if (!string.IsNullOrEmpty(statusDesc))
            {
                Output.WriteLine(statusDesc);
            }
        }

        // Add weapon-specific effect descriptions
        if (Owner.ActiveWeapon.Class == WeaponClass.Blade && damage > 10)
        {
            Output.WriteLine("BloodW sprays from the wound!");
        }
        else if (Owner.ActiveWeapon.Class == WeaponClass.Blunt && damage > 12)
        {
            Output.WriteLine("You hear a sickening crack!");
        }
        else if (Owner.ActiveWeapon.Class == WeaponClass.Pierce && damage > 15)
        {
            Output.WriteLine("The attack pierces deep into the flesh!");
        }

        Owner._skillRegistry.AddExperience("Fighting", 1);
        Thread.Sleep(1000);
    }

    private double AdjustAccuracyForTargeting(string targetedPart)
    {
        return .8; // todo, for now slight penalty for targeting vs random swing
    }

    public Actor Owner { get; }
}
================================================================================

File: ./PlayerComponents/InventoryManager.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

public class InventoryManager
{
    public InventoryManager(EffectRegistry effectRegistry)
    {
        Armor = [];
        _unarmed = ItemFactory.MakeFists();
        Inventory = new Container("Bag", 10);
        _effectRegistry = effectRegistry;
    }
    private Container Inventory { get; }
    public List<Armor> Armor { get; }
    public Gear? HeldItem { get; private set; }
    private EffectRegistry _effectRegistry { get; }
    // weapon
    private Weapon? _weapon;
    private readonly Weapon _unarmed;
    public bool IsArmed => Weapon != _unarmed;
    public bool IsArmored => Armor.Count != 0;

    public Armor? GetArmorInSpot(EquipSpots spot) => Armor.FirstOrDefault(i => i.EquipSpot == spot);
    public Weapon Weapon
    {
        get => _weapon ?? _unarmed;
        set => _weapon = value;
    }

    public void AddToInventory(Item item)
    {
        Output.WriteLine("You put the ", item, " in your ", Inventory);
        Inventory.Add(item);
    }

    public void RemoveFromInventory(Item item)
    {
        Output.WriteLine("You take the ", item, " from your ", Inventory);
        Inventory.Remove(item);
    }

    public double ArmorRating
    {
        get
        {
            double rating = 0;
            foreach (Armor armor in Armor)
            {
                rating += armor.Rating;
                // rating += armor.Type switch
                // {
                //     ArmorClass.Light => Skills.LightArmor.Level * .01,
                //     ArmorClass.Heavy => Skills.HeavyArmor.Level * .01,
                //     _ => throw new ArgumentOutOfRangeException()
                // };
            }
            return rating;
        }
    }

    public double EquipmentWarmth => (HeldItem?.Warmth ?? 0) + Armor.Sum(a => a.Warmth);

    public void Equip(IEquippable item)
    {
        switch (item)
        {
            case Weapon weapon:
                Unequip(Weapon);
                Weapon = weapon;
                break;
            case Armor armor:
                var oldItem = Armor.FirstOrDefault(i => i.EquipSpot == armor.EquipSpot);
                if (oldItem != null) Unequip(oldItem);
                Armor.Add(armor);
                break;
            case Gear gear:
                if (HeldItem != null) Unequip(HeldItem);
                HeldItem = gear;
                break;
            default:
                Output.WriteLine("You can't equip that.");
                return;
        }
        Inventory.Remove((Item)item);
        item.EquipEffects.ForEach(_effectRegistry.AddEffect);
    }
    public void Unequip(IEquippable item)
    {
        if (item is not Gear gear) return;
        if (item == _unarmed) return;

        switch (gear)
        {
            case Weapon weapon:
                Weapon = _unarmed;
                break;
            case Armor armor:
                Armor.Remove(armor);
                break;
            case Gear g:
                HeldItem = null;
                break;
            default:
                Output.WriteLine("You can't unequip that.");
                return;
        }
        Output.WriteLine("You unequip ", gear);
        Inventory.Add(gear);
        gear.EquipEffects.ForEach(_effectRegistry.RemoveEffect);
    }
    public void CheckGear()
    {
        Describe.DescribeGear(this);
        Output.WriteLine("Would you like to unequip an item?");
        if (Input.ReadYesNo()) return;

        Output.WriteLine("Which item would you like to unequip?");
        // get list of all equipment
        var equipment = new List<IEquippable>();
        equipment.AddRange(Armor);
        if (IsArmed) equipment.Add(Weapon);
        if (HeldItem != null) equipment.Add(HeldItem);

        var choice = Input.GetSelectionFromList(equipment, true);
        if (choice == null) return;
        Unequip(choice);
    }

    public void Open(Player player)
    {
        while (!Inventory.IsEmpty)
        {
            Output.WriteLine(Inventory, " (", Inventory.Weight(), "/", Inventory.MaxWeight, "):");

            var options = ItemStack.CreateStacksFromItems(Inventory.Items);
            var selection = Input.GetSelectionFromList(options, true, "Close " + Inventory);
            if (selection == null) return;

            Item item = selection.Take();

            Output.WriteLine("What would you like to do with ", item);
            string? choice = Input.GetSelectionFromList(["Use", "Inspect", "Drop"], true);

            switch (choice)
            {
                case null:
                    continue;
                case "Use":
                    player.UseItem(item);
                    break;
                case "Inspect":
                    Describe.DescribeItem(item);
                    break;
                case "Drop":
                    player.DropItem(item);
                    break;
            }
        }
        Output.WriteLine(Inventory, " is empty.");
    }
}
================================================================================

File: ./PlayerComponents/SpellManager.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.IO;
using text_survival.Level;
using text_survival.Magic;

namespace text_survival.PlayerComponents;

class SpellManager
{
    public SpellManager(SkillRegistry skills)
    {
        _skills = skills;
        _spells.Add(SpellFactory.Bleeding);
        _spells.Add(SpellFactory.Poison);
        _spells.Add(SpellFactory.MinorHeal);
    }
    private readonly List<Spell> _spells = [];
    private readonly SkillRegistry _skills;
    public void SelectSpell(List<Actor> targets)
    {
        //get spell
        Output.WriteLine("Which spell would you like to cast?");
        var spell = Input.GetSelectionFromList(_spells, true);
        if (spell == null) return;

        // get target
        Output.WriteLine("Who would you like to cast ", spell.Name, " on?");
        var target = Input.GetSelectionFromList(targets, true);
        if (target == null) return;

        CastSpell(spell, target);
    }

    public void CastSpell(Spell spell, Actor target)
    {
        if (spell.NeedsTargetPart)
        {
            Output.WriteLine("Select a part to target:");
            var parts = target.Body.GetAllParts();
            var part = Input.GetSelectionFromList(parts)!;
            spell.Cast(target, part);
        }
        else
        {
            spell.Cast(target);
        }
        _skills.AddExperience("Shamanism", 2);
    }
}================================================================================

File: ./Effects/SweatEffect.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Effects;

public class SweatingEffect : Effect
{
    private double _waterLossRate; // Liters per hour

    public SweatingEffect(double severity)
        : base("Sweating", "Heat exposure", null, severity, -2) // Naturally decreases when not refreshed
    {
        // Water loss rate based on severity
        _waterLossRate = 0.05 * severity; // Liters per hour
        IsStackable = false; // Use EffectRegistry's stacking mechanism
    }

    protected override void OnApply(Actor target)
    {
        if (Severity > 0.7)
        {
            Output.WriteLine("You are sweating profusely.");
        }
        else if (Severity > 0.3)
        {
            Output.WriteLine("You are sweating.");
        }
        else
        {
            Output.WriteLine("You are beginning to sweat.");
        }
    }

    protected override void OnRemove(Actor target)
    {
        Output.WriteLine("You stop sweating.");
    }

    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update water loss rate when severity changes
        _waterLossRate = 0.05 * updatedSeverity;

        // Only notify player of significant changes
        if (Math.Abs(oldSeverity - updatedSeverity) > 0.3)
        {
            if (updatedSeverity > oldSeverity)
            {
                if (updatedSeverity > 0.7)
                {
                    Output.WriteLine("You are now sweating profusely.");
                }
                else
                {
                    Output.WriteLine("You are sweating more.");
                }
            }
            else if (updatedSeverity < 0.3)
            {
                Output.WriteLine("You are sweating less.");
            }
        }
    }

    protected override void OnUpdate(Actor target)
    {
        if (target is Player player)
        {
            double waterLoss = _waterLossRate / 1000 / 60; // convert to ml per minute
            var stats = new SurvivalStatsUpdate();
            stats.Hydration = -waterLoss;
            player.Body.UpdateSurvivalStats(stats);
            Output.WriteLine($"You lose {waterLoss:F2} ml of water due to sweating.");
        }
    }
    public override string Describe()
    {
        string intensityDesc;
        if (Severity > 0.7)
            intensityDesc = "Profuse";
        else if (Severity > 0.3)
            intensityDesc = "Moderate";
        else
            intensityDesc = "Mild";

        return $"{intensityDesc} sweating";
    }
}
================================================================================

File: ./Effects/ShiveringEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects;

public class ShiveringEffect : Effect
{
    private double _tempBoost;

    public ShiveringEffect(double severity)
        : base("Shivering", "Cold exposure", null, severity, -0.1) // Naturally decreases when not refreshed
    {
        // Calculate metabolism boost based on severity
        _tempBoost = severity * 0.2; // Up to 20% metabolism increase

        // Setup capacity modifiers - shivering affects fine motor control
        CapacityModifiers["Manipulation"] = -0.2 * severity;

        IsStackable = false; // Use EffectRegistry's stacking mechanism
    }

    protected override void OnUpdate(Actor target)
    {
        target.Body.BodyTemperature += _tempBoost; // Increase body temperature
    }

    protected override void OnApply(Actor target)
    {
        if (Severity > 0.7)
        {
            Output.WriteLine("You are shivering violently.");
        }
        else if (Severity > 0.3)
        {
            Output.WriteLine("You are shivering.");
        }
        else
        {
            Output.WriteLine("You are beginning to shiver.");
        }
    }

    protected override void OnRemove(Actor target)
    {
        Output.WriteLine("You stop shivering.");
    }

    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update metabolism boost when severity changes
        _tempBoost = updatedSeverity * 0.2;

        // Update capacity modifiers when severity changes
        CapacityModifiers["Manipulation"] = -0.2 * updatedSeverity;

        // Only notify player of significant changes
        if (Math.Abs(oldSeverity - updatedSeverity) > 0.3)
        {
            if (updatedSeverity > oldSeverity)
            {
                if (updatedSeverity > 0.7)
                {
                    Output.WriteLine("You are now shivering violently.");
                }
                else
                {
                    Output.WriteLine("You are shivering more intensely.");
                }
            }
            else if (updatedSeverity < 0.3)
            {
                Output.WriteLine("Your shivering is subsiding.");
            }
        }
    }

    public override string Describe()
    {
        string intensityDesc;
        if (Severity > 0.7)
            intensityDesc = "Violent";
        else if (Severity > 0.3)
            intensityDesc = "Moderate";
        else
            intensityDesc = "Mild";

        return $"{intensityDesc} shivering";
    }
}================================================================================

File: ./Effects/BleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects;

public class BleedEffect : Effect
{
    private float _damagePerHour;

    public BleedEffect(string source, BodyPart? targetPart, float severity, float damagePerHour, int durationMin = -1)
        : base("Bleeding", source, targetPart, severity)
    {
        _damagePerHour = damagePerHour;

        // Configure effect properties
        SeverityChangeRate = -0.05f; // Natural clotting
        IsStackable = true; // Multiple cuts can stack

        // Configure capacity modifiers
        CapacityModifiers["BloodPumping"] = 0.2f; // Reduces blood pumping capacity by 20%
        CapacityModifiers["Consciousness"] = 0.1f; // Minor consciousness impact
    }

    protected override void OnApply(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"{target}'s {location} is bleeding!");
    }

    protected override void OnUpdate(Actor target)
    {
        // Calculate damage for one minute based on severity
        double damage = _damagePerHour / 60.0 * Severity;

        // Apply damage to the specific body part
        var damageInfo = new DamageInfo
        {
            Amount = damage,
            Type = "bleed",
            Source = Source,
            IsPenetrating = true, // Bleeding damage always penetrates
            TargetPart = TargetBodyPart?.Name
        };

        target.Damage(damageInfo);

        // Occasionally remind player of bleeding
        if (Utils.DetermineSuccess(0.05f) && Severity > 0.3f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"Blood continues to flow from {target}'s {location}...");
        }
    }

    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        if (updatedSeverity < 0.2f && oldSeverity >= 0.2f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"The bleeding on {target}'s {location} is slowing.");
        }
    }

    protected override void OnRemove(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"The bleeding on {target}'s {location} has stopped.");
    }
}================================================================================

File: ./Effects/RemoveBleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects
{
    public class RemoveBleedEffect : Effect
    {
        public RemoveBleedEffect(string source, BodyPart? targetBodyPart) : base("RemoveBleed", source, targetBodyPart, severity: 1.0f)
        {
        }

        protected override void OnApply(Actor target)
        {
            var effects = target.GetEffectsByKind("bleed");
            if (effects.Count == 0)
            {
                effects = target.GetEffectsByKind("bleeding");
                if (effects.Count == 0)
                {
                    Output.WriteWarning("There was no bleeding to stop");
                    this.Remove(target);
                    return;
                }
            }
            var bleed = effects[0];
            bleed.Remove(target);
            Output.WriteLine(target, " stopped bleeding.");
            this.Remove(target);
        }
    }
}================================================================================

File: ./Effects/TempEffects.cs
--------------------------------------------------------------------------------
// Temperature injury effect class 
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects;

public class TemperatureInjury : Effect
{
    public enum TemperatureInjuryType
    {
        Burn,
        Frostbite,
        Hypothermia,
        Hyperthermia
    }

    public TemperatureInjuryType InjuryType { get; }

    // Store environment data to use in OnUpdate
    private double _environmentalTemperature;

    public TemperatureInjury(TemperatureInjuryType type, string source, BodyPart? bodyPart, double severity)
        : base(type.ToString(), source, bodyPart, severity, GetSeverityChangeRate(type))
    {
        InjuryType = type;
        RequiresTreatment = type == TemperatureInjuryType.Hypothermia || type == TemperatureInjuryType.Hyperthermia;

        ConfigureCapacityModifiers();
    }

    private static double GetSeverityChangeRate(TemperatureInjuryType type)
    {
        // Rate per hour, negative means healing
        return type switch
        {
            TemperatureInjuryType.Burn => -0.03,       // Heals slowly
            TemperatureInjuryType.Frostbite => -0.02,  // Heals very slowly
            TemperatureInjuryType.Hypothermia => -0.01, // Very slow recovery without treatment
            TemperatureInjuryType.Hyperthermia => -0.01, // Very slow recovery without treatment
            _ => -0.05
        };
    }

    protected override void OnUpdate(Actor target)
    {
        if (target is Player player)
        {
            // these effects shouldn't be on npcs yet 
            _environmentalTemperature = player.CurrentLocation.GetTemperature();
        }

        // Apply additional environmental effects to recovery rate
        // apply an additional base heal rate for every 20 degrees cooler/warmer per hour
        double bonusRecoveryPerDegreePerMinute = GetSeverityChangeRate(InjuryType) / 25.0 / 60.0; // should be negative
        if (bonusRecoveryPerDegreePerMinute < 0) // negative is healing
        {
            if (InjuryType == TemperatureInjuryType.Hypothermia && _environmentalTemperature > 65.0)
            {
                Output.WriteLine($"The heat is helping your {EffectKind} recover faster.");
                double recoveryBoost = (_environmentalTemperature - 65.0) * bonusRecoveryPerDegreePerMinute;
                UpdateSeverity(target, -recoveryBoost); // Negative to reduce severity
            }
            else if (InjuryType == TemperatureInjuryType.Hyperthermia && _environmentalTemperature < 70.0)
            {
                Output.WriteLine($"The cool is helping your {EffectKind} recover faster.");
                double recoveryBoost = (70.0 - _environmentalTemperature) * bonusRecoveryPerDegreePerMinute;
                UpdateSeverity(target, recoveryBoost); // Negative to reduce severity
            }
        }

        // Update capacity modifiers based on current severity
        ConfigureCapacityModifiers();
    }

    private void ConfigureCapacityModifiers()
    {
        CapacityModifiers.Clear();

        switch (InjuryType)
        {
            case TemperatureInjuryType.Burn:
                CapacityModifiers["Manipulation"] = -0.4 * Severity;
                CapacityModifiers["Moving"] = -0.1 * Severity;
                CapacityModifiers["BloodPumping"] = -0.1 * Severity; // Fluid loss
                break;

            case TemperatureInjuryType.Frostbite:
                CapacityModifiers["Manipulation"] = -0.5 * Severity;
                CapacityModifiers["Moving"] = -0.5 * Severity;
                CapacityModifiers["BloodPumping"] = -0.2 * Severity; // Reduced circulation
                break;

            case TemperatureInjuryType.Hypothermia:
                CapacityModifiers["Moving"] = -0.3 * Severity;
                CapacityModifiers["Manipulation"] = -0.3 * Severity;
                CapacityModifiers["Consciousness"] = -0.5 * Severity;
                CapacityModifiers["BloodPumping"] = -0.2 * Severity;
                break;

            case TemperatureInjuryType.Hyperthermia:
                CapacityModifiers["Consciousness"] = -0.5 * Severity;
                CapacityModifiers["Moving"] = -0.3 * Severity;
                CapacityModifiers["BloodPumping"] = -0.2 * Severity;
                CapacityModifiers["BloodFiltration"] = -0.2 * Severity; // Kidney strain
                break;
        }
    }

    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update capacity modifiers when severity changes
        ConfigureCapacityModifiers();

        // Notify of significant changes
        if (Math.Abs(oldSeverity - updatedSeverity) > 0.3)
        {
            string direction = updatedSeverity > oldSeverity ? "worsening" : "improving";

            string message = InjuryType switch
            {
                TemperatureInjuryType.Burn => $"Your burn is {direction}.",
                TemperatureInjuryType.Frostbite => $"Your frostbite is {direction}.",
                TemperatureInjuryType.Hypothermia => $"Your hypothermia is {direction}.",
                TemperatureInjuryType.Hyperthermia => $"Your hyperthermia is {direction}.",
                _ => $"Your {EffectKind} is {direction}."
            };

            if (direction == "worsening")
                Output.WriteWarning(message);
            else
                Output.WriteLine(message);
        }
    }

    protected override void OnApply(Actor target)
    {
        // Notify player of the injury
        string message = InjuryType switch
        {
            TemperatureInjuryType.Burn => "Your skin burns from the heat!",
            TemperatureInjuryType.Frostbite => "Your extremities are beginning to freeze!",
            TemperatureInjuryType.Hypothermia => "Your body temperature is dangerously low.",
            TemperatureInjuryType.Hyperthermia => "Your body temperature is dangerously high.",
            _ => $"You've suffered {EffectKind}, a temperature-related injury."
        };

        Output.WriteWarning(message);
    }

    protected override void OnRemove(Actor target)
    {
        string message = InjuryType switch
        {
            TemperatureInjuryType.Burn => "Your burn has healed.",
            TemperatureInjuryType.Frostbite => "Your frostbite has healed.",
            TemperatureInjuryType.Hypothermia => "Your body temperature has returned to normal.",
            TemperatureInjuryType.Hyperthermia => "Your body temperature has returned to normal.",
            _ => $"Your {EffectKind} has resolved."
        };

        Output.WriteLine(message);
    }

    public override string Describe()
    {
        string severityDesc = GetSeverityDescription();
        string locationDesc = TargetBodyPart != null ? $" on {TargetBodyPart.Name}" : "";

        return $"{severityDesc} {InjuryType}{locationDesc}";
    }
}================================================================================

File: ./Effects/HealEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;
public class HealEffect : Effect
{
    private float _healAmountPerHour;
    private string _targetPartName;

    public HealEffect(string source, BodyPart? targetPart, float healAmount, int durationMin = 60)
        : base("Healing", source, targetPart, 1.0f)
    {
        _healAmountPerHour = healAmount;
        _targetPartName = targetPart?.Name ?? "body";

        // Configure effect properties
        IsStackable = false; // Healing doesn't stack
        SeverityChangeRate = -1.0f / durationMin; // Decreases to 0 over duration
    }

    protected override void OnApply(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"{Source} begins healing {target}'s {location}.");
    }

    protected override void OnUpdate(Actor target)
    {
        // Calculate healing for one minute
        float healAmount = _healAmountPerHour / 60.0f;

        // Apply healing
        var healInfo = new HealingInfo
        {
            Amount = healAmount,
            Quality = 1.0,
            Source = Source,
            TargetPart = _targetPartName
        };

        target.Heal(healInfo);

        // Visual effect based on severity (how much healing is left)
        if (Utils.DetermineSuccess(0.05f))
        {
            string location = _targetPartName;
            if (Severity > 0.7f)
            {
                Output.WriteLine($"Fresh healing is occurring in {target}'s {location}.");
            }
            else if (Severity > 0.3f)
            {
                Output.WriteLine($"The healing in {target}'s {location} continues steadily.");
            }
            else
            {
                Output.WriteLine($"The healing in {target}'s {location} is nearly complete.");
            }
        }
    }

    protected override void OnRemove(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"The healing process on {target}'s {location} is complete.");
    }
}================================================================================

File: ./Effects/EffectRegistry.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;
public class EffectRegistry(Actor owner)
{
    public void AddEffect(Effect effect)
    {
        if (_effects.Contains(effect)) return;

        BodyPart? part = effect.TargetBodyPart;
        if (part != null)
        {
            if (!effect.IsStackable)
            {
                var existingEffect = _effects.FirstOrDefault(e => e.TargetBodyPart == part && e.EffectKind == effect.EffectKind);
                if (existingEffect != null)
                {
                    double newSeverity = Math.Max(existingEffect.Severity, effect.Severity);
                    existingEffect.UpdateSeverity(_owner, newSeverity);
                    return;
                }
            }
        }

        _effects.Add(effect);
        effect.Apply(_owner);
    }

    public void RemoveEffect(Effect effect)
    {
        if (_effects.Remove(effect))
        {
            effect.Remove(_owner);
        }
        else
        {
            Output.WriteWarning("ERROR: couldn't find effect to remove.");
        }
    }
    public void Update()
    {
        _effects.ForEach(e => e.Update(_owner));
        // Clean up inactive effects
        _effects.RemoveAll(e => !e.IsActive);
    }


    public double GetPartCapacityModifier(string capacity, BodyPart part) => GetEffectsOnBodyPart(part).Sum(e => e.CapacityModifiers.GetValueOrDefault(capacity) * e.Severity);
    public double GetBodyCapacityModifier(string capacity) => _effects.Where(e => e.TargetBodyPart == null).Sum(e => e.CapacityModifiers.GetValueOrDefault(capacity) * e.Severity);


    public List<Effect> GetEffectsOnBodyPart(BodyPart part) => [.. _effects.Where(e => e.TargetBodyPart == part)];
    public List<Effect> GetEffectsByKind(string kind) => [.. _effects.Where(e => e.EffectKind.Equals(kind, StringComparison.CurrentCultureIgnoreCase))];
    public void RemoveEffectsByKind(string kind)
    {
        var effectsToRemove = _effects.Where(e => e.EffectKind.Equals(kind, StringComparison.CurrentCultureIgnoreCase)).ToList();
        foreach (var effect in effectsToRemove)
        {
            RemoveEffect(effect);
        }
    }


    private readonly Actor _owner = owner;
    private List<Effect> _effects = [];
}================================================================================

File: ./Effects/PoisonEffect.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

public class PoisonEffect : Effect
{
    private float _damagePerHour;
    private string _poisonType;
    
    public PoisonEffect(string poisonType, string source, float severity, float damagePerHour, int durationMin = 60)
        : base("Poison", source, null, severity) // Poison is typically whole-body
    {
        _damagePerHour = damagePerHour;
        _poisonType = poisonType;
        
        // Configure effect properties
        SeverityChangeRate = -0.02f; // Slow natural detoxification
        IsStackable = true; // Multiple poison sources can stack
        
        // Configure capacity modifiers - affect whole body
        CapacityModifiers["Consciousness"] = 0.3f * severity;
        CapacityModifiers["Manipulation"] = 0.2f * severity;
        CapacityModifiers["Moving"] = 0.2f * severity;
        CapacityModifiers["BloodFiltration"] = 0.4f * severity;
    }
    
    protected override void OnApply(Actor target)
    {
        Output.WriteLine($"{target} has been poisoned with {_poisonType}!");
    }
    
    protected override void OnUpdate(Actor target)
    {
        // Calculate damage for one minute based on severity
        double damage = _damagePerHour / 60.0 * Severity;
        
        // Apply poison damage randomly to internal organs
        // Get list of internal parts
        var internalParts = target.Body.GetAllParts()
            .Where(p => p.IsInternal && !p.IsDestroyed)
            .ToList();
            
        if (internalParts.Count > 0)
        {
            // Target a random internal organ for damage
            var targetPart = internalParts[Utils.RandInt(0, internalParts.Count - 1)];
            
            var damageInfo = new DamageInfo
            {
                Amount = damage,
                Type = "poison",
                Source = Source,
                IsPenetrating = true, // Poison always penetrates
                TargetPart = targetPart.Name
            };
            
            target.Damage(damageInfo);
        }
        else
        {
            // Fallback to general damage
            var damageInfo = new DamageInfo
            {
                Amount = damage,
                Type = "poison",
                Source = Source,
                IsPenetrating = true
            };
            
            target.Damage(damageInfo);
        }
        
        // Symptoms based on severity
        if (Severity > 0.7 && Utils.DetermineSuccess(0.2))
        {
            Output.WriteLine($"{target} vomits violently from the {_poisonType} poisoning.");
        }
        else if (Severity > 0.4f && Utils.DetermineSuccess(0.1))
        {
            Output.WriteLine($"{target} trembles from the effects of the {_poisonType} poison.");
        }
    }
    
    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update capacity modifiers based on new severity
        CapacityModifiers["Consciousness"] = 0.3 * updatedSeverity;
        CapacityModifiers["Manipulation"] = 0.2 * updatedSeverity;
        CapacityModifiers["Moving"] = 0.2 * updatedSeverity;
        
        if (updatedSeverity < 0.3 && oldSeverity >= 0.3)
        {
            Output.WriteLine($"The {_poisonType} poisoning is becoming less severe.");
        }
    }
    
    protected override void OnRemove(Actor target)
    {
        Output.WriteLine($"{target} has recovered from {_poisonType} poisoning.");
    }
}================================================================================

File: ./Effects/Effect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects
{
    // public interface IEffect
    // {
    //     string EffectType { get; }
    //     bool IsActive { get; }
    //     // float Severity { get; }
    //     // int DurationMin { get; } // Total duration in minutes
    //     // int RemainingDurationMin { get; } // Remaining duration in minutes

    //     void Apply(IActor target);
    //     void Update(IActor target);
    //     void Remove(IActor target);
    // }

    public abstract class Effect
    {
        protected Effect(string effectKind, string source, BodyPart? targetBodyPart = null, double severity = 1, double severityChangeRate = 0)
        {
            EffectKind = effectKind;
            Source = source;
            TargetBodyPart = targetBodyPart;
            Severity = severity;
            SeverityChangeRate = severityChangeRate;

            IsActive = true;
            IsStackable = false;
            RequiresTreatment = false;
        }

        public string EffectKind { get; protected set; }
        public string Source { get; } // what caused this effect (e.g., cold, wound poison)
        public BodyPart? TargetBodyPart { get; set; }
        public bool IsStackable { get; protected set; }
        public bool IsActive { get; protected set; }
        public double Severity { get; protected set; }
        public double SeverityChangeRate { get; protected set; } // per severity reduction per hour
        public bool RequiresTreatment { get; protected set; }
        public Dictionary<string, double> CapacityModifiers { get; } = [];
        // public List<TreatmentOption> TreatmentOptions {get;}

        // main algorithm methods - typically don't override
        public void Apply(Actor target)
        {
            IsActive = true;
            OnApply(target);
        }

        public void Update(Actor target)
        {
            if (!IsActive) return;

            OnUpdate(target);
            
            if (!RequiresTreatment && SeverityChangeRate > 0)
            {
                double minuteChange = SeverityChangeRate / 60;
                UpdateSeverity(target, minuteChange);
            }

            if (Severity <= 0)
            {
                Remove(target);
                return;
            }
        }
        public void Remove(Actor target)
        {
            if (!IsActive) return;
            OnRemove(target);
            IsActive = false;
        }
        public virtual void UpdateSeverity(Actor target, double severityChange)
        {
            if (!IsActive) return;

            double oldSeverity = Severity;

            Severity = Math.Clamp(Severity + severityChange, 0, 1);

            if (Math.Abs(oldSeverity - Severity) > 0.01)
            {
                OnSeverityChange(target, oldSeverity, Severity);
            }
        }


        // hook methods that can be implemented by sub classes
        protected virtual void OnApply(Actor target) { }
        protected virtual void OnUpdate(Actor target) { }
        protected virtual void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity) { }
        protected virtual void OnRemove(Actor target) { }


        // UI methods
        public string GetSeverityDescription()
        {
            if (Severity < 0.3f) return "Minor";
            if (Severity < 0.7f) return "Moderate";
            if (Severity < 0.9f) return "Severe";
            return "Critical";
        }
        public virtual string Describe()
        {
            string severityDesc = GetSeverityDescription();
            string locationDesc = TargetBodyPart != null ? $" on {TargetBodyPart.Name}" : "";
            return $"{severityDesc} {EffectKind}{locationDesc}";
        }
    }
}================================================================================

File: ./Command.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public interface ICommand
    {
        public string Name { get; set; }
        public void Execute();
    }

    public class Command<TPlayer> : ICommand
    {
        public string Name { get; set; }
        public Action<TPlayer> Act { get; set; }
        public TPlayer? Player { get; set; }

        public Command(string name, Action<TPlayer> act)
        {
            Name = name;
            Act = act;
        }

        public void Execute()
        {
            if (Player == null)
            {
                throw new Exception("Player is null");
            }
            Act.Invoke(Player);
        }

        public override string ToString() => Name;
    }
}
================================================================================

File: ./Bodies/BodyPart.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Bodies;

public class BodyPart
{
    // Core properties
    public string Name { get; }
    public double Health { get; private set; }
    public double MaxHealth { get; }
    public bool IsVital { get; }
    public bool IsInternal { get; }
    public bool IsDamaged => Health < MaxHealth;
    public bool IsDestroyed => Health <= 0;

    public double Coverage { get; set; } // Percentage of parent this part covers
    public double EffectiveCoverage { get; private set; }

    // Hierarchy
    public BodyPart? Parent { get; private set; }
    private List<BodyPart> _parts = new();
    public IReadOnlyList<BodyPart> Parts => _parts.AsReadOnly();

    // Physical state
    private Dictionary<string, double> _baseCapacities = new();

    public BodyPart(string name, double maxHealth, bool isVital, bool isInternal, double coverage)
    {
        Name = name;
        MaxHealth = maxHealth;
        Health = maxHealth;
        IsVital = isVital;
        IsInternal = isInternal;
        Coverage = coverage;
        _baseCapacities = new Dictionary<string, double>();
    }

    // Capacity management
    public void SetBaseCapacity(string capacity, double value)
    {
        _baseCapacities[capacity] = value;
    }

    public double GetCapacity(string capacity)
    {
        if (!_baseCapacities.TryGetValue(capacity, out double baseValue))
        {
            return 0;
        }

        // Apply health scaling
        return baseValue * (Health / MaxHealth);
    }

    public IReadOnlyDictionary<string, double> GetCapacities()
    {
        var result = new Dictionary<string, double>();
        foreach (var pair in _baseCapacities)
        {
            result[pair.Key] = GetCapacity(pair.Key);
        }
        return result;
    }


    // Hierarchical structure
    public void AddPart(BodyPart part)
    {
        part.Parent = this;
        _parts.Add(part);
    }

    public void Heal(HealingInfo healingInfo)
    {
        if (IsDestroyed) return;

        // Handle targeted healing
        if (healingInfo.TargetPart != null && healingInfo.TargetPart != Name)
        {
            // Try to find the targeted part
            var targetPart = FindPartByName(healingInfo.TargetPart);
            if (targetPart != null)
            {
                targetPart.Heal(healingInfo);
                return;
            }
        }

        // Distribute healing
        if (_parts.Count > 0 && healingInfo.TargetPart == null)
        {
            // Prioritize damaged parts for healing
            var damagedParts = _parts.Where(p => p.IsDamaged).ToList();
            if (damagedParts.Count > 0)
            {
                damagedParts[Utils.RandInt(0, damagedParts.Count - 1)].Heal(healingInfo);
                return;
            }

            // Random distribution if no parts are damaged
            if (Utils.FlipCoin())
            {
                BodyPart p = _parts[Utils.RandInt(0, _parts.Count - 1)];
                p.Heal(healingInfo);
                return;
            }
        }

        // Apply healing to this part
        double adjustedAmount = healingInfo.Amount * healingInfo.Quality;
        Health += adjustedAmount;
        if (Health > MaxHealth)
        {
            Health = MaxHealth;
        }
    }

    public void CalculateEffectiveCoverage()
    {
        if (Parent == null)
        {
            EffectiveCoverage = 1.0; // Root part has 100% chance
            return;
        }

        // My coverage of parent × parent's effective coverage
        EffectiveCoverage = (Coverage / 100.0) * Parent.EffectiveCoverage;

        // Calculate for all children
        foreach (var part in _parts)
        {
            part.CalculateEffectiveCoverage();
        }
    }

    public BodyPart? Damage(DamageInfo damageInfo)
    {
        if (IsDestroyed) return null;

        if (damageInfo.TargetPart == null)
        {
            // Standard untargeted damage
            return DamageUntargeted(damageInfo);
        }

        // Handle targeted damage - but still allow for sub-part hits
        if (damageInfo.TargetPart == Name)
        {
            if (_parts.Count == 0)
            {
                ApplyDamage(damageInfo);
                return this;
            }


            if (Utils.DetermineSuccess(damageInfo.Accuracy))
            {
                // Direct hit on the targeted part
                ApplyDamage(damageInfo);
                return this;
            }

            // Even when targeting, there's a chance to hit sub-parts
            // Higher accuracy for targeted hits - use 75% of normal child coverage
            var partChances = new Dictionary<BodyPart, double>();
            double totalChildCoverage = 0;

            foreach (var part in _parts)
            {
                // Reduce child coverage to make it more likely to hit the targeted part
                double adjustedCoverage = part.Coverage * 0.75;
                partChances[part] = adjustedCoverage;
                totalChildCoverage += adjustedCoverage;
            }

            // Add self with remaining coverage - more likely than with random hits
            double selfCoverage = 100 - totalChildCoverage;
            partChances[this] = selfCoverage;

            BodyPart hit = Utils.GetRandomWeighted(partChances);
            if (hit == this)
            {
                ApplyDamage(damageInfo);
                return this;
            }
            else
            {
                // When hitting a child on a targeted attack, we should
                // propagate that this was intentional targeting
                damageInfo.TargetPart = hit.Name; // Update target to child part
                damageInfo.Accuracy *= 0.8; // Reduce accuracy for child hit
                return hit.Damage(damageInfo);

            }
        }
        else // Handle targeted damage for a different part (searching)
        {
            // Look for the targeted part among children
            var targetedPart = FindPartByName(damageInfo.TargetPart);

            if (targetedPart != null && Utils.DetermineSuccess(damageInfo.Accuracy)) // chance to miss based on accuracy
            {
                // Found the part - propagate damage to it
                return targetedPart.Damage(damageInfo);
            }

            // Target not found as a descendant - try to hit this part instead
            // But with reduced damage since the intended target was missed
            damageInfo.Amount = damageInfo.Amount * 0.7; // Reduced damage for missing intended target
            damageInfo.TargetPart = null; // Clear targeting since we're defaulting

            // Process as untargeted hit
            return DamageUntargeted(damageInfo);
        }
    }

    // Separate method for untargeted damage distribution
    private BodyPart? DamageUntargeted(DamageInfo damageInfo)
    {
        // Distribute damage based on coverage
        if (_parts.Count > 0)
        {
            // Get all parts with their coverage values
            var partChances = new Dictionary<BodyPart, double>();
            double totalChildCoverage = 0;

            foreach (var part in _parts)
            {
                partChances[part] = part.Coverage;
                totalChildCoverage += part.Coverage;
            }

            // Add self with remaining coverage
            double selfCoverage = 100 - totalChildCoverage;
            partChances[this] = selfCoverage;

            BodyPart hit = Utils.GetRandomWeighted(partChances);
            if (hit == this)
            {
                ApplyDamage(damageInfo);
                return this;
            }
            else
            {
                return hit.Damage(damageInfo);
            }

        }

        // Default if no children or calculation issue
        ApplyDamage(damageInfo);
        return this;
    }

    // Helper method to find a part by name in the hierarchy
    private BodyPart? FindPartByName(string partName)
    {
        if (Name == partName) return this;

        foreach (var part in _parts)
        {
            var foundPart = part.FindPartByName(partName);
            if (foundPart != null) return foundPart;
        }

        return null;
    }

    // Method to actually apply damage
    private void ApplyDamage(DamageInfo damageInfo)
    {
        // Apply damage reduction for internal parts if damage is not penetrating
        double damageAmount = damageInfo.Amount;
        if (IsInternal && !damageInfo.IsPenetrating)
        {
            damageAmount *= 0.5; // 50% damage reduction for internal parts
        }

        Health -= damageAmount;
        // Output.WriteLine(this, " took ", damageAmount, " damage");
        // Handle destruction
        if (IsDestroyed)
        {
            Health = 0;
            if (IsVital && Parent != null)
            {
                var criticalDamage = new DamageInfo
                {
                    Amount = Parent.MaxHealth * 0.5,
                    Type = "critical",
                    Source = damageInfo.Source,
                    IsPenetrating = true // Critical damage always penetrates
                };
                Parent.Damage(criticalDamage);
            }
        }
    }

    public void Describe()
    {
        // Calculate health percentage
        int healthPercent = (int)((Health / MaxHealth) * 100);

        // Determine damage severity description
        string damageDescription;
        if (healthPercent <= 0)
        {
            damageDescription = "destroyed";
        }
        else if (healthPercent < 20)
        {
            damageDescription = "critically damaged";
        }
        else if (healthPercent < 40)
        {
            damageDescription = "severely damaged";
        }
        else if (healthPercent < 60)
        {
            damageDescription = "moderately damaged";
        }
        else if (healthPercent < 80)
        {
            damageDescription = "lightly damaged";
        }
        else if (healthPercent < 100)
        {
            damageDescription = "slightly damaged";
        }
        else
        {
            damageDescription = "in perfect condition";
        }

        // Output description line
        Output.WriteLine($"- {Name} is {damageDescription} ({healthPercent}%)");
    }
    public override string ToString() => Name;
}================================================================================

File: ./Bodies/Body.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;
using text_survival.Survival;

namespace text_survival.Bodies;

public class BodyStats
{
    public BodyPartFactory.BodyTypes type;
    public double overallWeight;
    public double fatPercent;
    public double musclePercent;
}

public class Body
{
    // Root part and core properties
    private readonly BodyPart _rootPart;
    public double Health => _rootPart.Health;
    public double MaxHealth => _rootPart.MaxHealth;
    public bool IsDestroyed => _rootPart.IsDestroyed;

    public readonly EffectRegistry EffectRegistry;
    private readonly HungerModule _hungerModule;
    private readonly ThirstModule _thirstModule;
    private readonly ExhaustionModule _exhaustionModule;
    private readonly TemperatureModule _temperatureModule;

    // Physical composition
    private double _bodyFat;
    private double _muscle;
    private readonly double _baseWeight;

    public Body(string ownerName, BodyStats stats, EffectRegistry effectRegistry)
    {
        OwnerName = ownerName;
        EffectRegistry = effectRegistry;
        _rootPart = BodyPartFactory.CreateBody(stats.type, stats.overallWeight);
        _hungerModule = new HungerModule(this);
        _thirstModule = new ThirstModule();
        _exhaustionModule = new ExhaustionModule();
        _temperatureModule = new TemperatureModule(this);

        // Initialize physical composition
        _bodyFat = stats.overallWeight * stats.fatPercent;
        _muscle = stats.overallWeight * stats.musclePercent;
        _baseWeight = stats.overallWeight - _bodyFat - _muscle;
    }


    // Physical composition properties
    public double BodyFat
    {
        get => _bodyFat;
        set
        {
            _bodyFat = Math.Max(value, 0);
        }
    }

    public double Muscle
    {
        get => _muscle;
        set
        {
            _muscle = Math.Max(value, 0);
        }
    }

    public readonly string OwnerName;
    public double BodyFatPercentage => _bodyFat / Weight;
    public double MusclePercentage => _muscle / Weight;
    public double Weight => _baseWeight + _bodyFat + _muscle;

    public double BodyTemperature { get; set; }

    // Forwarding methods to root part
    public BodyPart? Damage(DamageInfo damageInfo) => _rootPart.Damage(damageInfo);
    public void Heal(HealingInfo healingInfo) => _rootPart.Heal(healingInfo);

    private void UpdateMetabolism(TimeSpan timePassed, double activityLevel)
    {
        // Base BMR uses the Harris-Benedict equation (simplified)
        double bmr = 370 + (21.6 * Muscle) + (6.17 * BodyFat);

        // Adjust for injuries and conditions
        double healthFactor = Health / MaxHealth;
        bmr *= 0.7 + (0.3 * healthFactor); // Injured bodies need more energy to heal

        double currentMetabolism = bmr * activityLevel;
        double calories = currentMetabolism / 24 * timePassed.TotalHours;
        BodyTemperature += calories / 24000;
        _hungerModule.Update(currentMetabolism);
    }

    public void Update(TimeSpan timePassed)
    {
        // Handle metabolism and energy expenditure
        UpdateMetabolism(timePassed, 2);

    }

    // todo - move this to the survival manager or something

    // Calculate derived attributes
    public double CalculateStrength()
    {
        double manipulationCapacity = GetCapacity("Manipulation");
        double bloodPumping = GetCapacity("BloodPumping"); // Energy delivery

        // Base strength that everyone has
        double baseStrength = 0.30; // 30% strength from structural aspects

        // Muscle contribution with diminishing returns
        double muscleContribution;
        if (MusclePercentage < 0.2) // Below normal
            muscleContribution = MusclePercentage * 2.5; // Rapid gains when building from low muscle
        else if (MusclePercentage < 0.4) // Normal to athletic
            muscleContribution = 0.5 + (MusclePercentage - 0.2) * 1.0; // Moderate gains
        else // Athletic+
            muscleContribution = 0.7 + (MusclePercentage - 0.4) * 0.5; // Diminishing returns

        // Energy state affects strength expression
        double energyFactor = Math.Min(bloodPumping, 1.0);

        // Very low body fat impairs strength
        double fatPenalty = (BodyFatPercentage < 0.05) ? (0.05 - BodyFatPercentage) * 3.0 : 0;

        return manipulationCapacity * (baseStrength + muscleContribution * energyFactor - fatPenalty);
    }

    public double CalculateSpeed()
    {
        double movingCapacity = GetCapacity("Moving");
        double structuralWeightRatio = (_baseWeight / Weight) + (1 - 0.45); // avg 45% structure weight
        double sizeRatio = Weight / BaseLineHumanStats.overallWeight;

        double muscleBonus = Math.Min(MusclePercentage * 0.20, 0); // Up to 20% bonus from muscle

        double fatPenalty;
        // Minimal fat has no penalty, excess has increasing penalties
        if (BodyFatPercentage < 0.10)
        {
            // 10% is minimal necessary fat
            fatPenalty = -.01; // negative penalty if under 10% bf
        }
        else if (BodyFatPercentage <= BaseLineHumanStats.fatPercent)
        {
            fatPenalty = ((BodyFatPercentage - .10) * .20) - .01; // at baseline a 0% penalty
        }
        else
        {
            // Steeper penalty for excess, 1.5% reduction per 1% of fat 
            // 1.5(fat% - baselineFat%)
            // fat% => speed penalty (abs)
            // 20%  =>  8.5%, 
            // 30%  => 23.5%
            // 40%  => 38.5%
            // 50%  => 53.5%
            fatPenalty = (BodyFatPercentage - BaseLineHumanStats.fatPercent) * 1.5;
        }

        // Penalty for excess weight relative to frame
        // -(ratio^.7 - 1)
        // ratio => penalty (abs)
        // 0.1   => +0.80
        // 0.5   => +0.38
        // 0.9   => +0.07
        // 1.5   => -0.33
        // 3.0   => -1.16
        double weightEffect = -(Math.Pow(structuralWeightRatio, 0.7) - 1.0);

        // smaller creatures are faster and larger ones are slower
        // 1 - .1(Log2(sizeRatio))
        // ratio => speed (multiplier)
        // 0.1   => 1.33  
        // 0.5   => 1.10   - 1/2 size means 10% faster
        // 2.0   => 0.90  - 10% slower
        // 10.   => 0.66  - 1/3 slower
        // 50    => 0.44
        double speedSizeModifier = 1 - 0.1 * Math.Log(sizeRatio, 2);

        return movingCapacity * (1 + muscleBonus - fatPenalty + weightEffect) * speedSizeModifier;
    }
    public double CalculateVitality()
    {
        double breathing = GetCapacity("Breathing");
        double bloodPumping = GetCapacity("BloodPumping");
        double digestion = GetCapacity("Digestion");

        double organFunction = (2 * (breathing + bloodPumping) + digestion) / 5;

        // Base vitality that scales more gently with body composition
        double baseMultiplier = 0.7;  // Everyone gets 70% baseline
        double muscleContribution = MusclePercentage * 0.25;  // Up to 25% from muscle
        double fatContribution;

        // Essential fat is beneficial, excess isn't
        if (BodyFatPercentage < .10)
            fatContribution = BodyFatPercentage * 0.5;  // Fat is very important when low
        else if (BodyFatPercentage < .25)
            fatContribution = 0.05;  // Optimal fat gives 5%
        else
            fatContribution = 0.05 - (BodyFatPercentage - .25) * 0.1;  // Excess fat penalizes slightly

        double bodyComposition = baseMultiplier + muscleContribution + fatContribution;
        return organFunction * bodyComposition;
    }

    public double CalculatePerception()
    {
        double sight = GetCapacity("Sight");
        double hearing = GetCapacity("Hearing");

        return (sight + hearing) / 2;
    }

    public double CalculateColdResistance()
    {
        // Base cold resistance that everyone has
        double baseColdResistance = 0.5;
        double fatInsulation;

        if (BodyFatPercentage < 0.05)
            fatInsulation = (BodyFatPercentage / 0.05) * 0.1;  // Linear up to 5%
        else if (BodyFatPercentage < 0.15)
            fatInsulation = 0.1 + ((BodyFatPercentage - 0.05) / 0.1) * 0.15;  // From 0.1 to 0.25
        else
            fatInsulation = 0.25 + ((BodyFatPercentage - 0.15)) * 0.15;  // Diminishing returns after 15%

        return baseColdResistance + fatInsulation;
    }


    private double GetCapacity(string capacity)
    {
        var parts = GetAllParts().Where(p => p.GetCapacity(capacity) > 0);
        var values = parts.Select(p => GetEffectivePartCapacity(p, capacity)).ToList();
        if (values.Sum() <= 0) return 0;

        double result;
        // todo, see if I want to revisit the special logic here
        // if (capacity is "Moving" or "Manipulation" or "Breathing" or "Consciousness"
        // or "BloodPumping" or "Digestion" or "Eating" or "Talking")
        // {
        // }
        // else if (capacity is "Sight" or "Hearing" or "BloodFiltration")
        // {
        //     result = values.Average();
        // }
        // else
        // {
        //     result = values.Min();
        // }
        result = Math.Min(1, values.Sum());
        double bodyModifier = EffectRegistry.GetBodyCapacityModifier(capacity);
        result *= (1 + bodyModifier);
        result = Math.Max(0, result);
        return result;
    }

    private double GetEffectivePartCapacity(BodyPart part, string capacityName)
    {
        if (part.IsDestroyed) return 0;

        // Get base capacity (already includes health scaling)
        double baseCapacity = part.GetCapacity(capacityName);
        if (baseCapacity <= 0) return 0;

        // Apply effect modifiers for this part
        double modifier = EffectRegistry.GetPartCapacityModifier(capacityName, part);
        return Math.Max(0, baseCapacity * (1.0 + modifier));
    }


    // Helper to get all body parts
    public List<BodyPart> GetAllParts()
    {
        var result = new List<BodyPart>();
        CollectBodyParts(_rootPart, result);
        return result;
    }

    private void CollectBodyParts(BodyPart part, List<BodyPart> result)
    {
        result.Add(part);
        foreach (var child in part.Parts)
        {
            CollectBodyParts(child, result);
        }
    }

    public List<BodyPart>? GetPartsToNDepth(int depth)
    {
        if (depth <= 0) return null;

        var result = new List<BodyPart>();
        CollectBodyPartsToDepth(_rootPart, result, 1, depth);
        return result;
    }

    private void CollectBodyPartsToDepth(BodyPart part, List<BodyPart> result, int currentDepth, int maxDepth)
    {
        // Add the current part
        result.Add(part);

        // If we've reached our depth limit or there are no children, return
        if (currentDepth >= maxDepth || part.Parts.Count == 0)
            return;

        // Otherwise, recursively add children
        foreach (var child in part.Parts)
        {
            CollectBodyPartsToDepth(child, result, currentDepth + 1, maxDepth);
        }
    }

    // helper for baseline male human stats
    public static BodyStats BaseLineHumanStats = new BodyStats
    {
        type = BodyPartFactory.BodyTypes.Human,
        overallWeight = 75, // KG ~165 lbs
        fatPercent = .15, // pretty lean
        musclePercent = .40 // low end of athletic
    };

    public void Describe()
    {
        // Overall body statistics
        Output.WriteLine("Body Health: " + (int)((Health / MaxHealth) * 100) + "%");
        Output.WriteLine("Weight: " + Math.Round(Weight * 2.2, 1) + " lbs");
        Output.WriteLine("Body Composition: " + (int)(BodyFatPercentage * 100) + "% fat, " + (int)(MusclePercentage * 100) + "% muscle");

        // Physical capabilities
        Output.WriteLine("\nPhysical Capabilities:");
        Output.WriteLine("- Strength: " + Math.Round(CalculateStrength() * 100) + "%");
        Output.WriteLine("- Speed: " + Math.Round(CalculateSpeed() * 100) + "%");
        Output.WriteLine("- Vitality: " + Math.Round(CalculateVitality() * 100) + "%");
        Output.WriteLine("- Perception: " + Math.Round(CalculatePerception() * 100) + "%");
        Output.WriteLine("- Cold Resistance: " + Math.Round(CalculateColdResistance() * 100) + "%");

        // Display damaged body parts
        List<BodyPart> allParts = GetAllParts();
        List<BodyPart> damagedParts = allParts.Where(p => p.Health < p.MaxHealth && !p.IsDestroyed).ToList();
        List<BodyPart> destroyedParts = allParts.Where(p => p.IsDestroyed).ToList();

        if (damagedParts.Count > 0 || destroyedParts.Count > 0)
        {
            Output.WriteLine("\nInjuries:");

            // Show damaged parts
            foreach (var part in damagedParts)
            {
                part.Describe();
            }

            // Show destroyed parts
            foreach (var part in destroyedParts)
            {
                Output.WriteLine($"- {part.Name} is destroyed!");
            }
        }
        else
        {
            Output.WriteLine("\nNo injuries detected.");
        }

        // Check for any body system impairments
        Dictionary<string, double> systemCapacities = new Dictionary<string, double>
    {
        { "Moving", GetCapacity("Moving") },
        { "Manipulation", GetCapacity("Manipulation") },
        { "Breathing", GetCapacity("Breathing") },
        { "BloodPumping", GetCapacity("BloodPumping") },
        { "Consciousness", GetCapacity("Consciousness") },
        { "Sight", GetCapacity("Sight") },
        { "Hearing", GetCapacity("Hearing") },
        { "Digestion", GetCapacity("Digestion") }
    };

        var impairedSystems = systemCapacities.Where(kv => kv.Value < 0.9).ToList();

        if (impairedSystems.Count > 0)
        {
            Output.WriteLine("\nSystem Impairments:");
            foreach (var system in impairedSystems)
            {
                string severity = GetImpairmentSeverity(system.Value);
                Output.WriteLine($"- {system.Key}: {severity} ({(int)(system.Value * 100)}% efficiency)");
            }
        }
    }

    // Helper method to check and describe system impairments
    private void CheckAndDescribeImpairments()
    {
        Dictionary<string, double> systemCapacities = new Dictionary<string, double>
    {
        { "Moving", GetCapacity("Moving") },
        { "Manipulation", GetCapacity("Manipulation") },
        { "Breathing", GetCapacity("Breathing") },
        { "BloodPumping", GetCapacity("BloodPumping") },
        { "Consciousness", GetCapacity("Consciousness") },
        { "Sight", GetCapacity("Sight") },
        { "Hearing", GetCapacity("Hearing") },
        { "Digestion", GetCapacity("Digestion") }
    };

        var impairedSystems = systemCapacities.Where(kv => kv.Value < 0.9).ToList();

        if (impairedSystems.Count > 0)
        {
            Output.WriteLine("\nSystem Impairments:");
            foreach (var system in impairedSystems)
            {
                string severity = GetImpairmentSeverity(system.Value);
                Output.WriteLine($"- {system.Key}: {severity} ({(int)(system.Value * 100)}% efficiency)");
            }
        }
    }

    // Helper method to determine impairment severity description
    private string GetImpairmentSeverity(double capacity)
    {
        return capacity switch
        {
            < 0.25 => "Critical impairment",
            < 0.5 => "Severe impairment",
            < 0.75 => "Moderate impairment",
            < 0.9 => "Minor impairment",
            _ => "Normal"
        };
    }

    public void DescribeSurvivalStats()
    {
        _hungerModule.Describe();
        _thirstModule.Describe();
        _exhaustionModule.Describe();
        _temperatureModule.Describe();
    }

    public bool Rest(int minutes)
    {
        int minutesSlept = 0;
        while (minutesSlept < minutes)
        {
            _exhaustionModule.Rest(1);
            World.Update(1);
            minutesSlept++;
            if (_exhaustionModule.IsFullyRested)
            {
                break;
            }
        }
        HealingInfo healing = new HealingInfo()
        {
            Amount = minutesSlept / 10,
            Type = "natural",
            TargetPart = "Body",
            Quality = _exhaustionModule.IsFullyRested ? 1 : .7, // healing quality is better after a full night's sleep
        };

        Heal(healing);
        return _exhaustionModule.IsFullyRested;
    }
    public void Consume(FoodItem food)
    {
        _hungerModule.AddCalories(food.Calories);
        _thirstModule.AddHydration(food.WaterContent);

        if (food.HealthEffect != null)
        {
            Heal(food.HealthEffect);
        }
        if (food.DamageEffect != null)
        {
            Damage(food.DamageEffect);
        }
    }

    public void UpdateSurvivalStats(SurvivalStatsUpdate stats)
    {
        if (stats.Temperature != 0)
        {
            BodyTemperature += stats.Temperature;
        }
        if (stats.Calories != 0)
        {
            _hungerModule.AddCalories(stats.Calories);
        }
        if (stats.Hydration != 0)
        {
            _thirstModule.AddHydration(stats.Hydration);
        }
        if (stats.Exhaustion != 0)
        {
            _exhaustionModule.ModifyExhaustion(stats.Exhaustion);
        }
    }
}================================================================================

File: ./Bodies/BodyInterfaces.cs
--------------------------------------------------------------------------------

namespace text_survival.Bodies;


// Comprehensive damage information
public class DamageInfo
{
    public DamageInfo() { }
    public DamageInfo(double amount,
                      string type = "physical",
                      string? source = null,
                      string? targetPart = null,
                      bool isPenetrating = false,
                      bool isBlunt = false,
                      bool isSharp = false,
                      double accuracy = .9)
    {
        Amount = amount;
        Type = type;
        Source = source;
        TargetPart = targetPart;
        IsPenetrating = isPenetrating;
        IsBlunt = isBlunt;
        IsSharp = isSharp;
        Accuracy = accuracy;
    }

    public double Amount { get; set; }
    public string Type { get; set; } = "physical"; // physical, thermal, poison, etc.
    public string? Source { get; set; }
    public string? TargetPart { get; set; } // Optional specific target
    public bool IsPenetrating { get; set; } = false;
    public bool IsSharp { get; set; } = false;
    public bool IsBlunt { get; set; } = false;
    public double Accuracy { get; set; } = .9;
}

// Comprehensive healing information
public class HealingInfo
{
    public double Amount { get; set; }
    public string Type { get; set; } = "natural"; // natural, medical, magical
    public string? TargetPart { get; set; }
    public double Quality { get; set; } = 1.0; // Effectiveness multiplier
    public string? Source { get; set; }
}

================================================================================

File: ./Bodies/BodyPartFactory.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Bodies;

public static class BodyPartFactory
{

    public enum BodyTypes
    {
        Human,
        Quadruped,
        Serpentine,
        Arachnid,
        Flying
    }

    public static BodyPart CreateBody(BodyTypes type, double baseHP)
    {
        return type switch
        {
            BodyTypes.Human => CreateHumanBody(baseHP),
            BodyTypes.Quadruped => CreateQuadrupedBody(baseHP),
            BodyTypes.Serpentine => CreateSerpentineBody(baseHP),
            BodyTypes.Arachnid => CreateArachnidBody(baseHP),
            BodyTypes.Flying => CreateFlyingBody(baseHP),
            _ => throw new NotImplementedException("Invalid body type")
        };
    }

    // Create a snake body
    public static BodyPart CreateSerpentineBody(double hp)
    {
        // Main body
        BodyPart body = new BodyPart("Body", hp, true, false, 100);

        // Head (smaller proportion for snakes - 15%)
        BodyPart head = CreateSnakeHead(hp * 0.15);
        body.AddPart(head);

        // Internal organs
        BodyPart heart = new BodyPart("Heart", hp * 0.05, true, true, 5);
        heart.SetBaseCapacity("BloodPumping", 1.0);
        body.AddPart(heart);

        BodyPart lungs = new BodyPart("Lung", hp * 0.05, true, true, 5);
        lungs.SetBaseCapacity("Breathing", 1.0);
        body.AddPart(lungs);

        // Spine running through the body
        BodyPart spine = new BodyPart("Spine", hp * 0.15, true, true, 15);
        spine.SetBaseCapacity("Moving", 1.0);
        body.AddPart(spine);

        // Segments - create multiple body segments
        int segmentCount = 5;
        for (int i = 1; i <= segmentCount; i++)
        {
            BodyPart segment = CreateSnakeSegment(hp * 0.12, $"Segment {i}");
            body.AddPart(segment);
        }

        // Tail
        BodyPart tail = new BodyPart("Tail", hp * 0.1, false, false, 10);
        tail.SetBaseCapacity("Moving", 0.3);
        body.AddPart(tail);

        // Calculate effective coverage
        body.CalculateEffectiveCoverage();

        return body;
    }

    // Helper method for snake head
    private static BodyPart CreateSnakeHead(double hp)
    {
        BodyPart head = new BodyPart("Head", hp, true, false, 15);

        // Eyes
        BodyPart leftEye = new BodyPart("Left Eye", hp * 0.1, false, false, 5);
        leftEye.SetBaseCapacity("Sight", 0.5);
        head.AddPart(leftEye);

        BodyPart rightEye = new BodyPart("Right Eye", hp * 0.1, false, false, 5);
        rightEye.SetBaseCapacity("Sight", 0.5);
        head.AddPart(rightEye);

        // Jaw with venom glands
        BodyPart jaw = new BodyPart("Jaw", hp * 0.3, false, false, 30);
        head.AddPart(jaw);

        BodyPart venomGland = new BodyPart("Venom Gland", hp * 0.15, false, true, 15);
        jaw.AddPart(venomGland);

        BodyPart tongue = new BodyPart("Tongue", hp * 0.05, false, false, 5);
        jaw.AddPart(tongue);

        return head;
    }

    // Helper method for snake body segments
    private static BodyPart CreateSnakeSegment(double hp, string name)
    {
        BodyPart segment = new BodyPart(name, hp, false, false, 12);
        segment.SetBaseCapacity("Moving", 0.2);
        return segment;
    }

    // Create an arachnid body (spider)
    public static BodyPart CreateArachnidBody(double hp)
    {
        // Create the main body (cephalothorax + abdomen)
        BodyPart body = new BodyPart("Body", hp, true, false, 100);

        // Cephalothorax - head and thorax combined
        BodyPart cephalothorax = new BodyPart("Cephalothorax", hp * 0.4, true, false, 40);
        body.AddPart(cephalothorax);

        // Eyes - spiders have multiple eyes
        for (int i = 1; i <= 8; i++)
        {
            BodyPart eye = new BodyPart($"Eye {i}", hp * 0.01, false, false, 1);
            eye.SetBaseCapacity("Sight", 0.125); // Total sight = 8 eyes * 0.125 = 1.0
            cephalothorax.AddPart(eye);
        }

        // Fangs
        BodyPart fangs = new BodyPart("Fangs", hp * 0.05, false, false, 5);
        cephalothorax.AddPart(fangs);

        BodyPart venomGland = new BodyPart("Venom Gland", hp * 0.05, false, true, 5);
        fangs.AddPart(venomGland);

        // Heart
        BodyPart heart = new BodyPart("Heart", hp * 0.05, true, true, 5);
        heart.SetBaseCapacity("BloodPumping", 1.0);
        cephalothorax.AddPart(heart);

        // Abdomen
        BodyPart abdomen = new BodyPart("Abdomen", hp * 0.3, true, false, 30);
        body.AddPart(abdomen);

        // Silk glands in abdomen
        BodyPart silkGland = new BodyPart("Silk Gland", hp * 0.05, false, true, 5);
        abdomen.AddPart(silkGland);

        // Spinnerets
        BodyPart spinnerets = new BodyPart("Spinnerets", hp * 0.05, false, false, 5);
        abdomen.AddPart(spinnerets);

        // Eight legs
        for (int i = 1; i <= 8; i++)
        {
            string legPosition;
            if (i <= 4)
                legPosition = $"Front {(i <= 2 ? "Left" : "Right")} Leg {(i % 2 == 0 ? 2 : 1)}";
            else
                legPosition = $"Rear {(i <= 6 ? "Left" : "Right")} Leg {(i % 2 == 0 ? 2 : 1)}";

            BodyPart leg = CreateArachnidLeg(hp * 0.025, legPosition);
            body.AddPart(leg);
        }

        // Calculate effective coverage
        body.CalculateEffectiveCoverage();

        return body;
    }

    // Helper method for spider leg
    private static BodyPart CreateArachnidLeg(double hp, string name)
    {
        BodyPart leg = new BodyPart(name, hp, false, false, 2.5);
        leg.SetBaseCapacity("Moving", 0.125); // Each leg contributes 1/8 of total movement

        // Leg segments
        BodyPart femur = new BodyPart("Femur", hp * 0.3, false, false, 30);
        leg.AddPart(femur);

        BodyPart patella = new BodyPart("Patella", hp * 0.2, false, false, 20);
        leg.AddPart(patella);

        BodyPart tibia = new BodyPart("Tibia", hp * 0.3, false, false, 30);
        leg.AddPart(tibia);

        BodyPart tarsus = new BodyPart("Tarsus", hp * 0.2, false, false, 20);
        leg.AddPart(tarsus);

        return leg;
    }

    // Create a flying body (for bats)
    public static BodyPart CreateFlyingBody(double hp)
    {
        // Torso
        BodyPart torso = new BodyPart("Torso", hp, true, false, 100);

        // Head
        BodyPart head = CreateHead(hp * 0.15);
        torso.AddPart(head);

        // Internal organs
        BodyPart heart = CreateHeart(hp * 0.05);
        torso.AddPart(heart);

        BodyPart leftLung = CreateLungs(hp * 0.05, "Left Lung");
        torso.AddPart(leftLung);

        BodyPart rightLung = CreateLungs(hp * 0.05, "Right Lung");
        torso.AddPart(rightLung);

        // Wings (modified arms/forelimbs)
        BodyPart leftWing = CreateWing(hp * 0.2, "Left Wing");
        torso.AddPart(leftWing);

        BodyPart rightWing = CreateWing(hp * 0.2, "Right Wing");
        torso.AddPart(rightWing);

        // Legs
        BodyPart leftLeg = CreateLeg(hp * 0.1, "Left Leg");
        torso.AddPart(leftLeg);

        BodyPart rightLeg = CreateLeg(hp * 0.1, "Right Leg");
        torso.AddPart(rightLeg);

        // Calculate effective coverage
        torso.CalculateEffectiveCoverage();

        return torso;
    }

    // Helper method for wings
    private static BodyPart CreateWing(double hp, string name)
    {
        BodyPart wing = new BodyPart(name, hp, false, false, 20);
        wing.SetBaseCapacity("Moving", 0.5); // Wings provide flight capability

        // Wing structure includes modified arm bones and wing membrane
        BodyPart humerus = new BodyPart("Humerus", hp * 0.2, false, false, 20);
        wing.AddPart(humerus);

        BodyPart radius = new BodyPart("Radius", hp * 0.15, false, false, 15);
        wing.AddPart(radius);

        BodyPart digits = new BodyPart("Digits", hp * 0.15, false, false, 15);
        wing.AddPart(digits);

        BodyPart membrane = new BodyPart("Membrane", hp * 0.5, false, false, 50);
        wing.AddPart(membrane);

        return wing;
    }
    public static BodyPart CreateHumanBody(double hp)
    {
        // Torso (main part)
        BodyPart torso = new BodyPart("Torso", hp, true, false, 100);

        // Neck (7.5% of torso)
        BodyPart neck = CreateNeck(hp * 0.075);
        torso.AddPart(neck);

        // Spine (2.5% of torso)
        BodyPart spine = CreateSpine(hp * .025);
        torso.AddPart(spine);

        // Ribcage (3.6% of torso)
        BodyPart ribcage = CreateRibcage(hp * 0.036);
        torso.AddPart(ribcage);

        // Sternum (1.5% of torso)
        BodyPart sternum = CreateSternum(hp * 0.015);
        torso.AddPart(sternum);

        // Internal organs
        // Stomach (2.5% of torso)
        BodyPart stomach = CreateStomach(hp * 0.025);
        torso.AddPart(stomach);

        // Heart (2.0% of torso)
        BodyPart heart = CreateHeart(hp * 0.02);
        torso.AddPart(heart);

        // Lungs (2.5% each, total 5.0% of torso)
        BodyPart leftLung = CreateLungs(hp * 0.025, "Left Lung");
        torso.AddPart(leftLung);

        BodyPart rightLung = CreateLungs(hp * 0.025, "Right Lung");
        torso.AddPart(rightLung);

        // Kidneys (1.7% each, total 3.4% of torso)
        BodyPart leftKidney = CreateKidney(hp * 0.017, "Left Kidney");
        torso.AddPart(leftKidney);

        BodyPart rightKidney = CreateKidney(hp * 0.017, "Right Kidney");
        torso.AddPart(rightKidney);

        // Liver (2.5% of torso)
        BodyPart liver = CreateLiver(hp * 0.025);
        torso.AddPart(liver);

        // Pelvis (2.5% of torso)
        BodyPart pelvis = CreatePelvis(hp * 0.025);
        torso.AddPart(pelvis);

        // Shoulders (12% of torso, 6% each)
        BodyPart leftShoulder = CreateShoulder(hp * 0.06, "Left Shoulder");
        torso.AddPart(leftShoulder);

        BodyPart rightShoulder = CreateShoulder(hp * 0.06, "Right Shoulder");
        torso.AddPart(rightShoulder);

        // Legs (14% of torso, 7% each)
        BodyPart leftLeg = CreateLeg(hp * 0.07, "Left Leg");
        torso.AddPart(leftLeg);

        BodyPart rightLeg = CreateLeg(hp * 0.07, "Right Leg");
        torso.AddPart(rightLeg);

        // Calculate effective coverage
        torso.CalculateEffectiveCoverage();

        return torso;
    }

    public static BodyPart CreateQuadrupedBody(double hp)
    {

        // Torso
        BodyPart torso = new BodyPart("Torso", hp, true, false, 100);

        // Head (10% of torso)
        BodyPart head = CreateHead(hp * 0.625);
        torso.AddPart(head);

        // Internal organs with appropriate coverage
        BodyPart heart = CreateHeart(hp * 0.375);
        torso.AddPart(heart);

        BodyPart leftLung = CreateLungs(hp * 0.375, "Left Lung");
        torso.AddPart(leftLung);

        BodyPart rightLung = CreateLungs(hp * 0.375, "Right Lung");
        torso.AddPart(rightLung);

        // Legs (higher coverage for quadrupeds)
        BodyPart frontLeftLeg = CreateLeg(hp * 0.75, "Front Left Leg");
        torso.AddPart(frontLeftLeg);

        BodyPart frontRightLeg = CreateLeg(hp * 0.75, "Front Right Leg");
        torso.AddPart(frontRightLeg);

        BodyPart rearLeftLeg = CreateLeg(hp * 0.75, "Rear Left Leg");
        torso.AddPart(rearLeftLeg);

        BodyPart rearRightLeg = CreateLeg(hp * 0.75, "Rear Right Leg");
        torso.AddPart(rearRightLeg);

        // Calculate effective coverage
        torso.CalculateEffectiveCoverage();

        return torso;
    }

    public static BodyPart CreateGenericBody(string name, double hp)
    {
        return new BodyPart(name, hp, true, false, 100);
    }

    public static BodyPart CreateNeck(double hp)
    {
        BodyPart neck = new BodyPart("Neck", hp, true, false, 7.5);
        neck.SetBaseCapacity("Eating", 0.5);
        neck.SetBaseCapacity("Talking", 0.5);
        neck.SetBaseCapacity("Breathing", 0.5);

        // Head (80% of neck)
        BodyPart head = CreateHead(hp);
        neck.AddPart(head);

        return neck;
    }

    public static BodyPart CreateHead(double hp)
    {
        BodyPart head = new BodyPart("Head", hp, true, false, 80.0);

        // Skull (18% of head)
        BodyPart skull = new BodyPart("Skull", hp * 0.625, false, true, 18.0);
        head.AddPart(skull);

        // Brain (80% of skull)
        BodyPart brain = CreateBrain(hp * 0.25);
        skull.AddPart(brain);

        // Eyes (7% each, total 14% of head)
        BodyPart rightEye = CreateEye(hp * 0.25, "Right Eye");
        head.AddPart(rightEye);

        BodyPart leftEye = CreateEye(hp * 0.25, "Left Eye");
        head.AddPart(leftEye);

        // Ears (7% each, total 14% of head)
        BodyPart leftEar = CreateEar(hp * 0.3, "Left Ear");
        head.AddPart(leftEar);

        BodyPart rightEar = CreateEar(hp * 0.3, "Right Ear");
        head.AddPart(rightEar);

        // Nose (10% of head)
        BodyPart nose = new BodyPart("Nose", hp * 0.25, false, false, 10.0);
        head.AddPart(nose);

        // Jaw (15% of head)
        BodyPart jaw = CreateJaw(hp * 0.5);
        head.AddPart(jaw);

        return head;
    }

    public static BodyPart CreateShoulder(double hp, string name = "Shoulder")
    {
        BodyPart shoulder = new BodyPart(name, hp, false, false, 6.0);
        shoulder.SetBaseCapacity("Manipulation", 0.5);

        // Clavicle (9% of shoulder)
        BodyPart clavicle = CreateClavicle(hp * 0.625);
        shoulder.AddPart(clavicle);

        // Arm (77% of shoulder)
        BodyPart arm = CreateArm(hp * 0.75, name.Replace("Shoulder", "Arm"));
        shoulder.AddPart(arm);

        return shoulder;
    }

    public static BodyPart CreateArm(double hp, string name = "Arm")
    {
        BodyPart arm = new BodyPart(name, hp, false, false, 77.0);
        arm.SetBaseCapacity("Manipulation", 0.5);

        // Humerus (10% of arm)
        BodyPart humerus = CreateHumerus(hp * 0.625);
        arm.AddPart(humerus);

        // Radius (10% of arm)
        BodyPart radius = CreateRadius(hp * 0.5);
        arm.AddPart(radius);

        // Hand (14% of arm)
        BodyPart hand = CreateHand(hp * 0.5, name.Replace("Arm", "Hand"));
        arm.AddPart(hand);

        return arm;
    }

    public static BodyPart CreateHand(double hp, string name = "Hand")
    {
        BodyPart hand = new BodyPart(name, hp, false, false, 14.0);
        hand.SetBaseCapacity("Manipulation", 0.5);

        // Fingers (each with appropriate coverage of hand)
        BodyPart thumb = CreateFinger(hp * 0.2, name.Replace("Hand", "Thumb"));
        hand.AddPart(thumb);

        BodyPart indexFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Index Finger"));
        hand.AddPart(indexFinger);

        BodyPart middleFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Middle Finger"));
        hand.AddPart(middleFinger);

        BodyPart ringFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Ring Finger"));
        hand.AddPart(ringFinger);

        BodyPart pinky = CreateFinger(hp * 0.2, name.Replace("Hand", "Pinky"));
        hand.AddPart(pinky);

        return hand;
    }

    public static BodyPart CreateFinger(double hp, string name = "Finger")
    {
        BodyPart finger = new BodyPart(name, hp, false, false, 7.0); // Average coverage
        finger.SetBaseCapacity("Manipulation", 0.08);
        return finger;
    }

    public static BodyPart CreateLeg(double hp, string name = "Leg")
    {
        BodyPart leg = new BodyPart(name, hp, false, false, 7.0);
        leg.SetBaseCapacity("Moving", 0.5);

        // Femur (10% of leg)
        BodyPart femur = CreateFemur(hp * 0.625);
        leg.AddPart(femur);

        // Tibia (10% of leg)
        BodyPart tibia = CreateTibia(hp * 0.625);
        leg.AddPart(tibia);

        // Foot (10% of leg)
        BodyPart foot = CreateFoot(hp * 0.625, name.Replace("Leg", "Foot"));
        leg.AddPart(foot);

        return leg;
    }

    public static BodyPart CreateFoot(double hp, string name = "Foot")
    {
        BodyPart foot = new BodyPart(name, hp, false, false, 10.0);
        foot.SetBaseCapacity("Moving", 0.5);

        // Toes (each with appropriate coverage of foot)
        BodyPart bigToe = CreateToe(hp * 0.2, name.Replace("Foot", "Big Toe"));
        foot.AddPart(bigToe);

        BodyPart secondToe = CreateToe(hp * 0.2, name.Replace("Foot", "Second Toe"));
        foot.AddPart(secondToe);

        BodyPart middleToe = CreateToe(hp * 0.2, name.Replace("Foot", "Middle Toe"));
        foot.AddPart(middleToe);

        BodyPart fourthToe = CreateToe(hp * 0.2, name.Replace("Foot", "Fourth Toe"));
        foot.AddPart(fourthToe);

        BodyPart littleToe = CreateToe(hp * 0.2, name.Replace("Foot", "Little Toe"));
        foot.AddPart(littleToe);

        return foot;
    }

    public static BodyPart CreateToe(double hp, string name = "Toe")
    {
        BodyPart toe = new BodyPart(name, hp, false, false, 7.0); // Average coverage
        toe.SetBaseCapacity("Moving", 0.04);
        return toe;
    }

    public static BodyPart CreateBrain(double hp)
    {
        BodyPart brain = new BodyPart("Brain", hp, true, true, 80.0);
        brain.SetBaseCapacity("Consciousness", 1.0);
        return brain;
    }

    public static BodyPart CreateEye(double hp, string name = "Eye")
    {
        BodyPart eye = new BodyPart(name, hp, false, false, 7.0);
        eye.SetBaseCapacity("Sight", 0.5);
        return eye;
    }

    public static BodyPart CreateMouth(double hp)
    {
        BodyPart mouth = new BodyPart("Mouth", hp, false, false, 15.0);
        mouth.SetBaseCapacity("Eating", 0.5);
        mouth.SetBaseCapacity("Talking", 0.5);
        return mouth;
    }

    public static BodyPart CreateJaw(double hp)
    {
        BodyPart jaw = new BodyPart("Jaw", hp, false, false, 15.0);
        jaw.SetBaseCapacity("Eating", 0.5);
        jaw.SetBaseCapacity("Talking", 0.5);

        // Tongue (0.1% of jaw as per RimWorld)
        BodyPart tongue = CreateTongue(hp * 0.25);
        jaw.AddPart(tongue);

        return jaw;
    }

    public static BodyPart CreateTongue(double hp)
    {
        BodyPart tongue = new BodyPart("Tongue", hp, false, true, 0.1);
        tongue.SetBaseCapacity("Talking", 0.5);
        return tongue;
    }

    public static BodyPart CreateLungs(double hp, string name = "Lungs")
    {
        BodyPart lungs = new BodyPart(name, hp, true, true, 2.5);
        lungs.SetBaseCapacity("Breathing", 0.5);
        return lungs;
    }

    public static BodyPart CreateEar(double hp, string name = "Ear")
    {
        BodyPart ear = new BodyPart(name, hp, false, false, 7.0);
        ear.SetBaseCapacity("Hearing", 0.5);
        return ear;
    }

    public static BodyPart CreateHeart(double hp)
    {
        BodyPart heart = new BodyPart("Heart", hp, true, true, 2.0);
        heart.SetBaseCapacity("BloodPumping", 1.0);
        return heart;
    }

    public static BodyPart CreateStomach(double hp)
    {
        BodyPart stomach = new BodyPart("Stomach", hp, true, true, 2.5);
        stomach.SetBaseCapacity("Digestion", 0.5);
        return stomach;
    }

    public static BodyPart CreateLiver(double hp)
    {
        BodyPart liver = new BodyPart("Liver", hp, true, true, 2.5);
        liver.SetBaseCapacity("Digestion", 0.5);
        return liver;
    }

    public static BodyPart CreateKidney(double hp, string name = "Kidney")
    {
        BodyPart kidney = new BodyPart(name, hp, true, true, 1.7);
        kidney.SetBaseCapacity("BloodFiltration", 0.5);
        return kidney;
    }

    public static BodyPart CreateSpine(double hp)
    {
        BodyPart spine = new BodyPart("Spine", hp, false, true, 2.5);
        spine.SetBaseCapacity("Moving", 1.0);
        return spine;
    }

    public static BodyPart CreateRibcage(double hp)
    {
        BodyPart ribcage = new BodyPart("Ribcage", hp, false, true, 3.6);
        ribcage.SetBaseCapacity("Breathing", 0.5);
        return ribcage;
    }

    public static BodyPart CreateSternum(double hp)
    {
        BodyPart sternum = new BodyPart("Sternum", hp, false, true, 1.5);
        sternum.SetBaseCapacity("Breathing", 0.5);
        return sternum;
    }

    public static BodyPart CreatePelvis(double hp)
    {
        BodyPart pelvis = new BodyPart("Pelvis", hp, false, true, 2.5);
        pelvis.SetBaseCapacity("Moving", 1.0);
        return pelvis;
    }

    public static BodyPart CreateClavicle(double hp)
    {
        BodyPart clavicle = new BodyPart("Clavicle", hp, false, true, 9.0);
        clavicle.SetBaseCapacity("Manipulation", 0.5);
        return clavicle;
    }

    public static BodyPart CreateHumerus(double hp)
    {
        BodyPart humerus = new BodyPart("Humerus", hp, false, true, 10.0);
        humerus.SetBaseCapacity("Manipulation", 0.5);
        return humerus;
    }

    public static BodyPart CreateRadius(double hp)
    {
        BodyPart radius = new BodyPart("Radius", hp, false, true, 10.0);
        radius.SetBaseCapacity("Manipulation", 0.5);
        return radius;
    }

    public static BodyPart CreateFemur(double hp)
    {
        BodyPart femur = new BodyPart("Femur", hp, false, true, 10.0);
        femur.SetBaseCapacity("Moving", 0.5);
        return femur;
    }

    public static BodyPart CreateTibia(double hp)
    {
        BodyPart tibia = new BodyPart("Tibia", hp, false, true, 10.0);
        tibia.SetBaseCapacity("Moving", 0.5);
        return tibia;
    }
}
================================================================================

File: ./IO/Input.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.IO
{
    public static class Input
    {
        private static ManualResetEvent manualResetEvent = new ManualResetEvent(false);
        // private static string userInput;
        // public static void OnUserInputReceived(string input)
        // {
        //     userInput = input;
        //     manualResetEvent.Set();
        // }
        public static string Read()
        {
            string? input = "";
            if (Config.io == Config.IOType.Console)
            {
                input = Console.ReadLine();
            }
            else if (Config.io == Config.IOType.Web)
            {
                // await user input from web
                //input = AwaitInput();
                throw new NotImplementedException();
            }

            return input ?? "";
        }

        // public static string AwaitInput()
        // {
        //     manualResetEvent.WaitOne();
        //     manualResetEvent.Reset();
        //     return userInput;
        // }

        public static int ReadInt()
        {
            while (true)
            {
                string? input = Read();
                if (int.TryParse(input, out int result))
                {
                    return result;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number.\n");
                }
            }
        }

        public static int ReadInt(int low, int high)
        {
            while (true)
            {
                int input = ReadInt();
                if (input >= low && input <= high)
                {
                    return input;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number between ", low, " and ", high, ".\n");
                }
            }
        }

        public static bool ReadYesNo()
        {
            while (true)
            {
                string? input = Read().Trim().ToLower();
                if (input == "y" || input == "yes")
                {
                    return true;
                }
                else if (input == "n" || input == "no")
                {
                    return false;
                }
                else
                {
                    Output.Write("Invalid input. Please enter 'y' or 'n'.\n");
                }
            }
        }

        public static T? GetSelectionFromList<T>(List<T> list, bool cancelOption = false, string cancelMessage = "Cancel")
        {
            list.ForEach(i =>
            {
                if (i != null) Output.WriteLine(list.IndexOf(i) + 1, ". ", i);
            });

            int input;
            if (cancelOption)
            {
                Output.WriteLine(0, ". ", cancelMessage);
                input = ReadInt(0, list.Count);
                if (input == 0)
                {
                    return default;
                }
            }
            else
            {
                input = ReadInt(1, list.Count);
            }

            return list[input - 1];
        }
    }
}
================================================================================

File: ./IO/Output.cs
--------------------------------------------------------------------------------
﻿using System.Text;
using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival.IO
{
    public static class Output
    {
        public static int SleepTime = 20;
        public static Queue<string> OutputQueue = new Queue<string>();

        public static ConsoleColor DetermineTextColor(object x)
        {
            return x switch
            {
                string => ConsoleColor.Gray,
                int or float or double => ConsoleColor.Green,
                Npc => ConsoleColor.Red,
                Item => ConsoleColor.Cyan,
                Container => ConsoleColor.Yellow,
                Player => ConsoleColor.Green,
                Zone => ConsoleColor.Blue,
                Location => ConsoleColor.DarkYellow,
                Enum => ConsoleColor.White,
                null => ConsoleColor.Red,
                _ => ConsoleColor.White,
            };
        }

        public static void Write(params object[] args)
        {

            if (Config.io == Config.IOType.Console)
            {
                foreach (var arg in args)
                {
                    string text = GetFormattedText(arg);
                    Console.ForegroundColor = DetermineTextColor(arg);
                    Console.Write(text);
                    Thread.Sleep(SleepTime);
                }
            }
            else if (Config.io == Config.IOType.Web)
            {
                throw new NotImplementedException();
                //EventHandler.Publish(new WriteEvent(text));
            }

        }

        private static string GetFormattedText(params object[] args)
        {
            string result = string.Empty;

            foreach (var arg in args)
            {
                switch (arg)
                {
                    case float f:
                        result += $"{f:F1}";
                        break;
                    case double d:
                        result += $"{d:F1}";
                        break;
                    case null:
                        result += "[NULL]";
                        break;
                    default:
                        result += arg.ToString();
                        break;
                }
            }
            return result;

        }

        public static void WriteLine(params object[] args)
        {
            Write(args);
            Write("\n");
        }


        public static void WriteWarning(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Yellow;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        public static void WriteDanger(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Red;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        internal static void WriteSuccess(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Green;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }
    }
}
================================================================================

File: ./Program.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;
using text_survival.Events;
using text_survival.IO;
using text_survival.Items;

namespace text_survival
{
    public class Program
    {
        static void Main()
        {
            Output.SleepTime = 500;
            Output.WriteLine("You wake up in the forest, with no memory of how you got there.");
            Output.WriteLine("Light snow is falling, and you feel the air getting colder.");
            Output.WriteLine("You need to find shelter, food, and water to survive.");
            Output.SleepTime = 10;
            Zone zone = ZoneFactory.MakeForestZone();
            Container oldBag = new Container("Old bag", 10);
            Location startingArea = new Location("Clearing", zone);
            oldBag.Add(ItemFactory.MakeKnife());
            oldBag.Add(ItemFactory.MakeMoccasins());
            oldBag.Add(ItemFactory.MakeLeatherTunic());
            oldBag.Add(ItemFactory.MakeLeatherPants());
            startingArea.Containers.Add(oldBag);
            zone.Locations.Add(startingArea);
            Player player = new Player(startingArea);
            World.Player = player;
            Actions actions = new(player);

            EventBus.Subscribe(new StarvingEventHandler());
            EventBus.Subscribe(new DehydrationEventHandler());
            EventBus.Subscribe(new ExhaustionEventHandler());
            EventBus.Subscribe(new StoppedStarvingEventHandler());
            EventBus.Subscribe(new StoppedDehydrationEventHandler());
            EventBus.Subscribe(new StoppedExhaustionEventHandler());
            EventBus.Subscribe(new BodyHotEventHandler());
            EventBus.Subscribe(new BodyColdEventHandler());
            

            while (player.IsAlive)
            {
                actions.Act();
            }
        }
    }
}================================================================================

File: ./Survival/ThirstModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.Events;
using text_survival.IO;

namespace text_survival.Survival
{
    public class ThirstModule
    {
        public bool IsParched => Amount >= Max;
        private double Rate = 4000F / (24F * 60F); // mL per minute
        private double Max = 3000.0F; // mL
        private double Amount { get; set; }
        public ThirstModule()
        {
            Amount = 0;
        }
        public void AddHydration(double mL)
        {
            Amount -= mL;
            if (Amount < 0)
            {
                Amount = 0;
            }
        }
        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
                Amount = Max;
        }
        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Thirst: ", percent, "%");
        }
    }
}================================================================================

File: ./Survival/TemperatureModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Events;
using text_survival.IO;

namespace text_survival.Survival;

public class TemperatureModule(Body owner)
{
    private readonly Body owner = owner;
    private double BodyTemperature => owner.BodyTemperature;
    private bool IsWarming;
    private TemperatureEnum TemperatureEffect = TemperatureEnum.Warm;

    private const double BaseBodyTemperature = 98.6F;
    private const double SevereHypothermiaThreshold = 89.6; // °F
    private const double HypothermiaThreshold = 95.0;  // °F
    private const double HyperthermiaThreshold = 99.5; // °F  

    private enum TemperatureEnum
    {
        Warm,
        Cool,
        Cold,
        Freezing,
        Hot,
    }

    public void Update(double environmentalTemp, double equipmentInsulation)
    {
        UpdateTemperatureTick(environmentalTemp, equipmentInsulation);
    }

    private void UpdateTemperatureTick(double environmentalTemp, double equipmentInsulation)
    {
        double naturalInsulation = Math.Clamp(owner.CalculateColdResistance(), 0, 1); // 0-1
        double totalInsulation = Math.Clamp(naturalInsulation + equipmentInsulation, 0, 0.95);

        double skinTemp = BodyTemperature - 8.4;
        double tempDifferential = environmentalTemp - skinTemp;
        double insulatedDiff = tempDifferential * (1 - totalInsulation);
        double tempDiffMagnitude = Math.Abs(insulatedDiff);
        double baseRate = 1.0 / 120.0;
        double exponentialFactor = 1.0 + (tempDiffMagnitude / 40.0);
        double rate = baseRate * exponentialFactor;

        // double surfaceAreaFactor = Math.Pow(body.Weight / 70.0, -0.2);

        double tempChange = insulatedDiff * rate;
        owner.BodyTemperature += tempChange;

        IsWarming = tempChange > 0;

        UpdateTemperatureEffect();
    }


    private void UpdateTemperatureEffect()
    {
        TemperatureEnum oldTemperature = TemperatureEffect;

        // Normal body temperature, no effects
        if (BodyTemperature >= BaseBodyTemperature && BodyTemperature <= HyperthermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Warm;
        }
        else if (BodyTemperature >= HypothermiaThreshold && BodyTemperature < BaseBodyTemperature)
        {
            TemperatureEffect = TemperatureEnum.Cool;
        }

        else if (BodyTemperature > SevereHypothermiaThreshold && BodyTemperature <= HypothermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Cold;
            EventBus.Publish(new BodyColdEvent(owner, oldTemperature != TemperatureEffect));
        }
        else if (BodyTemperature < SevereHypothermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Freezing;
            EventBus.Publish(new BodyColdEvent(owner, oldTemperature != TemperatureEffect));
        }
        else if (BodyTemperature > HyperthermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Hot;
            EventBus.Publish(new BodyHotEvent(owner, oldTemperature != TemperatureEffect));
        }
    }


    public void Describe()
    {
        string tempChange = IsWarming ? "Warming up" : "Getting colder";
        Output.WriteLine("Body Temperature: ", BodyTemperature, "°F (", TemperatureEffect, "), ", tempChange);
    }
}
================================================================================

File: ./Survival/HungerModule.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Bodies;
using text_survival.Events;
using text_survival.IO;

namespace text_survival.Survival;


public class HungerModule(Body owner)
{
	private const double MAX_CALORIES = 2000.0; // Maximum calories stored before fat conversion


	private bool IsStarving => CurrentCalories <= 0;
	private bool wasStarving;
	private double CurrentCalories { get; set; } = 0;
	private readonly Body owner = owner;

	public void Update(double metabolicRate)
	{
		// todo, actually update with activity level
		// todo have this account for temp too

		double calories = metabolicRate / 24 / 60;  //* timePassed.TotalHours;

		CurrentCalories -= calories;

		if (IsStarving)
		{
			double excessCalories = -CurrentCalories;
			CurrentCalories = 0;
			EventBus.Publish(new StarvingEvent(owner, excessCalories, isNew: !wasStarving));
		}
		else if (wasStarving)
		{
			EventBus.Publish(new StoppedStarvingEvent(owner));
		}
		wasStarving = IsStarving;
	}

	public void AddCalories(double calories)
	{
		CurrentCalories += calories;

		if (CurrentCalories > MAX_CALORIES)
		{
			double excessCalories = CurrentCalories - MAX_CALORIES;
			EventBus.Publish(new CalorieSurplusEvent(owner, excessCalories));
			CurrentCalories = MAX_CALORIES;
		}
	}

	public void Describe()
	{
		double percent = (int)(CurrentCalories / MAX_CALORIES * 100);
		Output.WriteLine("Hunger: ", percent, "%");
	}
}
================================================================================

File: ./Survival/ExhaustionModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class ExhaustionModule
    {
        public bool IsExhausted => Amount >= Max;
        public bool IsFullyRested => Amount <= 0;
        public double ExhaustionPercent => (Amount / Max) * 100;
        private double Rate = 1;
        private double Max = 480.0F; // minutes (8 hours)
        public double Amount { get; private set; }

        public ExhaustionModule()
        {
            Amount = 0;
        }

        public void Rest(int minutes)
        {
            Amount -= minutes * Rate;
            if (Amount < 0)
            {
                Amount = 0;
            }
        }

        public void ModifyExhaustion(double minutes)
        {
            Amount += minutes;
            if (Amount > Max)
            {
                Amount = Max;
            }
        }

        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
            {
                Amount = Max;
            }
        }

        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Exhaustion: ", percent, "%");
        }
    }
}================================================================================

File: ./World.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;

namespace text_survival
{
    public static class World
    {
        public static TimeOnly Time { get; set; } = new TimeOnly(hour: 9, minute: 0);

        public static Player? Player { get; set; }
        public static void Update(int minutes)
        {
            for (int i = 0; i < minutes; i++)
            {
                Player?.Update();
                Player?.CurrentZone.Update();
                Time = Time.AddMinutes(1);
            }
        }

        public enum TimeOfDay
        {
            Night,
            Dawn,
            Morning,
            Afternoon,
            Noon,
            Evening,
            Dusk
        }

        public static TimeOfDay GetTimeOfDay()
        {
            return Time.Hour switch
            {
                < 5 => TimeOfDay.Night,
                < 6 => TimeOfDay.Dawn,
                < 11 => TimeOfDay.Morning,
                < 13 => TimeOfDay.Noon,
                < 17 => TimeOfDay.Afternoon,
                < 20 => TimeOfDay.Evening,
                < 21 => TimeOfDay.Dusk,
                _ => TimeOfDay.Night
            };
        }

    }
}
================================================================================

File: ./Utils/Utils.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Utils
    {
        private static readonly Random random = new Random(DateTime.Now.Millisecond);

        static Utils()
        {
            random = new Random(DateTime.Now.Millisecond);
        }

        public static int Roll(int sides)
        {
            return random.Next(1, sides + 1);
        }

        public static bool DetermineSuccess(double chance)
        {
            return (random.NextDouble() < chance);
        }

        public static int RandInt(int low, int high)
        {
            return random.Next(low, high + 1);
        }

        public static float RandFloat(float low, float high)
        {
            return (float)random.NextDouble() * (high - low) + low;
        }

        public static double RandDouble(double low, double high)
        {
            return random.NextDouble() * (high - low) + low;
        }

        public static bool FlipCoin()
        {
            return random.Next(2) == 0;
        }

        public static T? GetRandomEnum<T>() where T : Enum
        {
            Array values = Enum.GetValues(typeof(T));
            return (T?)values.GetValue(Roll(values.Length) - 1);
        }

        public static T GetRandomFromList<T>(List<T> list)
        {
            if (list.Count == 0)
            {
                throw new Exception("List is empty.");
            }
            return list[Roll(list.Count) - 1];
        }
        
    public static T GetRandomWeighted<T>(IDictionary<T, double> choices)
    {
        if (choices == null || choices.Count == 0)
            throw new ArgumentException("Cannot select from an empty collection", nameof(choices));
            
        double totalWeight = choices.Sum(pair => pair.Value);
        if (totalWeight <= 0)
            throw new ArgumentException("Total weight must be positive", nameof(choices));
            
        double roll = random.NextDouble() * totalWeight;
        
        double cumulativeWeight = 0;
        foreach (var pair in choices)
        {
            cumulativeWeight += pair.Value;
            if (roll <= cumulativeWeight)
                return pair.Key;
        }
        
        // This should never happen if weights are positive
        return choices.Keys.Last();
    }
    }
}
================================================================================

File: ./Utils/WeightedTable.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival;

public class GenericWeightedTable<T> where T : class
{
    protected Dictionary<Func<T>, double> weightedFactories = [];

    public GenericWeightedTable() { }
    public void AddFactory(Func<T> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual T GenerateRandom()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)();
    }
}

public class LootTable : GenericWeightedTable<Item>
{
    public void AddItem(Func<Item> itemFactory, double weight = 1)
    {
        AddFactory(itemFactory, weight);
    }

    public Item GenerateRandomItem()
    {
        return base.GenerateRandom();
    }
}

public class LocationTable
{
    protected Dictionary<Func<Zone, Location>, double> weightedFactories = [];

    public void AddFactory(Func<Zone, Location> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual Location GenerateRandom(Zone parent)
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)(parent);
    }
}


public class NpcTable : GenericWeightedTable<Npc>
{
    public void AddActor(Func<Npc> actorFactory, double weight = 1)
    {
        AddFactory(actorFactory, weight);
    }
}================================================================================

File: ./Magic/SpellFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;

namespace text_survival.Magic
{
    public static class SpellFactory
    {
        public static Spell MinorHeal => new Spell("Minor Heal", new HealEffect("healing spell", null, 10), true);
        public static Spell Bleeding => new Spell("Bleeding", new BleedEffect("bleed spell", null, 1, 10, 60), true);
        public static Spell Poison => new Spell("Poison", new PoisonEffect("magic", "poison spell", 1, 5, 180), false);
    }
}
================================================================================

File: ./Magic/Spell.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;

namespace text_survival.Magic;

public class Spell
{
    public string Name { get; private set; }
    public bool NeedsTargetPart { get; private set; }
    private Effect Effect { get; }


    public Spell(string name, Effect effect, bool needsTargetPart)
    {
        Name = name;
        Effect = effect;
        NeedsTargetPart = needsTargetPart;
    }

    public void Cast(Actor target)
    {
        target.ApplyEffect(Effect);
    }
    public void Cast(Actor target, BodyPart part)
    {
        Effect.TargetBodyPart = part;
        target.ApplyEffect(Effect);
    }



}
================================================================================

File: ./Combat.cs
--------------------------------------------------------------------------------
﻿using text_survival;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival
{
    public static class Combat
    {
        public static void CombatLoop(Player player, Actor enemy)
        {
            // Dramatic combat intro
            Output.WriteLine("!");
            Output.WriteLine(CombatNarrator.DescribeCombatStart(player, enemy));

            player.IsEngaged = true;
            enemy.IsEngaged = true;

            // First strike determination
            bool enemyFirstStrike = enemy.Body.CalculateSpeed() > player.Body.CalculateSpeed();

            if (enemyFirstStrike)
            {
                Output.WriteLine($"The {enemy.Name} moves with surprising speed!");
                Thread.Sleep(500);
                enemy.Attack(player);
            }
            else
            {
                Output.WriteLine("You're quick to react, giving you the initiative!");
                Thread.Sleep(500);
            }

            // Combat loop
            while (player.IsAlive && enemy.IsAlive)
            {
                if (!player.IsEngaged || !player.IsAlive) break;
                PlayerTurn(player, enemy);

                if (!enemy.IsEngaged || !enemy.IsAlive) break;
                Thread.Sleep(500); // Pause before enemy attack
                enemy.Attack(player);

                World.Update(1);
            }

            player.IsEngaged = false;
            enemy.IsEngaged = false;

            // Combat end
            if (!player.IsAlive)
            {
                Output.WriteDanger("Your vision fades to black as you collapse... You have died!");
            }
            else if (!enemy.IsAlive)
            {
                string[] victoryMessages = {
                    $"The {enemy.Name} collapses, defeated!",
                    $"You stand victorious over the fallen {enemy.Name}!",
                    $"With a final blow, you bring down the {enemy.Name}!"
                };
                Output.WriteLine(victoryMessages[Utils.RandInt(0, victoryMessages.Length - 1)]);

                // Calculate experience based on enemy difficulty
                int xpGain = CalculateExperienceGain(enemy);
                Output.WriteLine($"You've gained {xpGain} fighting experience!");
                player._skillRegistry.AddExperience("Fighting", xpGain);
            }
        }

        private static int CalculateExperienceGain(Actor enemy)
        {
            // Base XP
            int baseXP = 5;

            // Adjust based on enemy weight/size
            double sizeMultiplier = Math.Clamp(enemy.Body.Weight / 50, 0.5, 3.0);

            // Adjust based on enemy weapon damage
            double weaponMultiplier = Math.Clamp(enemy.ActiveWeapon.Damage / 8, 0.5, 2.0);

            return (int)(baseXP * sizeMultiplier * weaponMultiplier);
        }


        public static void PlayerTurn(Player player, Actor enemy)
        {
            Output.WriteLine("─────────────────────────────────────");

            // Display combat status
            DisplayCombatStatus(player, enemy);

            Output.WriteLine("What do you want to do?");

            List<string> options = ["Attack", "Target Attack", "Cast Spell", "Flee"];

            string? choice = Input.GetSelectionFromList(options);

            switch (choice)
            {
                case "Attack":
                    player.Attack(enemy);
                    break;
                case "Target Attack":
                    string? targetPart = SelectTargetPart(enemy, player._skillRegistry.GetLevel("Fighting"));
                    if (targetPart != null)
                    {
                        player.Attack(enemy, targetPart);
                    }
                    else
                    {
                        // Player changed their mind
                        PlayerTurn(player, enemy);
                    }
                    break;
                case "Cast Spell":
                    player.SelectSpell();
                    break;
                case "Flee":
                    if (SpeedCheck(player, enemy))
                    {
                        Output.WriteLine("You got away!");
                        enemy.IsEngaged = false;
                        player.IsEngaged = false;
                    }
                    else
                    {
                        Output.WriteLine("You weren't fast enough to get away from ", enemy, "!");
                        player._skillRegistry.AddExperience("Agility", 1); // XP for flee attempt
                    }
                    break;
                default:
                    throw new InvalidOperationException("Invalid Selection");
            }
        }

        private static string? SelectTargetPart(Actor enemy, int depth)
        {
            if (depth <= 0)
            {
                Output.WriteWarning("You don't have enough skill to target an attack");
                return null;
            }
            Output.WriteLine($"Where do you want to target your attack on the {enemy.Name}?");

            // Group body parts by region for better organization
            var allParts = enemy.Body.GetPartsToNDepth(depth)!;

            BodyPart? choice = Input.GetSelectionFromList(allParts, true);
            if (choice == null)
                return null;

            // todo return part itself
            return choice.Name;
        }

        public static void DisplayCombatStatus(Player player, Actor enemy)
        {
            ConsoleColor oldColor = Console.ForegroundColor;

            // Player status
            Console.ForegroundColor = GetHealthColor(player.Body.Health / player.Body.MaxHealth);
            Output.WriteLine($"You: {Math.Round(player.Body.Health, 0)}/{Math.Round(player.Body.MaxHealth, 0)} HP");

            // Enemy status
            Console.ForegroundColor = GetHealthColor(enemy.Body.Health / enemy.Body.MaxHealth);
            Output.WriteLine($"{enemy.Name}: {Math.Round(enemy.Body.Health, 0)}/{Math.Round(enemy.Body.MaxHealth, 0)} HP");

            Console.ForegroundColor = oldColor;
        }

        private static ConsoleColor GetHealthColor(double healthPercentage)
        {
            if (healthPercentage < 0.2) return ConsoleColor.Red;
            if (healthPercentage < 0.5) return ConsoleColor.Yellow;
            return ConsoleColor.Green;
        }
        public static bool SpeedCheck(Player player, Actor? enemy = null)
        {
            if (player.CurrentLocation.Npcs.Count == 0) return true;

            enemy ??= GetFastestNpc(player.CurrentLocation);

            double playerCheck = CalcSpeedCheck(player);
            double enemyCheck = CalcSpeedCheck(enemy);

            return playerCheck >= enemyCheck;
        }

        public static Npc GetFastestNpc(Location location)
        {
            double enemyCheck = 0;
            Npc fastestNpc = location.Npcs.First();
            foreach (Npc npc in location.Npcs)
            {
                if (npc == fastestNpc) continue;
                if (!npc.IsAlive) continue;
                var currentNpcCheck = CalcSpeedCheck(npc);
                if (currentNpcCheck < enemyCheck) continue;
                fastestNpc = npc;
                enemyCheck = currentNpcCheck;
            }
            return fastestNpc;
        }

        public static double CalcSpeedCheck(Actor actor)
        {
            double athleticsBonus = actor._skillRegistry.GetLevel("Agility");
            return actor.Body.CalculateSpeed() + athleticsBonus;
        }
    }
}
public static class CombatNarrator
{
    private static readonly Dictionary<WeaponClass, List<string>> AttackVerbs = new()
    {
        { WeaponClass.Blade, new List<string> { "slashes", "cuts", "slices", "carves" } },
        { WeaponClass.Blunt, new List<string> { "bashes", "strikes", "smashes", "cracks" } },
        { WeaponClass.Pierce, new List<string> { "stabs", "pierces", "impales", "punctures" } },
        { WeaponClass.Claw, new List<string> { "tears", "rips", "rends", "shreds" } },
        { WeaponClass.Unarmed, new List<string> { "punches", "strikes", "hits", "pounds" } }
    };

    private static readonly Dictionary<WeaponType, List<string>> SpecialAttackDescriptions = new()
    {
        { WeaponType.Spear, new List<string> { "lunges with", "thrusts forward with", "strikes with" } },
        { WeaponType.Claws, new List<string> { "swipes with", "tears with", "mauls with" } },
        { WeaponType.Fangs, new List<string> { "bites with", "snaps with", "sinks" } },
        { WeaponType.Knife, new List<string> { "slashes with", "jabs with", "slices with" } },
        { WeaponType.Club, new List<string> { "swings", "brings down", "thumps with" } }
    };

    public static string DescribeAttack(Actor attacker, Actor target, double damage, string targetPart, bool isHit, bool isDodged, bool isBlocked)
    {
        var sb = new System.Text.StringBuilder();

        // 1. Attack Initiation
        sb.Append(DescribeAttackAttempt(attacker, target, targetPart));

        // 2. Attack Resolution
        if (isDodged)
            sb.Append(DescribeDodge(attacker, target));
        else if (isBlocked)
            sb.Append(DescribeBlock(attacker, target));
        else if (!isHit)
            sb.Append(DescribeMiss(attacker, target));
        else
            sb.Append(DescribeHit(attacker, target, damage, targetPart));

        return sb.ToString();
    }

    private static string DescribeAttackAttempt(Actor attacker, Actor target, string targetPart)
    {
        WeaponType weaponType = attacker.ActiveWeapon.Type;
        string weaponName = attacker.ActiveWeapon.Name;

        if (attacker is Player)
        {
            // Get special description based on weapon type if available
            if (SpecialAttackDescriptions.TryGetValue(weaponType, out var specialDescs))
            {
                string desc = specialDescs[Utils.RandInt(0, specialDescs.Count - 1)];
                return $"You {desc} your {weaponName}, at {target.Name}'s {targetPart}. ";
            }
            else
            {
                return $"You attack with your {weaponName}, aiming at {target.Name}'s {targetPart}. ";
            }
        }
        else
        {
            // Enemy attacking player
            if (SpecialAttackDescriptions.TryGetValue(weaponType, out var specialDescs))
            {
                string desc = specialDescs[Utils.RandInt(0, specialDescs.Count - 1)];
                return $"The {attacker.Name} {desc} its {weaponName} at your {targetPart}. ";
            }
            else
            {
                return $"The {attacker.Name} attacks with its {weaponName}, lunging at your {targetPart}. ";
            }
        }
    }

    private static string DescribeDodge(Actor attacker, Actor target)
    {
        if (target is Player)
            return $"You quickly sidestep the {attacker.Name}'s attack!";
        else
            return $"The {target.Name} nimbly evades your strike!";
    }

    private static string DescribeBlock(Actor attacker, Actor target)
    {
        if (target is Player)
            return $"You raise your {target.ActiveWeapon.Name} and deflect the attack!";
        else
            return $"The {target.Name} blocks your blow with its {target.ActiveWeapon.Name}!";
    }

    private static string DescribeMiss(Actor attacker, Actor target)
    {
        if (attacker is Player)
            return "Your attack misses, throwing you slightly off balance!";
        else
            return $"The {attacker.Name}'s attack whistles past you, missing entirely!";
    }

    private static string DescribeHit(Actor attacker, Actor target, double damage, string targetPart)
    {
        WeaponClass weaponClass = attacker.ActiveWeapon.Class;

        // Get appropriate attack verb based on weapon class
        string attackVerb;
        if (AttackVerbs.TryGetValue(weaponClass, out var verbs))
            attackVerb = verbs[Utils.RandInt(0, verbs.Count - 1)];
        else
            attackVerb = "strikes";

        // Describe damage severity
        string damageDesc = GetDamageSeverity(damage);

        // Describe hit
        if (attacker is Player)
        {
            return $"Your attack {attackVerb} the {target.Name}'s {targetPart}, dealing {damageDesc} damage! ({Math.Round(damage, 1)})";
        }
        else
        {
            return $"The {attacker.Name}'s attack {attackVerb} your {targetPart}, dealing {damageDesc} damage! ({Math.Round(damage, 1)})";
        }
    }

    private static string GetDamageSeverity(double damage)
    {
        if (damage <= 2) return "minimal";
        if (damage <= 5) return "light";
        if (damage <= 10) return "moderate";
        if (damage <= 15) return "severe";
        if (damage <= 25) return "critical";
        return "devastating";
    }

    public static string DescribeTargetStatus(string partName, double healthPercent)
    {
        if (healthPercent <= 0)
            return $"The {partName} is completely destroyed!";
        if (healthPercent < 0.15)
            return $"The {partName} is maimed and barely functioning!";
        if (healthPercent < 0.35)
            return $"The {partName} is gravely injured!";
        if (healthPercent < 0.6)
            return $"The {partName} is wounded.";
        if (healthPercent < 0.9)
            return $"The {partName} is lightly injured.";

        return "";
    }

    public static string DescribeCombatStart(Actor player, Actor enemy)
    {
        List<string> possibleStarts = new()
        {
            $"A {enemy.Name} emerges, its {enemy.ActiveWeapon.Name} at the ready!",
            $"A {enemy.Name} appears and prepares to attack!",
            $"You find yourself face to face with a {enemy.Name}!",
            $"A hostile {enemy.Name} blocks your path!",
            $"A {enemy.Name} lunges towards you suddenly!"
        };

        // Add special descriptions for certain enemy types
        if (enemy.Name.Contains("Wolf"))
            possibleStarts.Add("You hear growling as a wolf steps out from the shadows, fangs bared!");
        else if (enemy.Name.Contains("Bear"))
            possibleStarts.Add("A massive bear rears up on its hind legs, letting out a terrifying roar!");
        else if (enemy.Name.Contains("Snake"))
            possibleStarts.Add("A venomous snake rises up, hood flared, ready to strike!");

        return possibleStarts[Utils.RandInt(0, possibleStarts.Count - 1)];
    }
}================================================================================

File: ./Config.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival
{
    public static class Config
    {
        public enum IOType
        {
            Console,
            Web
        }
        public static IOType io = IOType.Console;

        public static double NOTIFY_EXISTING_STATUS_CHANCE = .1;
    }
}
================================================================================

File: ./Environments/Location.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.Environments;

public class Location
{
    public string Name;
    public bool Visited = false;
    public bool IsFound { get; set; } = false;
    public List<Npc> Npcs = [];
    public List<Item> Items = [];
    public List<Container> Containers = [];
    virtual public Zone Parent { get; }
    public List<LocationFeature> Features = [];

    #region Initialization

    public Location(string name, Zone parent)
    {
        Name = name;
        Parent = parent;
        NpcSpawner = new();
        // InitializeNpcs(numNpcs);
    }

    // public static readonly List<string> genericLocationAdjectives = ["", "Old", "Dusty", "Cool", "Breezy", "Quiet", "Ancient", "Ominous", "Sullen", "Forlorn", "Desolate", "Secret", "Hidden", "Forgotten", "Cold", "Dark", "Damp", "Wet", "Dry", "Warm", "Icy", "Snowy", "Frozen"];

    public T? GetFeature<T>() where T : LocationFeature => Features.OfType<T>().FirstOrDefault();

    public void SpawnNpcs(int numNpcs)
    {
        for (int i = 0; i < numNpcs; i++)
        {
            var npc = NpcSpawner.GenerateRandomNpc();
            if (npc is not null)
                Npcs.Add(npc);
        }
    }
    protected virtual NpcSpawner NpcSpawner { get; }


    #endregion Initialization
    public void Interact(Player player)
    {
        Output.WriteLine("You consider heading to the " + Name + "...");
        Output.WriteLine("Do you want to go there? (y/n)");
        if (Input.ReadYesNo())
        {
            player.CurrentLocation = this;
        }
        else
        {
            Output.WriteLine("You decide to stay.");
        }
    }
    public Command<Player> InteractCommand => new("Go to " + Name + (Visited ? " (Visited)" : ""), Interact);
    public double GetTemperature()
    {
        // Get zone's weather temperature (in Fahrenheit)
        double zoneTemp = Parent.Weather.TemperatureInFahrenheit;

        // Start with this base temperature
        double locationTemp = zoneTemp;

        // ------ STEP 1: Apply inherent location modifiers ------
        double overheadCoverage = 0;
        double windProtection = 0;
        var locationType = GetFeature<EnvironmentFeature>();
        if (locationType != null)
        {
            locationTemp += locationType.TemperatureModifier;
            overheadCoverage = locationType.NaturalOverheadCoverage;
            windProtection = locationType.NaturalWindProtection;
        }

        // ------ STEP 2: Apply weather exposure effects ------
        // Wind chill when windy
        double effectiveWindSpeed = 0;
        if (Parent.Weather.WindSpeed > 0.1) // Only significant wind
        {
            effectiveWindSpeed = Parent.Weather.WindSpeed * (1 - windProtection);
            double windSpeedMph = effectiveWindSpeed * 30; // Scale 0-1 to approx mph
            locationTemp = CalculateWindChillNWS(locationTemp, windSpeedMph);
        }

        // Sun warming effects during daytime with clear skies
        double sunIntensity = Parent.Weather.SunlightIntensity;
        double sunExposure = 1 - overheadCoverage;
        // Sun can add up to 10°F on a cold day
        double sunWarming = sunIntensity * sunExposure * 10;

        // Sun effect is more noticeable when cold
        double temperatureAdjustment = sunWarming * Math.Max(0.5, Math.Min(1, (50 - locationTemp) / 30));
        locationTemp += temperatureAdjustment;

        // Precipitation effects
        double precipitation = Parent.Weather.Precipitation;
        precipitation *= 1 - overheadCoverage;
        // todo, determine if this effects temp directly or if we use this elsewhere 
        double precipitationCooling = precipitation * 5; //  simple up to 5°F cooling for now
        locationTemp -= precipitationCooling * (1 - overheadCoverage);

        // ------ STEP 3: Apply shelter effects if present ------
        double insulation = 0;
        var shelter = GetFeature<ShelterFeature>();
        if (shelter != null)
        {
            // Start with minimum temperature a shelter can maintain (in °F)
            double minShelterTemp = 40; // About 4.4°C, what a good shelter can maintain from body heat
            // Calculate warming effect based on insulation quality
            double tempDifference = minShelterTemp - locationTemp;
            insulation = Math.Clamp(shelter.TemperatureInsulation, 0, .9); // cap at 90%
            insulation *= 1 - (precipitation * .3); // precipitation can reduce insulation up to 30%
            insulation *= 1 - (effectiveWindSpeed * .3); // and wind another 30 on top of that

            locationTemp += tempDifference * insulation;
        }

        // If there's a heat source, add its effect
        var heatSource = GetFeature<HeatSourceFeature>();
        if (heatSource != null && heatSource.IsActive)
        {
            // Insulation increases effectiveness of heat sources
            double heatEffect = heatSource.HeatOutput * Math.Max(insulation, .40); // heat sources are less effective outside
            locationTemp += heatEffect;
        }

        return locationTemp;
    }

    public double CalculateWindChillNWS(double temperatureF, double windSpeedMph)
    {
        // NWS formula is only valid for temperatures <= 50°F and wind speeds >= 3 mph
        if (temperatureF > 50 || windSpeedMph < 3)
        {
            return temperatureF;
        }
        // Calculate using the NWS Wind Chill Temperature (WCT) formula
        // https://www.weather.gov/media/epz/wxcalc/windChill.pdf
        // WCT = 35.74 + 0.6215T - 35.75(V^0.16) + 0.4275T(V^0.16)
        // Where T = Air Temperature (°F), V = Wind Speed (mph)
        double windPowFactor = Math.Pow(windSpeedMph, 0.16);
        return 35.74 + (0.6215 * temperatureF) - (35.75 * windPowFactor) + (0.4275 * temperatureF * windPowFactor);
    }

    public void Update()
    {
        // Locations.ForEach(i => i.Update());
        Npcs.ForEach(n => n.Update());
    }

    public override string ToString() => Name;
}================================================================================

File: ./Environments/LocationFeatures.cs/EnvironmentFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class EnvironmentFeature : LocationFeature
{
    public enum LocationType
    {
        OpenPlain,      // No natural shelter
        Forest,         // Trees provide some wind/rain protection
        Cave,           // Natural temperature moderation
        Cliff,          // Wind protection from one direction
        RiverBank,      // Water nearby, but exposure
        HighGround      // More wind but better visibility
    }
    private LocationType Type;
    public double TemperatureModifier { get; } = 0; // degrees F adjustment
    public double NaturalOverheadCoverage { get; } = 0;
    public double NaturalWindProtection { get; } = 0;

    public EnvironmentFeature(Location location, double tempModifier, double overheadCoverage, double windProtection) : base("shelter", location)
    {
        TemperatureModifier = tempModifier;
        NaturalOverheadCoverage = overheadCoverage;
        NaturalWindProtection = windProtection;
    }
    public EnvironmentFeature(Location location, LocationType type)
        : base("locationType", location)
    {
        Type = type;

        switch (type)
        {
            case LocationType.Forest:
                NaturalWindProtection = 0.4;     // 40% wind reduction
                NaturalOverheadCoverage = 0.3;   // 30% precipitation protection
                TemperatureModifier = 3.0;       // 3°F warmer in winter, cooler in summer
                break;

            case LocationType.Cave:
                NaturalWindProtection = 0.9;     // 90% wind protection
                NaturalOverheadCoverage = 0.95;  // 95% precipitation protection
                TemperatureModifier = 15.0;      // 15°F warmer in winter, cooler in summer
                break;

            case LocationType.Cliff:
                NaturalWindProtection = 0.6;     // 60% wind protection
                NaturalOverheadCoverage = 0.2;   // 20% precipitation protection
                TemperatureModifier = 2.0;       // 2°F temperature moderation
                break;

            case LocationType.RiverBank:
                NaturalWindProtection = 0.1;     // 10% wind protection
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -2.0;      // 2°F cooler from water proximity
                break;

            case LocationType.HighGround:
                NaturalWindProtection = -0.2;    // 20% increased wind
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -4.0;      // 4°F cooler from elevation
                break;

            case LocationType.OpenPlain:
            default:
                NaturalWindProtection = 0.0;
                NaturalOverheadCoverage = 0.0;
                TemperatureModifier = 0.0;
                break;
        }
    }

    // Get description of the location type
    public string GetDescription()
    {
        return Type switch
        {
            LocationType.Forest => "A forest with trees providing some shelter from the elements.",
            LocationType.Cave => "A cave offering protection from wind and precipitation.",
            LocationType.Cliff => "A cliff face providing some protection from the wind.",
            LocationType.RiverBank => "The bank of a river, exposed but with access to water.",
            LocationType.HighGround => "Higher elevation with increased exposure to wind.",
            LocationType.OpenPlain => "An open area with no natural protection.",
            _ => "An undefined location type."
        };
    }

}================================================================================

File: ./Environments/LocationFeatures.cs/ForageFeature.cs
--------------------------------------------------------------------------------
﻿using text_survival.Items;

namespace text_survival.Environments;

public class ForageFeature(Location location, double resourceDensity = 1) : LocationFeature("forage", location)
{
    private double baseResourceDensity = resourceDensity;
    private int numberOfHoursForaged = 0;
    private Dictionary<Func<Item>, double> resourceRarities = [];
    private double ResourceDensity => baseResourceDensity / (numberOfHoursForaged + 1);

    public void Forage(int hours)
    {
        // todo: change the order of operations here
        List<Item> itemsFound = [];
        foreach (Func<Item> factory in resourceRarities.Keys)
        {
            double chance = ResourceDensity * resourceRarities[factory];

            for (int i = 0; i < hours; i++)
            {
                if (Utils.DetermineSuccess(chance))
                {
                    var item = factory();
                    item.IsFound = true;
                    ParentLocation.Items.Add(item);
                    numberOfHoursForaged++;
                }
            }
        }
        World.Update(hours * 60);
    }

    public void AddResource(Func<Item> factory, double rarity)
    {
        resourceRarities.Add(factory, rarity);
    }
}
================================================================================

File: ./Environments/LocationFeatures.cs/LocationFeature.cs
--------------------------------------------------------------------------------

using text_survival.Survival;

namespace text_survival.Environments;

public abstract class LocationFeature
{
    public string Name { get; private set; }
    protected Location ParentLocation { get; private set; }
    public LocationFeature(string name, Location location)
    {
        Name = name;
        ParentLocation = location;
    }
    // public virtual void Initialize() { }
    // public virtual void Update() { }
}



================================================================================

File: ./Environments/LocationFeatures.cs/ShelterFeature.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ShelterFeature : LocationFeature
{
    // todo add enums and presets like environment features
    public double TemperatureInsulation { get; } = 0; // ambient temp protection 0-1
    public double OverheadCoverage { get; } = 0; // rain / snow / sun protection 0-1
    public double WindCoverage { get; } = 0; // wind protection 0-1
    // public double Durability {get; private}
    public ShelterFeature(Location location, double tempInsulation, double overheadCoverage, double windCoverage) : base("shelter", location)
    {
        TemperatureInsulation = tempInsulation;
        OverheadCoverage = overheadCoverage;
        WindCoverage = windCoverage;
    }
    
}================================================================================

File: ./Environments/LocationFeatures.cs/HeatSourceFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class HeatSourceFeature : LocationFeature
{
    public bool IsActive { get; private set; }
    public double HeatOutput { get; private set; } // In Fahrenheit
    public double FuelRemaining { get; private set; } // 0-1 scale
    public double FuelConsumptionRate { get; private set; } // Per hour
    
    public HeatSourceFeature(Location location, double heatOutput = 15.0) 
        : base("heatSource", location)
    {
        IsActive = false;
        HeatOutput = heatOutput; // Default 15°F increase
        FuelRemaining = 0;
        FuelConsumptionRate = 0.1; // 10% per hour
    }
    
    public void AddFuel(double amount)
    {
        FuelRemaining = Math.Min(1.0, FuelRemaining + amount);
        
        // Activate if adding fuel to inactive source
        if (!IsActive && FuelRemaining > 0)
            IsActive = true;
    }
    
    // Update for fuel consumption
    public void Update(TimeSpan elapsed)
    {
        if (!IsActive || FuelRemaining <= 0)
            return;
            
        // Calculate fuel consumption
        double hoursElapsed = elapsed.TotalHours;
        double fuelUsed = FuelConsumptionRate * hoursElapsed;
        
        FuelRemaining = Math.Max(0, FuelRemaining - fuelUsed);
        
        // Deactivate if out of fuel
        if (FuelRemaining <= 0)
            IsActive = false;
    }
    
    // Manually activate/deactivate
    public void SetActive(bool active)
    {
        // Can only activate if there's fuel
        if (active && FuelRemaining > 0)
            IsActive = true;
        else if (!active)
            IsActive = false;
    }
}================================================================================

File: ./Environments/Zone.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class Zone
    {
        public string Name { get; }
        public string Description { get; }
        public bool Visited = false;
        private double BaseTemperature { get; }
        public int Elevation { get; }
        public virtual List<Location> Locations { get; } = [];
        private LocationTable LocationTable;
        public ZoneWeather Weather;


        public Zone(string name, string description, LocationTable locationTable, double baseTemp = 20, int elevation = 0)
        {
            Name = name;
            Description = description;
            BaseTemperature = baseTemp;
            Elevation = elevation;
            LocationTable = locationTable;
            Weather = new(this);
            if (!LocationTable.IsEmpty())
            {
                for (int i = 0; i < 3; i++)
                {
                    Locations.Add(LocationTable.GenerateRandom(this));
                }
            }

        }

        public void Update()
        {
            Locations.ForEach(x => x.Update());
        }

        public override string ToString() => Name;

    }
}
================================================================================

File: ./Environments/WorldMap.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class WorldMap
    {
        private Dictionary<(int, int), Zone> map = new();

        private int X;
        private int Y;

        public WorldMap(Zone startingZone)
        {
            X = 0;
            Y = 0;
            map.Add((X, Y), startingZone);
            startingZone.Visited = true;
        }

        public Zone CurrentZone => GetZone(X, Y);
        public Zone North => GetZone(X, Y + 1);
        public Zone South => GetZone(X, Y - 1);
        public Zone East => GetZone(X + 1, Y);
        public Zone West => GetZone(X - 1, Y);


        public void MoveNorth() => MoveTo(X, Y + 1);
        public void MoveSouth() => MoveTo(X, Y - 1);
        public void MoveEast() => MoveTo(X + 1, Y);
        public void MoveWest() => MoveTo(X - 1, Y);


        private void MoveTo(int x, int y)
        {
            Zone zone = GetZone(x, y) ?? throw new Exception("Invalid zone.");
            X = x;
            Y = y;
            zone.Visited = true;
        }

        private Zone GetZone(int x, int y)
        {
            Zone? zone = map.GetValueOrDefault((x, y));
            if (zone == null)
            {
                zone = GenerateRandomZone();
                map.Add((x, y), zone);
            }
            return zone;
        }

        private Zone GenerateRandomZone()
        {
            // todo
            return Utils.GetRandomFromList([ZoneFactory.MakeForestZone(), ZoneFactory.MakeCaveSystemZone()]);
        }

    }
}
================================================================================

File: ./Environments/ZoneFactory.cs
--------------------------------------------------------------------------------
namespace text_survival.Environments;

public static class ZoneFactory
{
    public static Zone MakeForestZone(string name = "", string description = "", double baseTemp = 20)
    {
        // Create a location table specifically for forest locations
        LocationTable forestLocationTable = new LocationTable();
        
        // Add various forest location types with appropriate weights
        forestLocationTable.AddFactory(LocationFactory.MakeForest, 3.0); // Most common
        
        // You can add more forest-related locations here when implemented
        // forestLocationTable.AddFactory(LocationFactory.MakeTrail, 2.0);
        // forestLocationTable.AddFactory(LocationFactory.MakeRiverbank, 1.5);
        // forestLocationTable.AddFactory(LocationFactory.MakeHillside, 1.0);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> forestZoneNames = ["Forest", "Woods", "Woodland", "Taiga", "Wildwood", "Timberland", "Pine Forest", "Birch Forest"];
            List<string> forestZoneAdjectives = [
                "", "Deep", "Ancient", "Verdant", "Mysterious", "Shadowy", "Enchanted", "Wild", "Dark", "Dense", 
                "Northern", "Southern", "Eastern", "Western", "Frozen", "Boreal", "Glacial", "Snowy", "Frost-rimmed", 
                "Ice-laden", "Primeval", "Rime-covered", "Mammoth", "Misty", "Foggy"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(forestZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(forestZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> forestDescriptions = [
                "A vast expanse of snow-covered trees stretching as far as the eye can see.",
                "Frost-covered trees with icicles hanging from branches, filtering weak sunlight to the forest floor.",
                "A quiet forest with the occasional sounds of wildlife echoing through the icy stillness.",
                "Evergreen trees stand tall amidst the snow, creating a sanctuary for cold-adapted creatures.",
                "A sprawling woodland with ice-crusted paths winding between ancient trees and frozen undergrowth.",
                "Mammoth trails wind between the massive tree trunks, where herds seek shelter from the harsh winds.",
                "Rime-covered trees glisten in the pale light, their branches laden with snow and ice.",
                "The forest floor is covered with a thick blanket of snow, punctuated by animal tracks.",
                "Shadows stretch long across the pristine snow as sunlight filters through the dense canopy.",
                "Ancient pines stand as sentinels, their needles heavy with frost and snow."
            ];
            
            description = Utils.GetRandomFromList(forestDescriptions);
        }
        
        // Create and return the forest zone
        return new Zone(name, description, forestLocationTable, baseTemp);
    }
    
    public static Zone MakeCaveSystemZone(string name = "", string description = "", double baseTemp = 10)
    {
        // Create a location table specifically for cave system locations
        LocationTable caveLocationTable = new LocationTable();
        
        // Add various cave location types with appropriate weights
        caveLocationTable.AddFactory(LocationFactory.MakeCave, 3.0); // Most common
        
        // You can add more cave-related locations here when implemented
        // caveLocationTable.AddFactory(LocationFactory.MakeTrail, 1.0); // Cave entrance trails
        // caveLocationTable.AddFactory(LocationFactory.MakeHillside, 1.5); // Cave entrances in hillsides
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> caveZoneNames = [
                "Cave System", "Caverns", "Underground Complex", "Grotto Network", "Subterranean Labyrinth",
                "Cave Refuge", "Ice Caverns", "Shelter System", "Hibernation Caves", "Painted Caves"
            ];
            List<string> caveZoneAdjectives = [
                "", "Deep", "Ancient", "Crystal", "Mysterious", "Dark", "Echoing", "Forgotten", "Hidden", "Vast", "Winding",
                "Frost-lined", "Ice-walled", "Glacial", "Ancestral", "Bone-filled", "Mammoth", "Protected", "Ritual",
                "Clan", "Fur-lined", "Warm", "Painted", "Firelit"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(caveZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(caveZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> caveDescriptions = [
                "A maze of dark tunnels and chambers offering refuge from the harsh ice age climate.",
                "A network of interconnected caves with icicles and ice formations hanging from the ceiling.",
                "Warm, sheltered caverns with the sound of meltwater dripping echoing in the darkness.",
                "An intricate system of underground passages formed by ancient glacial movements.",
                "A sprawling subterranean network with chambers used by clans for shelter and ritual.",
                "Cave walls adorned with ancient paintings depicting mammoth hunts and clan ceremonies.",
                "Floors littered with bones and artifacts from generations of human habitation.",
                "Narrow passages opening to large chambers where fires have burned for countless seasons.",
                "Ancestral shelters where generations have found protection from the deadly cold.",
                "Ice-rimmed entrances leading to surprisingly warm chambers deep within the earth."
            ];
            
            description = Utils.GetRandomFromList(caveDescriptions);
        }
        
        // Create and return the cave system zone with cooler base temperature
        return new Zone(name, description, caveLocationTable, baseTemp);
    }
    
    public static Zone MakeTundraZone(string name = "", string description = "", double baseTemp = 0)
    {
        // Create a location table specifically for tundra locations
        LocationTable tundraLocationTable = new LocationTable();
        
        // Add various tundra location types with appropriate weights
        tundraLocationTable.AddFactory(LocationFactory.MakePlain, 4.0); // Most common
        // tundraLocationTable.AddFactory(LocationFactory.MakeHillside, 2.0);
        // tundraLocationTable.AddFactory(LocationFactory.MakeRiverbank, 1.5);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> tundraZoneNames = [
                "Tundra", "Steppe", "Plains", "Mammoth Plains", "Permafrost", "Ice Fields", 
                "Frozen Expanse", "Glacier Edge", "Frost Plains", "Hunting Grounds"
            ];
            List<string> tundraZoneAdjectives = [
                "", "Vast", "Windswept", "Endless", "Frozen", "Desolate", "Barren", "Ancient", 
                "Mammoth", "Glacial", "Northern", "Pristine", "Inhospitable", "Snow-covered", 
                "Primal", "Harsh", "Woolly", "Thundering", "Game-rich", "Megafauna"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(tundraZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(tundraZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> tundraDescriptions = [
                "An endless expanse of snow and ice, where mighty herds of woolly mammoth roam.",
                "Windswept plains stretching to the horizon, where only the hardiest plants survive.",
                "Wide open spaces where great herds of ice age megafauna gather to graze.",
                "A harsh landscape dominated by permafrost and spotted with patches of tough grasses.",
                "Snow-covered plains where saber-toothed predators stalk their mammoth prey.",
                "Vast open tundra where the wind howls unimpeded across the frozen landscape.",
                "The thunder of mammoth herds can be heard across these ancient hunting grounds.",
                "A stark but beautiful landscape of ice, snow, and occasional hardy vegetation.",
                "Glacial plains carved by the retreating ice sheet, leaving a harsh but life-filled realm.",
                "The domain of the woolly mammoth, where these giants travel in family groups across the snow."
            ];
            
            description = Utils.GetRandomFromList(tundraDescriptions);
        }
        
        // Create and return the tundra zone with much colder base temperature
        return new Zone(name, description, tundraLocationTable, baseTemp);
    }
    
    public static Zone MakeRiverValleyZone(string name = "", string description = "", double baseTemp = 15)
    {
        // Create a location table specifically for river valley locations
        LocationTable riverValleyLocationTable = new LocationTable();
        
        // Add various river valley location types with appropriate weights
        riverValleyLocationTable.AddFactory(LocationFactory.MakeRiverbank, 4.0); // Most common
        // riverValleyLocationTable.AddFactory(LocationFactory.MakeForest, 2.0); // Riverside forests
        // riverValleyLocationTable.AddFactory(LocationFactory.MakeHillside, 1.5); // Valley sides
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> riverZoneNames = [
                "River Valley", "Waterway", "Glacial Valley", "River Basin", "Floodplain", 
                "Stream Network", "River Lands", "Meltwater Valley", "River Territory"
            ];
            List<string> riverZoneAdjectives = [
                "", "Winding", "Frozen", "Ancient", "Deep", "Fertile", "Ice-carved", "Glacier-fed", 
                "Protected", "Sheltered", "Resource-rich", "Fish-filled", "Life-giving", "Abundant",
                "Clay-rich", "Game-rich", "Meandering", "Mammoth-crossed"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(riverZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(riverZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> riverDescriptions = [
                "A network of glacier-fed rivers and streams cutting through the icy landscape.",
                "Partially frozen waterways that provide essential resources for all life in the region.",
                "A river valley carved by ancient glacial movements, now home to diverse ice age life.",
                "Ice-rimmed waters flowing through a sheltered valley, attracting animals from miles around.",
                "A life-giving river system where clay, fish, and fresh water can be harvested.",
                "Mammoth herds gather along these banks to drink and bathe in the cold waters.",
                "The sound of rushing water breaks the winter silence as the river cuts through ice and snow.",
                "A critical resource in the frozen world, this river network sustains countless creatures.",
                "Ancient humans have left traces of their camps along these fertile riverbanks for generations.",
                "Where ice meets flowing water, creating a unique ecosystem in the frozen landscape."
            ];
            
            description = Utils.GetRandomFromList(riverDescriptions);
        }
        
        // Create and return the river valley zone with slightly warmer base temperature
        return new Zone(name, description, riverValleyLocationTable, baseTemp);
    }
    
    // // Method to create a complete ice age world with multiple zones
    // public static List<Zone> CreateIceAgeWorld()
    // {
    //     List<Zone> world = new List<Zone>();
        
    //     // Create various zones with ice age appropriate base temperatures
    //     Zone forestZone = MakeForestZone(baseTemp: 10); // Colder than default
    //     world.Add(forestZone);
        
    //     Zone caveZone = MakeCaveSystemZone(baseTemp: 5); // Even colder caves
    //     world.Add(caveZone);
        
    //     Zone tundraZone = MakeTundraZone(); // Already very cold (0)
    //     world.Add(tundraZone);
        
    //     Zone riverValleyZone = MakeRiverValleyZone(baseTemp: 8); // Slightly warmer than surroundings but still cold
    //     world.Add(riverValleyZone);
        
    //     return world;
    // }
}================================================================================

File: ./Environments/Weather.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ZoneWeather
{

    // todo: improve sunrise and sunset logic,
    // todo: add more continuity and state to more granular changes
    public double BaseTemperature { get; private set; } // In Celsius
    public WeatherCondition CurrentCondition { get; private set; }
    public double Precipitation { get; private set; } // 0-1 intensity
    public double WindSpeed { get; private set; }    // 0-1 intensity
    public double CloudCover { get; private set; }   // 0-1 coverage

    // Season tracking
    public enum Season { Winter, Spring, Summer, Fall }
    public Season CurrentSeason { get; private set; } = Season.Fall; // Start in fall

    // Weather conditions for Ice Age Europe
    public enum WeatherCondition
    {
        Clear,      // Clear, cold skies
        Cloudy,     // Overcast conditions
        Misty,      // Low visibility with moisture
        LightSnow,  // Light snowfall (common in Ice Age)
        Rainy,      // Cold rain (uncommon but possible)
        Blizzard,   // Heavy snow with wind (dangerous)
        Stormy      // Thunderstorms (rare, mostly summer)
    }

    // Add to ZoneWeather class
    public double SunlightIntensity
    {
        get
        {
            // No sun at night
            if (!IsDaytime())
                return 0;

            // Base sun intensity from time of day
            double timeOfDayFactor = GetSunIntensityByTime();

            // Reduction factors from weather conditions
            double cloudReduction = CloudCover * 0.9; // Clouds block up to 90% of sunlight

            // Additional reduction based on weather condition
            double conditionReduction = CurrentCondition switch
            {
                WeatherCondition.Misty => 0.6,
                WeatherCondition.Blizzard => 0.9,
                WeatherCondition.LightSnow => 0.3,
                WeatherCondition.Rainy => 0.5,
                WeatherCondition.Stormy => 0.8,
                _ => 0.0
            };
            // Calculate final intensity (0-1)
            double baseIntensity = timeOfDayFactor * (1 - cloudReduction);
            return baseIntensity * (1 - conditionReduction);
        }
    }

    private bool IsDaytime()
    {
        // todo: flesh this out and combine it with the temperature cycle 
        int hour = World.Time.Hour;

        // Seasonal variation in daylight hours
        int sunriseHour, sunsetHour;

        switch (CurrentSeason)
        {
            case Season.Winter:
                sunriseHour = 8;  // Late sunrise
                sunsetHour = 16;  // Early sunset
                break;
            case Season.Spring:
            case Season.Fall:
                sunriseHour = 6;  // Normal sunrise
                sunsetHour = 18;  // Normal sunset
                break;
            case Season.Summer:
                sunriseHour = 4;  // Early sunrise
                sunsetHour = 20;  // Late sunset
                break;
            default:
                sunriseHour = 6;
                sunsetHour = 18;
                break;
        }

        return hour >= sunriseHour && hour < sunsetHour;
    }

    private double GetSunIntensityByTime()
    {
        // Get sun intensity purely based on time of day (0-1)
        int hour = World.Time.Hour;
        int minute = World.Time.Minute;

        // No sunlight before sunrise or after sunset
        if (!IsDaytime())
            return 0;

        // Convert to minutes since sunrise (0-720)
        double minutesSinceSunrise = ((hour - 6) * 60) + minute;
        double dayLengthMinutes = 12 * 60; // 12 hours of daylight

        // Calculate angle for sine function (0 to π over the day)
        double angle = (minutesSinceSunrise / dayLengthMinutes) * Math.PI;

        // Sine wave peaks at noon (6 hours after sunrise)
        return Math.Sin(angle);
    }

    // Time and update tracking
    private TimeSpan _weatherDuration;
    private TimeSpan _timeSinceChange = TimeSpan.Zero;

    // Zone this weather belongs to
    private Zone _zone;

    public ZoneWeather(Zone zone)
    {
        _zone = zone;

        // Initialize with fall weather
        BaseTemperature = 0; // 0°C is about 32°F - freezing point
        CurrentCondition = WeatherCondition.Clear;
        Precipitation = 0;
        WindSpeed = 0.3; // Moderate wind - 30% of maximum
        CloudCover = 0.3; // Light clouds - 30% coverage

        _weatherDuration = TimeSpan.FromHours(6);
    }

    public void Update(TimeSpan elapsed)
    {
        _timeSinceChange += elapsed;

        // Time to change weather?
        if (_timeSinceChange >= _weatherDuration)
        {
            GenerateNewWeather();
            _timeSinceChange = TimeSpan.Zero;
        }
    }

    private void GenerateNewWeather()
    {
        // Generate new weather conditions based on season and zone
        // Determine base temperature range for season
        double minTemp, maxTemp;
        double precipChance;
        double snowRatio; // Chance of precipitation being snow vs rain

        switch (CurrentSeason)
        {
            case Season.Winter:
                minTemp = -30; // -30°C (-22°F) extreme winter low
                maxTemp = -5;  // -5°C (23°F) winter "warm" day
                precipChance = 0.2; // 20% chance of precipitation
                snowRatio = 0.95;   // 95% of precip is snow in winter
                break;

            case Season.Spring:
                minTemp = -15; // -15°C (5°F) cold spring night
                maxTemp = 5;   // 5°C (41°F) mild spring day
                precipChance = 0.25; // 25% chance of precipitation
                snowRatio = 0.6;    // 60% of precip is snow in spring
                break;

            case Season.Summer:
                minTemp = -5;  // -5°C (23°F) cold summer night
                maxTemp = 15;  // 15°C (59°F) warm summer day
                precipChance = 0.15; // 15% chance of precipitation
                snowRatio = 0.2;    // 20% of precip is snow in summer
                break;

            case Season.Fall:
                minTemp = -10; // -10°C (14°F) cold fall night
                maxTemp = 5;   // 5°C (41°F) mild fall day
                precipChance = 0.2;  // 20% chance of precipitation
                snowRatio = 0.7;    // 70% of precip is snow in fall
                break;

            default:
                minTemp = -15;
                maxTemp = 0;
                precipChance = 0.2;
                snowRatio = 0.8;
                break;
        }

        // Apply zone-specific modifications
        if (_zone.Elevation > 0)
        {
            // Higher elevation = colder (-0.6°C per 100m elevation)
            double elevationEffect = _zone.Elevation * -0.006; // -0.6% per 100m
            minTemp += elevationEffect;
            maxTemp += elevationEffect;
        }

        // Get time of day temperature modifier (0-1 scale)
        double timeOfDayFactor = GetTimeOfDayFactor();

        // Calculate random temperature within range, biased toward colder
        // For example: With Spring (-15°C to 5°C) at noon (factor=1.0):
        // Temperature range = -15 + (5-(-15)) * random(0,0.8) * 1.0 = -15 to +1°C
        double temperatureRange = maxTemp - minTemp;
        double randomFlux = Utils.RandDouble(0, 1);

        BaseTemperature = minTemp + (temperatureRange * randomFlux * timeOfDayFactor);

        // Determine weather condition
        if (Utils.RandDouble(0, 1) < precipChance) // Precipitation check (0.15-0.25 chance)
        {
            // Determine type of precipitation
            double snowVsRainRoll = Utils.RandDouble(0, 1);

            if (snowVsRainRoll < snowRatio) // Snow event
            {
                // Determine if blizzard (rare) or light snow (common)
                if (Utils.RandDouble(0, 1) < 0.15) // 15% of snow events are blizzards
                {
                    CurrentCondition = WeatherCondition.Blizzard;
                    Precipitation = Utils.RandDouble(0.7, 1.0); // 70-100% intensity
                    WindSpeed = Utils.RandDouble(0.7, 1.0);     // 70-100% of max wind
                    CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                }
                else
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.6); // 20-60% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.5);     // 20-50% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
                }
            }
            else // Rain event (uncommon in Ice Age)
            {
                // Only happens when temperature is above freezing
                if (BaseTemperature > 0)
                {
                    // Determine if stormy (very rare) or rainy
                    if (CurrentSeason == Season.Summer && Utils.RandDouble(0, 1) < 0.1) // 10% of summer rain is storms
                    {
                        CurrentCondition = WeatherCondition.Stormy;
                        Precipitation = Utils.RandDouble(0.6, 0.9); // 60-90% intensity
                        WindSpeed = Utils.RandDouble(0.5, 0.8);     // 50-80% of max wind
                        CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(2); // 1-3 hours
                    }
                    else
                    {
                        CurrentCondition = WeatherCondition.Rainy;
                        Precipitation = Utils.RandDouble(0.3, 0.6); // 30-60% intensity
                        WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                        CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                    }
                }
                else // Temperature too cold for rain, adjust to snow
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.5); // 20-50% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(5); // 1-9 hours
                }
            }
        }
        else // No precipitation
        {
            // Choose between clear, cloudy or misty
            double clearVsCloudyRoll = Utils.RandDouble(0, 1);

            if (clearVsCloudyRoll < 0.4) // 40% chance for clear
            {
                CurrentCondition = WeatherCondition.Clear;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.1, 0.5);     // 10-50% of max wind
                CloudCover = Utils.RandDouble(0, 0.2);      // 0-20% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(9); // 1-17 hours
            }
            else if (clearVsCloudyRoll < 0.8) // 40% chance for cloudy
            {
                CurrentCondition = WeatherCondition.Cloudy;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.2, 0.6);     // 20-60% of max wind
                CloudCover = Utils.RandDouble(0.5, 0.8);    // 50-80% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
            }
            else // 20% chance for misty
            {
                CurrentCondition = WeatherCondition.Misty;
                Precipitation = Utils.RandDouble(0, 0.1);   // 0-10% light moisture
                WindSpeed = Utils.RandDouble(0, 0.2);       // 0-20% of max wind
                CloudCover = Utils.RandDouble(0.6, 0.9);    // 60-90% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(3); // 1-5 hours
            }
        }
    }

    private TimeSpan GenerateRandomWeatherDuration(int typicalHours = 6)
    {
        // int minHours = 1; // using roll instead which has 1 as default
        int maxHours = (typicalHours * 2) - 1;

        // triangular distribution - similar to normal dist, 
        // where values in the center are more common and extremes are rare
        // kind of like rolling dice, it's rare to roll 3 ones or 3 sixes
        int r1 = Utils.Roll(maxHours);
        int r2 = Utils.Roll(maxHours);
        int r3 = Utils.Roll(maxHours);
        double sum = r1 + r2 + r3;
        double average = sum / 3.0;
        int minutes = (int)(average * 60);
        return TimeSpan.FromMinutes(minutes);
    }

    private double GetTimeOfDayFactor()
    {
        // Returns 0-1 value representing relative temperature (0=coldest, 1=warmest)
        // todo combine this with seasonal day/ night lengths
        int minutesInDay = 24 * 60;
        int coldestTime = 4 * 60; // 4 AM

        int currentMinute = World.Time.Hour * 60 + World.Time.Minute;
        double minSinceColdest = currentMinute - coldestTime;
        double percentOfDay = minSinceColdest / minutesInDay; // scale so .5 is warmest and 0/1 is coldest
        double radians = 2 * Math.PI * percentOfDay; // scale for Cos

        // cos(x) => -1 to 1, but we need to shift to 0-1 so divide by 2 and shift up by 
        // but also the cos function needs to be flipped since cos(0 or 1) = 1, but we want 0 and 1 to be the min, so just * -1
        double temperature = -1 * (Math.Cos(radians) / 2) + .5; // Cos results in -1 to 1, so scale to 0-1 (divide 2, shift)

        return temperature;
    }

    // Convert Celsius to Fahrenheit
    public double TemperatureInFahrenheit => (BaseTemperature * 9 / 5) + 32;

    // Get detailed weather description
    public string GetWeatherDescription()
    {
        string temp = GetTemperatureDescription();
        string conditions = GetConditionsDescription();
        string wind = GetWindDescription();

        return $"{temp} {conditions} {wind}";
    }

    private string GetTemperatureDescription()
    {
        if (BaseTemperature < -25)
            return "It's brutally cold.";
        else if (BaseTemperature < -15)
            return "It's extremely cold.";
        else if (BaseTemperature < -5)
            return "It's very cold.";
        else if (BaseTemperature < 0)
            return "It's freezing cold.";
        else if (BaseTemperature < 5)
            return "It's cold.";
        else if (BaseTemperature < 10)
            return "It's cool.";
        else
            return "It's mild."; // As warm as it gets in Ice Age
    }

    private string GetConditionsDescription()
    {
        switch (CurrentCondition)
        {
            case WeatherCondition.Clear:
                return "The sky is clear.";

            case WeatherCondition.Cloudy:
                return "The sky is cloudy and gray.";

            case WeatherCondition.Misty:
                return "A cold mist hangs in the air.";

            case WeatherCondition.Rainy:
                if (Precipitation < 0.5)
                    return "A cold drizzle is falling.";
                else
                    return "Cold rain is falling steadily.";

            case WeatherCondition.LightSnow:
                if (Precipitation < 0.3)
                    return "A few snowflakes drift through the air.";
                else
                    return "Snow is falling steadily.";

            case WeatherCondition.Blizzard:
                return "A blizzard rages with heavy snow and wind.";

            case WeatherCondition.Stormy:
                return "A thunderstorm rumbles overhead.";

            default:
                return "";
        }
    }

    private string GetWindDescription()
    {
        if (WindSpeed < 0.2)           // 0-20%
            return "The air is still.";
        else if (WindSpeed < 0.4)      // 20-40%
            return "A light breeze blows.";
        else if (WindSpeed < 0.6)      // 40-60%
            return "A cold wind blows steadily.";
        else if (WindSpeed < 0.8)      // 60-80%
            return "Strong, bitter winds howl across the landscape.";
        else                           // 80-100%
            return "Powerful, freezing gusts threaten to knock you over.";
    }

    // Set season
    public void SetSeason(Season season)
    {
        CurrentSeason = season;
        GenerateNewWeather(); // Update weather for new season
    }
}


================================================================================

File: ./Environments/LocationFactory.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;
using text_survival.Survival;

namespace text_survival.Environments;

public static class LocationFactory
{
    public static Location MakeForest(Zone parent)
    {
        // Create a base forest location
        Location location = new Location("Forest", parent);
        
        // Generate a more descriptive name with ice age theme
        List<string> forestNames = ["Forest", "Woodland", "Grove", "Thicket", "Pine Stand", "Birch Grove"];
        List<string> forestAdjectives = [
            "Frost-bitten", "Snow-laden", "Ice-coated", "Permafrost", "Glacial", "Silent", "Frozen", "Snowy",
            "Windswept", "Frigid", "Boreal", "Primeval", "Shadowy", "Ancient", "Taiga", 
             "Frosty", "Dark", "Foggy", "Overgrown",
            "Dense", "Old", "Misty", "Quiet", "Pristine", "Forgotten", "Cold", "Verdant", "Mossy", "Wet"
        ];
        
        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(forestAdjectives);
        string name = Utils.GetRandomFromList(forestNames);
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with high resource density for forests (1.2)
        ForageFeature forageFeature = new ForageFeature(location, 1.2);
        
        // Add natural resources to the forage feature - more forest-appropriate items
        forageFeature.AddResource(ItemFactory.MakeBerry, 5.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeWater, 2.0);     // Available but not as common
        forageFeature.AddResource(ItemFactory.MakeMushroom, 4.0);  // Common in forests
        forageFeature.AddResource(ItemFactory.MakeStick, 8.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFirewood, 4.0);   // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 3.0);     // Fairly common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for forest
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Forest));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomForestItem();
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);   // Common
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Rare
        
        // Determine if we should add NPCs initially (40% chance)
        if (Utils.RandInt(0, 9) < 4)
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            for (int i = 0; i < npcCount; i++)
            {
                location.Npcs.Add(npcSpawner.GenerateRandom());
            }
        }
        
        return location;
    }
    
    public static Location MakeCave(Zone parent)
    {
        // Create a base cave location
        Location location = new Location("Cave", parent);
        
        // Generate a more descriptive name with ice age theme
        List<string> caveNames = ["Cave", "Cavern", "Grotto", "Hollow", "Shelter"];
        List<string> caveAdjectives = [
            "Icicle-lined", "Frost-rimmed", "Ice-floored", "Bone-strewn", "Mammoth-bone", "Winding", "Ancient", 
            "Hidden", "Ancestral", "Painted", "Rocky", "Echoing", "Ice-walled", "Hibernation", 
            "Crystal-ice", "Glacier-carved", "Frosty", "Icy",
            "Dark", "Shadowy", "Damp", "Deep", "Frozen", "Narrow", "Secluded", 
            "Granite",  "Glowing",  "Cold", "Crystal", "Protected"
        ];
        
        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(caveAdjectives);
        string name = Utils.GetRandomFromList(caveNames);
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with moderate resource density for caves (0.8)
        ForageFeature forageFeature = new ForageFeature(location, 0.8);
        
        // Add resources to the forage feature - cave-appropriate items
        forageFeature.AddResource(ItemFactory.MakeMushroom, 3.0);  // Can find mushrooms in caves
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 2.0);     // More common in caves
        forageFeature.AddResource(ItemFactory.MakeClay, 1.0);      // Near cave entrances
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.3); // Rare but valuable
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for cave
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cave));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomCaveItem();
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeSpider, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeRat, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeBat, 4.0);
        npcSpawner.AddActor(NpcFactory.MakeCaveBear, 0.5);
        
        // Determine if we should add NPCs initially (50% chance)
        if (Utils.RandInt(0, 9) < 5)
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            for (int i = 0; i < npcCount; i++)
            {
                location.Npcs.Add(npcSpawner.GenerateRandom());
            }
        }
        
        return location;
    }
    
    public static Location MakeRiverbank(Zone parent)
    {
        // Create a base riverbank location
        Location location = new Location("Riverbank", parent);
        
        // Generate a more descriptive name with ice age theme
        List<string> riverNames = ["River", "Stream", "Creek", "Brook", "Rapids", "Ford", "Ice-Melt", "Waterfall", "Shallows"];
        List<string> riverAdjectives = [
            "Ice-rimmed", "Glacial", "Snowmelt", "Half-frozen", "Ice-flow", "Narrow", "Mammoth-crossing",
            "Frozen-edged", "Icy", "Slush-filled", "Ice-bridged", "Cold", "Mist-shrouded", "Foggy", "Glacier-fed", 
            "Thawing", "Crystalline", "Ice-dammed", "Frigid", "Quiet", "Thundering", "Bone-strewn", "Glistening",
            "Rushing", "Flowing", "Clear", "Muddy", "Wide", "Rocky", "Sandy", "Shallow", "Deep",
            "Misty", "Meandering", "Winding", "Fast-flowing", "Gentle", "Noisy", "Bubbling"
        ];
        
        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(riverAdjectives);
        string name = Utils.GetRandomFromList(riverNames);
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with good resource density for riverbanks (1.1)
        ForageFeature forageFeature = new ForageFeature(location, 1.1);
        
        // Add resources to the forage feature - river-appropriate items
        forageFeature.AddResource(ItemFactory.MakeWater, 10.0);    // Very abundant
        forageFeature.AddResource(ItemFactory.MakeFish, 6.0);      // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 4.0);     // Common near water
        forageFeature.AddResource(ItemFactory.MakeClay, 5.0);      // Common at riverbanks
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // River stones
        forageFeature.AddResource(ItemFactory.MakeFlint, 1.0);     // Occasionally found
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for riverbank
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.RiverBank));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomRiverbankItem();
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner for riverbanks
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 2.0);   // Predators come to water
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Bears fish at rivers
        
        // Determine if we should add NPCs initially (30% chance)
        if (Utils.RandInt(0, 9) < 3)
        {
            location.Npcs.Add(npcSpawner.GenerateRandom());
        }
        
        return location;
    }
    
    public static Location MakePlain(Zone parent)
    {
        // Create a base plains location
        Location location = new Location("Plain", parent);
        
        // Generate a more descriptive name with ice age theme
        List<string> plainNames = ["Plain", "Steppe", "Tundra", "Mammoth Grounds", "Permafrost", "Glacier-edge", "Grassland", "Prairie", "Meadow"];
        List<string> plainAdjectives = [
            "Windswept", "Permafrost", "Glacial", "Frozen", "Vast", "Rolling", "Endless", "Mammoth-trampled",
            "Snow-covered", "Ice-plain", "Desolate", "Frosty", "Exposed", "Bison-grazed", 
            "Bleak", "Stark", "Harsh", "Woolly", "Flat", "Frost-cracked", "Mammoth",
            "Open", "Windy", "Cold", "Barren", "Grassy", "Empty", "Rocky", "Wild"
        ];
        
        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(plainAdjectives);
        string name = Utils.GetRandomFromList(plainNames);
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with low-moderate resource density for plains (0.7)
        ForageFeature forageFeature = new ForageFeature(location, 0.7);
        
        // Add resources to the forage feature - plains-appropriate items
        forageFeature.AddResource(ItemFactory.MakeRoots, 6.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeBerry, 2.0);     // Less common
        forageFeature.AddResource(ItemFactory.MakeStick, 1.0);     // Rare (few trees)
        forageFeature.AddResource(ItemFactory.MakeStone, 4.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for open plain
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.OpenPlain));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomPlainsItem();
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner - plains have megafauna!
        var npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);               // Common
        npcSpawner.AddActor(NpcFactory.MakeWoollyMammoth, 0.5);      // Rare but possible
        npcSpawner.AddActor(NpcFactory.MakeSaberToothTiger, 0.7);    // Uncommon
        
        // Determine if we should add NPCs initially (40% chance)
        if (Utils.RandInt(0, 9) < 4)
        {
            location.Npcs.Add(npcSpawner.GenerateRandom());
        }
        
        return location;
    }
    
    public static Location MakeHillside(Zone parent)
    {
        // Create a base hillside location
        Location location = new Location("Hillside", parent);
        
        // Generate a more descriptive name with ice age theme
        List<string> hillNames = ["Ridge", "Moraine", "Slope", "Drift", "Crag", "Bluff", "Outcrop", "Hill", "Hillside", "Knoll"];
        List<string> hillAdjectives = [
            "Glacier-carved", "Ice-cracked", "Snow-swept", "Wind-scoured", "Ice-exposed", "Frost-heaved", "Craggy",
            "Rugged", "Snow-capped", "Icy", "Ice-scarred", "Stone", "High", "Misty", "Frost-shattered", 
            "Eroded", "Ancient", "Mammoth-trail", "Granite", "Shaded", "Splintered",
            "Rocky", "Steep", "Gentle", "Windswept", "Exposed", "Barren", "Weathered", 
            "Protected", "Treacherous", "Cold", "Foggy"
        ];
        
        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(hillAdjectives);
        string name = Utils.GetRandomFromList(hillNames);
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with moderate resource density for hillsides (0.9)
        ForageFeature forageFeature = new ForageFeature(location, 0.9);
        
        // Add resources to the forage feature - hillside-appropriate items
        forageFeature.AddResource(ItemFactory.MakeStone, 8.0);        // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 3.0);        // More common on hillsides
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.5); // Rare but possible
        forageFeature.AddResource(ItemFactory.MakeRoots, 2.0);         // Less common
        forageFeature.AddResource(ItemFactory.MakeOchrePigment, 1.0);  // Sometimes found on hills
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for hillside (using cliff as closest match)
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cliff));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomHillsideItem();
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner for hillsides
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 2.0);    // Snakes like rocky areas
        
        // Determine if we should add NPCs initially (30% chance)
        if (Utils.RandInt(0, 9) < 3)
        {
            location.Npcs.Add(npcSpawner.GenerateRandom());
        }
        
        return location;
    }
    
    // Helper methods to generate random location-appropriate items
    
    private static Item GetRandomForestItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 5.0 },
            { ItemFactory.MakeBerry, 4.0 },
            { ItemFactory.MakeStick, 8.0 },
            { ItemFactory.MakeFirewood, 5.0 },
            { ItemFactory.MakeTorch, 0.5 },
            { ItemFactory.MakeSpear, 0.2 },
            { ItemFactory.MakeHealingHerbs, 1.0 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomCaveItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 4.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 3.0 },
            { ItemFactory.MakeTorch, 1.0 },
            { ItemFactory.MakeBone, 4.0 },
            { ItemFactory.MakeObsidianShard, 0.5 },
            { ItemFactory.MakeOchrePigment, 0.2 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomRiverbankItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeWater, 8.0 },
            { ItemFactory.MakeFish, 5.0 },
            { ItemFactory.MakeClay, 6.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 2.0 },
            { ItemFactory.MakeRoots, 3.0 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomPlainsItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeRoots, 6.0 },
            { ItemFactory.MakeStone, 5.0 },
            { ItemFactory.MakeBone, 3.0 },
            { ItemFactory.MakeSinew, 1.0 },
            { ItemFactory.MakeBerry, 2.0 },
            { ItemFactory.MakeMammothTusk, 0.1 } // Very rare find
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomHillsideItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 5.0 },
            { ItemFactory.MakeObsidianShard, 1.0 },
            { ItemFactory.MakeOchrePigment, 2.0 },
            { ItemFactory.MakeHandAxe, 0.2 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
}================================================================================

