File: ./Describe.cs
--------------------------------------------------------------------------------
﻿
using text_survival.IO;
using text_survival.Items;
using text_survival.PlayerComponents;

namespace text_survival
{
    public static class Describe
    {
        public static void DescribeGear(InventoryManager inv)
        {
            if (inv.IsArmed)
            {
                Output.Write("Weapon => ");
                DescribeItem(inv.Weapon);
            }
            foreach (Armor armor in inv.Armor)
            {
                Output.Write(armor.EquipSpot, " => ");
                DescribeItem(armor);
            }
            if (inv.HeldItem is not null)
            {
                Output.Write("Held Item => ");
                DescribeItem(inv.HeldItem);
            }
        }

        public static void DescribeItem(Item item)
        {
            Output.Write(item, " => ", item.Description, " ");
            if (item is Weapon weapon)
            {
                Output.Write("Damage: ", weapon.Damage, " hp, ");
                Output.Write("Hit Chance: ", weapon.Accuracy * 100, "%, ");
                if (weapon.BlockChance != 0)
                {
                    Output.Write(", BlockChance: ", weapon.BlockChance * 100, "%, ");
                }
            }
            else if (item is Armor armor)
            {
                if (armor.Rating != 0)
                    Output.Write("Defense: ", armor.Rating * 100, "%, ");

                if (armor.Warmth != 0)
                    Output.Write("Warmth: ", armor.Warmth, "F, ");
            }

            if (item.Weight != 0)
            {
                Output.Write("Weight: ", item.Weight, "kg");
            }
            Output.WriteLine();
        }

        public static void DescribeSkills(Player player)
        {
            player._skillRegistry.Describe();

        }
    }
}
================================================================================

File: ./Actions.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival
{

    public class Actions
    {
        private readonly Player _player;
        public List<ICommand> AvailableActions { get; private set; }

        public Actions(Player player)
        {
            _player = player;
            AvailableActions = [];
        }

        private Command<Player> LookAroundCommand => new Command<Player>($"Look Around {_player.CurrentLocation}", LookAround);
        private Command<Player> CheckStatsCommand => new Command<Player>("Check Stats", CheckStats);
        // private Command<Player> LevelUpCommand => new Command<Player>("Level Up", LevelUp);
        //private Command<Player, IInteractable> InteractCommand => new Command<Player, IInteractable>("Interact", Interact);
        private Command<Player> OpenInventoryCommand => new Command<Player>("Open Inventory", OpenInventory);
        private Command<Player> TravelCommand => new Command<Player>("Travel", Travel);
        private Command<Player> SleepCommand => new Command<Player>("Sleep", Sleep);
        private Command<Player> CheckGearCommand => new Command<Player>("Check Gear", CheckGear);
        private Command<Player> ForageCommand => new Command<Player>("Forage", Forage);
        //private Command<Player> QuitCommand => new Command<Player>("Quit", Quit);
        public void UpdatePossibleActions()
        {
            // Clear the available actions
            AvailableActions.Clear();

            // always available actions
            var lookCommand = LookAroundCommand;
            lookCommand.Player = _player;
            AvailableActions.Add(lookCommand);

            var forageFeature = _player.CurrentLocation.GetFeature<ForageFeature>();
            if (forageFeature != null)
            {
                var forageCommand = ForageCommand;
                forageCommand.Player = _player;
                AvailableActions.Add(forageCommand);
            }


            // conditional actions
            foreach (Item item in _player.CurrentLocation.Items)
            {
                if (item.IsFound)
                {
                    var interactCommand = item.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Container container in _player.CurrentLocation.Containers)
            {
                if (container.IsFound)
                {
                    var interactCommand = container.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Npc npc in _player.CurrentLocation.Npcs)
            {
                if (npc.IsFound)
                {
                    var interactCommand = npc.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }
            foreach (Location location in GetNearbyLocations(_player))
            {
                if (location.IsFound)
                {
                    var interactCommand = location.InteractCommand;
                    interactCommand.Player = _player;
                    AvailableActions.Add(interactCommand);
                }
            }



            var openInventoryCommand = OpenInventoryCommand;
            openInventoryCommand.Player = _player;
            AvailableActions.Add(openInventoryCommand);

            var travelCommand = TravelCommand;
            travelCommand.Player = _player;
            AvailableActions.Add(travelCommand);


            var sleepCommand = SleepCommand;
            sleepCommand.Player = _player;
            AvailableActions.Add(sleepCommand);

            var checkGearCommand = CheckGearCommand;
            checkGearCommand.Player = _player;
            AvailableActions.Add(checkGearCommand);


            var checkStats = CheckStatsCommand;
            checkStats.Player = _player;
            AvailableActions.Add(checkStats);

            // if (_player.SkillPoints > 0)
            // {
            //     var levelUpCommand = LevelUpCommand;
            //     levelUpCommand.Player = _player;
            //     AvailableActions.Add(levelUpCommand);
            // }
        }

        private void Forage(Player player)
        {
            var forageFeature = player.CurrentLocation.GetFeature<ForageFeature>();
            if (forageFeature == null)
            {
                Output.WriteLine("You can't forage here");
                return;
            }
            Output.WriteLine("How many hours would you like to forage?");
            int hours = Input.ReadInt();
            forageFeature.Forage(hours);


        }

        public void Act()
        {
            UpdatePossibleActions();
            Output.WriteLine();
            _player.DescribeSurvivalStats();
            Output.WriteLine();
            Output.WriteLine("What would you like to do?");
            ICommand? command = Input.GetSelectionFromList(AvailableActions);
            command?.Execute();
        }

        // private void LevelUp(Player player)
        // {
        //     Output.WriteLine("You have ", player.SkillPoints, " points.");
        //     while (player.SkillPoints > 0)
        //     {
        //         Output.WriteLine("Select an attribute to improve:");
        //         Output.WriteLine("1. ", Attributes.PrimaryAttributes.Strength);
        //         Output.WriteLine("3. ", Attributes.PrimaryAttributes.Speed);
        //         Output.WriteLine("4. ", Attributes.PrimaryAttributes.Endurance);
        //         Output.WriteLine("6. ", Attributes.PrimaryAttributes.Luck);

        //         Output.WriteLine("0. Cancel");
        //         int input = Input.ReadInt(0, 8);
        //         if (input == 0) return;
        //         var attribute = input switch
        //         {
        //             1 => Attributes.PrimaryAttributes.Strength,
        //             3 => Attributes.PrimaryAttributes.Speed,
        //             4 => Attributes.PrimaryAttributes.Endurance,
        //             6 => Attributes.PrimaryAttributes.Luck,
        //             _ => throw new NotImplementedException(),
        //         };
        //         // player.SpendPointToUpgradeAttribute(attribute);
        //     }
        // }

        private void CheckStats(Player player)
        {
            // Describe.DescribeLevel(player);
            // Describe.DescribePrimaryAttributes(player);
            Describe.DescribeSkills(player);
            Output.WriteLine("Press any key to continue...");
            Console.ReadKey(true);
        }

        private void OpenInventory(Player player)
        {
            player.OpenInventory();
        }

        private void Travel(Player player)
        {
            player.Travel();
        }


        private void Sleep(Player player)
        {
            Output.WriteLine("How many hours would you like to sleep?");
            player.Sleep(Input.ReadInt() * 60);
        }

        private void CheckGear(Player player)
        {
            // player.CheckGear();
            //todo
        }

        private void LookAround(Player player)
        {
            Output.WriteLine("You look around the ", player.CurrentLocation);
            Output.WriteLine("You are in a ", player.CurrentLocation, " in a ", player.CurrentZone);
            Output.WriteLine("Its ", World.GetTimeOfDay(), " and ", player.CurrentLocation.GetTemperature(), " degrees.");
            // if (player.CurrentLocation.Things.Count == 0)
            // {
            //     Output.WriteLine("You see nothing of interest, time to move on.");
            //     return;
            // }
            // Output.WriteLine("You see:");
            // foreach (var thing in player.CurrentLocation.Things)
            // {
            //     Output.WriteLine(thing);
            //     thing.IsFound = true;
            // }

            var nearbyLocations = GetNearbyLocations(player);
            if (nearbyLocations.Count == 0)
                return;
            Output.WriteLine("Nearby, you see some other places: ");
            foreach (var location in nearbyLocations)
            {
                Output.WriteLine(location);
                location.IsFound = true;
            }
        }
        private List<Location> GetNearbyLocations(Player player)
        {
            List<Location> nearbyLocations = [];
            if (player.CurrentZone.Locations.Count > 0)
            {
                foreach (var location in player.CurrentZone.Locations)
                {
                    if (location == player.CurrentLocation)
                        continue;
                    nearbyLocations.Add(location);
                }
            }
            return nearbyLocations;
        }
    }
}
================================================================================

File: ./Physics.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Physics
    {
        public static float DeltaCelsiusToDeltaFahrenheit(float celsius)
        {
            return (celsius * (9.0F / 5.0F));
        }
        public static float TempChange(float mass, float specificHeat, float joules)
        {
            float deltaT = joules / (mass * specificHeat);
            return deltaT;
        }
        public static float CaloriesToJoules(float calories)
        {
            return calories * 4184.0F;
        }

    }
}
================================================================================

File: ./Player.cs
--------------------------------------------------------------------------------
﻿using System.Reflection.Metadata.Ecma335;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.PlayerComponents;

namespace text_survival;

public class Player : Actor
{

    private LocationManager locationManager;
    private SpellManager spellManager;
    private InventoryManager inventoryManager;



    public double EquipmentWarmth => inventoryManager.EquipmentWarmth;
    public void Sleep(int minutes) => survivalManager.Sleep(minutes);
    public void OpenInventory() => inventoryManager.Open(this);
    public override Weapon ActiveWeapon
    {
        get => inventoryManager.Weapon; protected set
        {
            inventoryManager.Weapon = value;
        }
    }

    // Location-related methods
    public Location CurrentLocation
    {
        get => locationManager.CurrentLocation;
        set => locationManager.CurrentLocation = value;
    }

    public Zone CurrentZone => locationManager.CurrentZone;

    #region Constructor

    public Player(Location startingLocation) : base(bodyStats)
    {
        Name = "Player";
        locationManager = new LocationManager(startingLocation);
        spellManager = new(_skillRegistry);
        inventoryManager = new(_effectRegistry);
    }

    // helper to keep constructor clean
    private static BodyStats bodyStats = new BodyStats
    {
        type = BodyPartFactory.BodyTypes.Human,
        overallWeight = 70, // KG
        fatPercent = .20,
        musclePercent = .60
    };

    #endregion Constructor

    public void DropItem(Item item)
    {
        inventoryManager.RemoveFromInventory(item);
        Output.WriteLine("You drop the ", item);
        locationManager.AddItemToLocation(item);
    }

    public void TakeItem(Item item)
    {
        locationManager.RemoveItemFromLocation(item);
        Output.WriteLine("You take the ", item);
        inventoryManager.AddToInventory(item);
    }

    public void SelectSpell()
    {
        List<Actor> targets = [this];
        CurrentLocation.Npcs.ForEach(targets.Add);
        spellManager.SelectSpell(targets);
    }



    public override void Damage(DamageInfo damageInfo)
    {
        survivalManager.Damage(damageInfo);
        if (!IsAlive)
        {
            // end program
            Environment.Exit(0);
        }
    }

    internal void DescribeSurvivalStats() => survivalManager.Describe();
    public void UseItem(Item item)
    {
        Output.WriteLine($"DEBUG: Item '{item.Name}' has actual type: {item.GetType().FullName}");
        Output.WriteLine($"DEBUG: Base type: {item.GetType().BaseType?.FullName}");
        // handle special logic for each item type
        if (item is FoodItem food)
        {
            string eating_type = food.WaterContent > food.Calories ? "drink" : "eat";
            Output.Write($"You {eating_type} the ", food, "...");
            survivalManager.ConsumeFood(food);
        }
        else if (item is ConsumableItem consumable)
        {
            foreach (Effect e in consumable.Effects)
            {
                ApplyEffect(e);
            }
        }
        else if (item is Gear gear)
        {
            Output.WriteLine("You equip the ", gear);
            inventoryManager.Equip(gear);
            foreach (Effect effect in gear.EquipEffects)
            {
                ApplyEffect(effect);
            }
        }

        else if (item is WeaponModifierItem weaponMod)
        {
            if (ModifyWeapon(weaponMod.Damage))
            {
                Output.WriteLine("You use the ", weaponMod, " to modify your ", inventoryManager.Weapon);
            }
            else
            {
                Output.WriteLine("You don't have a weapon equipped to modify.");
                return;
            }
        }
        else if (item is ArmorModifierItem armorMod)
        {
            if (ModifyArmor(armorMod.ValidArmorTypes[0], armorMod.Rating, armorMod.Warmth))
            {
                Output.WriteLine("You use the ", armorMod, " to modify your armor.");
            }
            else
            {
                Output.WriteLine("You don't have any armor you can use that on.");
                return;
            }
        }
        else
        {
            Output.Write("You don't know what to use the ", item, " for...\n");
            return;
        }
        // shared logic for all item types
        if (item.NumUses != -1)
        {
            item.NumUses -= 1;
            if (item.NumUses == 0)
            {
                inventoryManager.RemoveFromInventory(item);
            }
        }
        World.Update(1);
    }

    public bool ModifyWeapon(double damage)
    {
        if (!inventoryManager.IsArmed) return false;

        inventoryManager.Weapon.Damage += damage;
        return true;
    }
    public bool ModifyArmor(EquipSpots spot, double rating = 0, double warmth = 0)
    {
        Armor? armor = inventoryManager.GetArmorInSpot(spot);
        if (armor is null) return false;

        armor.Rating += rating;
        armor.Warmth += warmth;
        return true;
    }

    public void Travel() => locationManager.TravelToAdjacentZone();
}



================================================================================

File: ./Actors/Animal.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;
using text_survival.IO;

namespace text_survival.Actors
{
    public class Animal : Npc
    {
        // public string Description { get; set; } = "";
        // public bool IsFound { get; set; } = false;
        // public bool IsHostile { get; set; } = true;
        public override Weapon ActiveWeapon { get ; protected set; }
        private Container Loot { get; }
    
    
        public Animal(string name, Weapon weapon, BodyStats bodyStats) : base(name, weapon, bodyStats)
        {
            Name = name;
            ActiveWeapon = weapon;

            // Set up loot container
            Loot = new Container(name, 10);
        }

  
        public override string ToString() => Name;
    }
}================================================================================

File: ./Actors/IBuffable.cs
--------------------------------------------------------------------------------
﻿// using text_survival.Magic;

// namespace text_survival.Actors
// {
//     public interface IBuffable //: IActor
//     {
//         public List<Buff> Buffs { get; }

//         public void AddBuff(Buff buff)
//         {
//             if (buff.Target == null)
//                 buff.ApplyTo(this);
//             Buffs.Add(buff);
//         }
//         public void RemoveBuff(Buff buff)
//         {
//             if (buff.Target == this)
//                 buff.Remove();
//             Buffs.Remove(buff);
//         }

//     }
// }
================================================================================

File: ./Actors/ICombatant.cs
--------------------------------------------------------------------------------
﻿
// using text_survival.Items;
// using text_survival.Level;

// namespace text_survival.Actors
// {
//     public interface ICombatant
//     {
//         bool IsAlive { get; }
//         bool IsEngaged { get; set; }
//         Weapon ActiveWeapon { get; }
//         Attributes Attributes { get; }
//         SkillRegistry _skillRegistry {get;}
//         double ConditionPercent { get; }
//         void Attack(ICombatant target);
//         // double DetermineDamage();
//         // double DetermineHitChance(ICombatant defender);
//         // double DetermineDodgeChance(ICombatant attacker);
//         // double DetermineBlockChance(ICombatant attacker);

//     }
// }
================================================================================

File: ./Actors/NPCFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;

namespace text_survival.Actors
{
    public static class NpcFactory
    {
        public static Animal MakeRat()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 0.5, // 0.5 kg for a rat
                fatPercent = 0.15,   // 15% fat
                musclePercent = 0.40 // 40% muscle
            };

            // Create a natural weapon for the rat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Rodent Teeth", 100)
            {
                Damage = 2,
                Accuracy = 1.2
            };

            Animal rat = new("Rat", weapon, bodyStats)
            {
                Description = "A rat with fleas."
            };
            rat.AddLoot(ItemFactory.MakeSmallMeat());
            return rat;
        }

        public static Animal MakeWolf()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 40,   // 40 kg - average wolf
                fatPercent = 0.20,    // 20% fat
                musclePercent = 0.60  // 60% muscle - wolves are muscular
            };

            // Create a natural weapon for the wolf
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Wolf Fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.1
            };

            Animal wolf = new("Wolf", weapon, bodyStats)
            {
                Description = "A wolf."
            };
            wolf.AddLoot(ItemFactory.MakeLargeMeat());
            return wolf;
        }

        public static Animal MakeBear()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 250,  // 250 kg - large bear
                fatPercent = 0.30,    // 30% fat - bears have more fat reserves
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "Bear Claws", 100)
            {
                Damage = 20,
                Accuracy = 0.9
            };

            Animal bear = new("Bear", weapon, bodyStats)
            {
                Description = "A bear."
            };
            bear.AddLoot(ItemFactory.MakeLargeMeat());
            return bear;
        }

        public static Animal MakeSnake()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Serpentine,
                overallWeight = 5,    // 5 kg - medium sized snake
                fatPercent = 0.10,    // 10% fat
                musclePercent = 0.80  // 80% muscle - snakes are almost all muscle
            };

            // Create a natural weapon for the snake
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.0
            };

            Animal snake = new("Snake", weapon, bodyStats)
            {
                Description = "A venomous snake."
            };

            LootTable loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSmallMeat, 2);
            loot.AddItem(ItemFactory.MakeVenomSac);
            snake.AddLoot(loot.GenerateRandomItem());

            // TODO: Apply venom effect
            // snake.ApplyEffect(new PoisonEffect("venom", "natural", 0.8, 2, 180));

            return snake;
        }

        public static Animal MakeBat()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Flying,
                overallWeight = 0.2,   // 200g - small bat
                fatPercent = 0.20,     // 20% fat 
                musclePercent = 0.65   // 65% muscle - flying requires strong muscles
            };

            // Create a natural weapon for the bat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Tiny Teeth", 100)
            {
                Damage = 2,
                Accuracy = 0.9
            };

            Animal bat = new("Bat", weapon, bodyStats)
            {
                Description = "A small bat with leathery wings."
            };

            return bat;
        }

        public static Animal MakeSpider()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Arachnid,
                overallWeight = 0.1,   // 100g - large spider
                fatPercent = 0.05,     // 5% fat
                musclePercent = 0.45   // 45% muscle
            };

            // Create a natural weapon for the spider
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Mandibles", 100)
            {
                Damage = 5,
                Accuracy = 1.2
            };

            Animal spider = new("Spider", weapon, bodyStats)
            {
                Description = "A venomous spider with long hairy legs."
            };

            // TODO: Apply venom effect
            // spider.ApplyEffect(new PoisonEffect("venom", "natural", 0.6, 1, 120));

            var loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSpiderSilk);
            loot.AddItem(ItemFactory.MakeVenomSac);
            spider.AddLoot(loot.GenerateRandomItem());

            return spider;
        }

        public static Animal MakeCaveBear()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 350,  // 350 kg - larger than a regular bear
                fatPercent = 0.35,    // 35% fat - more for cave survival
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the cave bear - stronger than regular bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "Massive Cave Bear Claws", 100)
            {
                Damage = 25,
                Accuracy = 0.85
            };

            Animal caveBear = new("Cave Bear", weapon, bodyStats)
            {
                Description = "An enormous cave bear with massive claws. It's adapted to cave dwelling and hunting in darkness."
            };

            // Add more meat due to larger size
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());

            return caveBear;
        }

        public static Animal MakeWoollyMammoth()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 6000,  // 6 tons - enormous
                fatPercent = 0.35,     // 35% fat for cold protection
                musclePercent = 0.50   // 50% muscle
            };

            // Create a natural weapon for the mammoth
            var weapon = new Weapon(WeaponType.Horns, WeaponMaterial.Organic, "Mammoth Tusks", 100)
            {
                Damage = 35,
                Accuracy = 0.7
            };

            Animal mammoth = new("Woolly Mammoth", weapon, bodyStats)
            {
                Description = "A massive woolly mammoth with long curved tusks and a thick fur coat."
            };

            // Add large amount of meat and other rare resources
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());

            return mammoth;
        }

        public static Animal MakeSaberToothTiger()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 300,   // 300 kg - large cat
                fatPercent = 0.15,     // 15% fat
                musclePercent = 0.70   // 70% muscle - extremely powerful
            };

            // Create a natural weapon for the saber-tooth
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Massive Fangs", 100)
            {
                Damage = 30,
                Accuracy = 1.0
            };

            Animal saberTooth = new("Saber-Tooth Tiger", weapon, bodyStats)
            {
                Description = "A fearsome predator with long saber-like canine teeth."
            };

            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());
            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());

            return saberTooth;
        }

        // Human NPCs with various weapons
        public static Npc MakeTribalHunter()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 65,
                fatPercent = 0.15,
                musclePercent = 0.60
            };

            // Create a hunting spear
            var weapon = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Hunter's Wooden Spear", 75)
            {
                Damage = 8,
                Accuracy = 1.2
            };

            // Create hunter with spear
            Npc hunter = new("Tribal Hunter", weapon, bodyStats)
            {
                Description = "A lean, muscular hunter from a nearby tribe."
            };

            // Add some basic equipment to loot
            hunter.AddLoot(ItemFactory.MakeSmallMeat());

            return hunter;
        }

        public static Npc MakeTribalWarrior()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 70,
                fatPercent = 0.15,
                musclePercent = 0.65
            };

            // Create a war club
            var weapon = new Weapon(WeaponType.Club, WeaponMaterial.Stone, "Warrior's War-Club", 80)
            {
                Damage = 12,
                Accuracy = 0.9
            };

            // Create warrior with club
            Npc warrior = new("Tribal Warrior", weapon, bodyStats)
            {
                Description = "A fierce warrior with ritual paint markings."
            };

            // Add some loot
            warrior.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Knapped-Flint Scraper", 60));

            return warrior;
        }

        public static Npc MakeTribalShaman()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 60,
                fatPercent = 0.20,
                musclePercent = 0.45
            };

            // Create a ritual staff
            var weapon = new Weapon(WeaponType.Knife, WeaponMaterial.Bone, "Shamanic Bone-Knife", 90)
            {
                Damage = 6,
                Accuracy = 1.1
            };

            // Create shaman with staff
            Npc shaman = new("Tribal Shaman", weapon, bodyStats)
            {
                Description = "An elderly shaman adorned with animal bones and feathers."
            };

            // Add some rare loot
            shaman.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Obsidian, "Night-Glass Ritual Knife", 95));

            return shaman;
        }
    }
}================================================================================

File: ./Actors/NpcSpawner.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Actors
{
    public class NpcSpawner
    {
        private List<Func<Npc>> _factories { get; set; }

        public NpcSpawner()
        {
            _factories = [];
        }

        public NpcSpawner(List<Func<Npc>> factories)
        {
            _factories = factories;
        }

        public void Add(Func<Npc> factory)
        {
            _factories.Add(factory);
        }

        public Npc? GenerateRandomNpc()
        {
            if (_factories.Count == 0)
            {
                throw new Exception("No factories");
            }
            var fac = Utils.GetRandomFromList(_factories);
            return fac();
        }
    }
}================================================================================

File: ./Actors/Actor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Items;
using text_survival.Level;
using text_survival.PlayerComponents;

namespace text_survival.Actors;

public abstract class Actor
{
    public string Name = "";
    public virtual void Attack(Actor target) => combatManager.Attack(target);

    public virtual void Damage(DamageInfo damage) => survivalManager.Damage(damage);
    public virtual void Heal(HealingInfo heal) => survivalManager.Heal(heal);

    public bool IsEngaged { get; set; }
    public bool IsAlive => !Body.IsDestroyed;
    public double ConditionPercent => survivalManager.ConditionPercent;
    public abstract Weapon ActiveWeapon { get; protected set;}

    public virtual void ApplyEffect(Effect effect) => _effectRegistry.AddEffect(effect);
    public virtual void RemoveEffect(Effect effect) => _effectRegistry.RemoveEffect(effect);
    public virtual List<Effect> GetEffectsByKind(string kind) => _effectRegistry.GetEffectsByKind(kind);
    public virtual void Update()
    {
        survivalManager.Update();
        _effectRegistry.Update();
    }

    public SkillRegistry _skillRegistry { get; init; }
    public Body Body { get; init; }
    protected EffectRegistry _effectRegistry { get; init; }
    protected SurvivalManager survivalManager { get; init; }
    protected CombatManager combatManager { get; init; }

    public override string ToString() => Name;

    protected Actor(BodyStats stats)
    {
        _effectRegistry = new EffectRegistry(this);
        _skillRegistry = new SkillRegistry();
        this.survivalManager = new SurvivalManager(this, _effectRegistry);
        this.combatManager = new CombatManager(this);
        Body = new Body(stats, _effectRegistry);
    }
}


================================================================================

File: ./Actors/NPC.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.Bodies;

namespace text_survival.Actors
{
    public class Npc : Actor
    {
        #region Properties

        // Basic properties
        public string Description { get; set; }
        public bool IsFound { get; set; }
        public bool IsHostile { get; private set; }
        public override Weapon ActiveWeapon {get; protected set; }

        // IPhysicalEntity implementation
        public double Health => Body.Health;
        public double MaxHealth => Body.MaxHealth;
        public bool IsDestroyed => Body.IsDestroyed;

        // Internal components

        private Container Loot { get; }

        #endregion

        #region Constructor

        public Npc(string name, Weapon weapon, BodyStats stats) : base(stats)
        {
            // Basic initialization
            Name = name;
            Description = "";
            IsHostile = true;
            ActiveWeapon = weapon;

            // Component initialization
            _skillRegistry = new SkillRegistry(false);

            // Set up loot container
            Loot = new Container(name, 10);
        }

        #endregion


        #region IInteractable Interface Implementation

        public void Interact(Player player)
        {
            if (IsAlive)
            {
                Combat.CombatLoop(player, this);
            }
            else
            {
                if (Loot.IsEmpty)
                {
                    Output.WriteLine("There is nothing to loot.");
                    return;
                }
                Loot.Open(player);
            }
        }

        public Command<Player> InteractCommand
        {
            get
            {
                string name = IsAlive ? "Fight " + Name : "Loot " + Name;
                return new Command<Player>(name, Interact);
            }
        }

        #endregion



        #region Inventory and Loot Methods

        public void AddLoot(Item item) => Loot.Add(item);

        #endregion

        public override string ToString() => Name;
    }
}================================================================================

File: ./Items/Container.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Items
{
    public class Container
    {
        private string _name;
        public string Name { get => (IsEmpty && HasBeenOpened) ? _name + " (Empty)" : _name; set => _name = value; }
        public double Weight() => Items.Sum(item => item.Weight);
        public float MaxWeight { get; set; }
        public List<Item> Items { get; }
        public bool IsEmpty => Items.Count == 0;
        protected bool HasBeenOpened { get; set; }
        public bool IsFound { get; set; }

        public Container(string name, float maxWeight)
        {
            _name = name;
            MaxWeight = maxWeight;
            Items = [];
        }

        public Item GetItem(int index) => Items[index];
        public Item GetItemByName(string itemName) => Items.First(i => i.Name.Equals(itemName));

        public void Interact(Player player)
        {
            if (!Combat.SpeedCheck(player))
            {
                Npc npc = Combat.GetFastestNpc(player.CurrentLocation);
                Output.WriteLine("You couldn't get past the ", npc, "!");
                npc.Interact(player);
                return;
            }
            Output.WriteLine("You open the ", this);
            Open(player);
        }

        public Command<Player> InteractCommand => new("Look in " + Name, Interact);

        public virtual void Open(Player player)
        {
            HasBeenOpened = true;
            while (!IsEmpty)
            {
                Output.WriteLine(this, ":");

                var items = new List<Item>(Items);
                Item takeAll = new Item("Take all");
                if (items.Count > 1)
                {
                    items.Add(takeAll);
                }

                var itemStacks = ItemStack.CreateStacksFromItems(items);

                var selection = Input.GetSelectionFromList(itemStacks, true, "Close " + this);
                if (selection == null) return;

                Item selectedItem = selection.Take();

                if (selectedItem == takeAll)
                {
                    TakeAll(player);
                    return;
                }

                Output.WriteLine("What would you like to do with ", selectedItem);
                string? choice = Input.GetSelectionFromList(["Take", "Inspect"], true);
                switch (choice)
                {
                    case null:
                        continue;
                    case "Take":
                        Remove(selectedItem);
                        player.TakeItem(selectedItem);
                        break;
                    case "Inspect":
                        Describe.DescribeItem(selectedItem);
                        break;
                    case "Use":
                        Remove(selectedItem);
                        player.TakeItem(selectedItem);
                        player.UseItem(selectedItem);
                        break;
                }
            }
            Output.WriteLine(this, " is empty.");
        }


        private void TakeAll(Player player)
        {
            while (!IsEmpty)
            {
                var item = Items.First();
                Remove(item);
                player.TakeItem(item);
            }
        }

        public override string ToString() => Name;

        public void Add(Item item)
        {
            if (item.Weight + Weight() > MaxWeight)
            {
                Output.Write("The ", this, "is full!\n");
                return;
            }
            Items.Add(item);
        }

        public void Remove(Item item) => Items.Remove(item);
        public int Count() => Items.Count;

    }
}
================================================================================

File: ./Items/Item.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;

using text_survival.IO;

namespace text_survival.Items
{
    //public interface IItem
    //{
    //    string Name { get; set; }
    //    double Weight { get; set; } // in kg
    //    Action<Player> UseEffect { get; set; }
    //    string Description { get; set; }
    //    int Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
    //    string ToString();
    //    void Use(Player player);
    //}

    public class Item
    {
        public string Name { get; set; }
        public double Weight { get; set; } // in kg
        public string Description { get; set; } = "";
        public double Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
        public bool IsFound { get; set; }
        public int NumUses { get; set; }

        public Item(string name, double weight = 1, int quality = 50)
        {
            Name = name;
            Weight = weight;
            Quality = quality;
            NumUses = -1; // not consumable
        }

        public override string ToString()
        {
            return Name;
        }
        

        public void Interact(Player player)
        {
            if (!Combat.SpeedCheck(player))
            {
                Npc npc = Combat.GetFastestNpc(player.CurrentLocation);
                Output.WriteLine("You couldn't get past the ", npc, "!");
                npc.Interact(player);
                return;
            }
            player.TakeItem(this);
        }
        public Command<Player> InteractCommand => new Command<Player>("Pick up " + Name, Interact);

    }
}
================================================================================

File: ./Items/FoodItem.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;

namespace text_survival.Items
{
    public interface IEdible
    {
        int WaterContent { get; }
        int Calories { get; }
    }

    public class FoodItem : Item, IEdible
    {
        public FoodItem(string name, int calories, int waterContent = 0, double weight = .5) : base(name, weight)
        {
            Quality = 100;
            Calories = calories;
            WaterContent = waterContent;
            NumUses = 1;
        }

        public int WaterContent { get; }
        public int Calories { get; }
        public HealingInfo? HealthEffect {get; set;}
        public DamageInfo? DamageEffect {get; set;}
        public void Update()
        {
            Quality -= .1; //TODO: Add spoilage
        }
        public override string ToString() => Name;
    }
}
================================================================================

File: ./Items/IEquippable.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Effects;

namespace text_survival.Items
{
    public interface IEquippable
    {
        // public List<Buff> GetEquipBuffs();
        // public void AddEquipBuff(Buff buff);
        // public void RemoveEquipBuff(Buff buff);
        public List<Effect> EquipEffects { get; }
    }

}================================================================================

File: ./Items/ItemStack.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class ItemStack
{
    public string DisplayName => Items.Count == 1 ? FirstItem.Name : $"{FirstItem.Name} x{Items.Count}";
    public Item FirstItem { get; private set; }
    public Stack<Item> Items { get; private set; }
    public int Count => Items.Count;
    
    public ItemStack(Item item)
    {
        FirstItem = item;
        Items = new Stack<Item>();
        Items.Push(item);
    }
    
    public void Add(Item item)
    {
        if (item.Name != FirstItem.Name)
        {
            throw new ArgumentException($"Cannot add item '{item.Name}' to stack of '{FirstItem.Name}'");
        }
        
        Items.Push(item);
    }
    
    public Item Take() => Items.Pop();
    
    public override string ToString() => DisplayName;
    
    public static List<ItemStack> CreateStacksFromItems(IEnumerable<Item> items)
    {
        var stacksByName = new Dictionary<string, ItemStack>();
        
        foreach (var item in items)
        {
            if (stacksByName.TryGetValue(item.Name, out var stack))
            {
                stack.Add(item);
            }
            else
            {
                stacksByName[item.Name] = new ItemStack(item);
            }
        }
        
        return stacksByName.Values.ToList();
    }
}================================================================================

File: ./Items/Gear.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Gear : Item, IEquippable
    {
        // private List<Buff> EquipBuffs { get; }
        // public List<Buff> GetEquipBuffs() => EquipBuffs;
        // public void AddEquipBuff(Buff buff) => EquipBuffs.Add(buff);
        // public void RemoveEquipBuff(Buff buff) => EquipBuffs.Remove(buff);
        public List<Effect> EquipEffects { get; set; }
        public double Warmth { get; set; }
        public Gear(string name, double weight = 1, int quality = 50) : base(name, weight, quality)
        {
            EquipEffects = [];
        }
    }

}

================================================================================

File: ./Items/ConsumableItem.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.Items;

namespace text_survival.Actors;

class ConsumableItem : Item
{
    public ConsumableItem(string name, int numUses=1) : base(name)
    {
        Effects = [];
        NumUses = numUses;
    }

    public List<Effect> Effects;
}
================================================================================

File: ./Items/ModifierItem.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class WeaponModifierItem : Item
{
    public double Damage { get; set; }
    public WeaponModifierItem(string name) : base(name)
    {
        Damage = 0;
    }

}

public class ArmorModifierItem : Item
{
    public List<EquipSpots> ValidArmorTypes;
    public double Warmth { get; set; }
    public double Rating { get; set; }
    public ArmorModifierItem(string name, List<EquipSpots> validArmorTypes) : base(name)
    {
        ValidArmorTypes = validArmorTypes;
        Warmth = 0;
        Rating = 0;
    }

}================================================================================

File: ./Items/Armor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Armor : Gear
    {
        public EquipSpots EquipSpot { get; set; }
        public double Rating { get; set; }
        public ArmorClass Type { get; set; }

        public Armor(string name, double rating, EquipSpots equipSpot, double warmth = 0, ArmorClass type = ArmorClass.Light) : base(name)
        {
            EquipEffects = [];
            Rating = rating;
            EquipSpot = equipSpot;
            Warmth = warmth;
            Type = type;
        }


    }
}================================================================================

File: ./Items/ItemEnums.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum EquipSpots
    {
        Head,
        Chest,
        Legs,
        Feet,
        Hands,
        Weapon
    }

    public enum ArmorClass
    {
        Light,
        Heavy
    }







}================================================================================

File: ./Items/Weapon.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum WeaponType
    {
        // Crafted weapons
        Spear,          // Long distance hunting/combat
        Club,           // Heavy blunt force
        HandAxe,        // Cutting tool and weapon
        Knife,          // Sharp tool made of flint or similar
        SharpStone,     // Primitive cutting tool

        // Natural weapons
        Unarmed,        // Human fists
        Claws,          // Bear, large feline
        Fangs,          // Wolf, snake
        Horns           // Mammoth tusks, deer antlers
    }

    public enum WeaponClass
    {
        Blade,          // Cutting damage
        Blunt,          // Impact damage
        Pierce,         // Stabbing damage
        Claw,           // Tearing damage
        Unarmed         // Basic damage
    }

    public enum WeaponMaterial
    {
        Wood,           // Sticks, branches
        Stone,          // Basic stone
        Bone,           // Animal bones
        Antler,         // Deer/elk antlers
        Flint,          // Knapped flint
        Obsidian,       // Volcanic glass
        Organic,        // Natural animal weapons
        Other           // Miscellaneous
    }
    public class Weapon : Gear
    {
        public WeaponClass Class { get; set; }
        public WeaponMaterial Material { get; set; }
        public WeaponType Type { get; set; }
        public double Damage { get; set; }
        public double Accuracy { get; set; }
        public double BlockChance { get; set; }
        public double Craftsmanship { get; set; }

        public Weapon(WeaponType type, WeaponMaterial material, string name = "", int craftsmanship = 50)
            : base(name, quality: craftsmanship)
        {
            Craftsmanship = craftsmanship;
            SetBaseStats(type);
            ApplyMaterialModifier(material);
            ApplyCraftsmanshipModifier();
            Class = GetDamageTypeFromWeaponType(type);

            if (string.IsNullOrWhiteSpace(name))
                Name = $"{GetCraftsmanshipDescription(Craftsmanship)} {GetMaterialDescription(material)} {GetWeaponTypeDescription(type)}";

            Type = type;
            Material = material;
            EquipEffects = [];
        }

        private void ApplyCraftsmanshipModifier()
        {
            // The better crafted the weapon, the more effective it is
            Damage *= (Craftsmanship * 1.5) / 100;
            BlockChance *= Craftsmanship / 100;
        }

        private void ApplyMaterialModifier(WeaponMaterial material)
        {
            switch (material)
            {
                case WeaponMaterial.Wood:
                    Damage *= 0.6;
                    BlockChance *= 0.7;
                    Weight *= 0.5;
                    break;
                case WeaponMaterial.Stone:
                    Damage *= 1.0;
                    BlockChance *= 0.6;
                    Weight *= 1.2;
                    break;
                case WeaponMaterial.Bone:
                    Damage *= 0.8;
                    BlockChance *= 0.8;
                    Weight *= 0.7;
                    break;
                case WeaponMaterial.Antler:
                    Damage *= 0.9;
                    BlockChance *= 0.7;
                    Weight *= 0.8;
                    break;
                case WeaponMaterial.Flint:
                    Damage *= 1.2;
                    BlockChance *= 0.5;
                    Weight *= 1.0;
                    break;
                case WeaponMaterial.Obsidian:
                    Damage *= 1.4;
                    BlockChance *= 0.4;
                    Weight *= 0.9;
                    break;
                case WeaponMaterial.Organic:
                case WeaponMaterial.Other:
                default:
                    // No modifiers for natural/organic materials
                    break;
            }
        }

        private void SetBaseStats(WeaponType type)
        {
            switch (type)
            {
                case WeaponType.Spear:
                    Damage = 8;
                    BlockChance = 0.12;
                    Accuracy = 1.2;
                    Weight = 1.5;
                    break;
                case WeaponType.Club:
                    Damage = 10;
                    BlockChance = 0.08;
                    Accuracy = 0.9;
                    Weight = 2.0;
                    break;
                case WeaponType.HandAxe:
                    Damage = 12;
                    BlockChance = 0.05;
                    Accuracy = 0.8;
                    Weight = 1.8;
                    break;
                case WeaponType.Knife:
                    Damage = 6;
                    BlockChance = 0.02;
                    Accuracy = 1.4;
                    Weight = 0.5;
                    break;
                case WeaponType.SharpStone:
                    Damage = 4;
                    BlockChance = 0.01;
                    Accuracy = 1.1;
                    Weight = 0.3;
                    break;
                case WeaponType.Unarmed:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.5;
                    Weight = 0;
                    break;
                default:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.0;
                    Weight = 0.5;
                    break;
            }
        }

        public static Weapon GenerateRandomWeapon()
        {
            // Filter out unarmed and natural weapons when generating random weapons
            var validTypes = Enum.GetValues(typeof(WeaponType))
                .Cast<WeaponType>()
                .Where(t => t != WeaponType.Unarmed &&
                            t != WeaponType.Claws &&
                            t != WeaponType.Fangs &&
                            t != WeaponType.Horns)
                .ToArray();

            // Filter out organic and other from random generation
            var validMaterials = Enum.GetValues(typeof(WeaponMaterial))
                .Cast<WeaponMaterial>()
                .Where(m => m != WeaponMaterial.Organic && m != WeaponMaterial.Other)
                .ToArray();

            WeaponMaterial material = validMaterials[Utils.RandInt(0, validMaterials.Length - 1)];
            WeaponType type = validTypes[Utils.RandInt(0, validTypes.Length - 1)];

            int craftsmanship = Utils.RandInt(30, 80); // Primitive technology has limited upper quality

            return new Weapon(type, material, craftsmanship: craftsmanship);
        }

        private static WeaponClass GetDamageTypeFromWeaponType(WeaponType type)
        {
            return type switch
            {
                WeaponType.Knife => WeaponClass.Blade,
                WeaponType.SharpStone => WeaponClass.Blade,
                WeaponType.HandAxe => WeaponClass.Blade,
                WeaponType.Spear => WeaponClass.Pierce,
                WeaponType.Club => WeaponClass.Blunt,
                WeaponType.Unarmed => WeaponClass.Unarmed,
                WeaponType.Claws => WeaponClass.Claw,
                WeaponType.Fangs => WeaponClass.Pierce,
                WeaponType.Horns => WeaponClass.Pierce,
                _ => WeaponClass.Blunt,
            };
        }

        private string GetCraftsmanshipDescription(double craftsmanship)
        {
            return craftsmanship switch
            {
                0 => "Broken",
                < 20 => "Primitive",
                < 40 => "Rough",
                < 60 => "Simple",
                < 80 => "Sturdy",
                < 95 => "Master Crafted",
                <= 100 => "Flawless",
                _ => "Strange"
            };
        }

        private string GetMaterialDescription(WeaponMaterial material)
        {
            return material switch
            {
                WeaponMaterial.Wood => "Wooden",
                WeaponMaterial.Stone => "Stone",
                WeaponMaterial.Bone => "Bone",
                WeaponMaterial.Antler => "Antler",
                WeaponMaterial.Flint => "Flint",
                WeaponMaterial.Obsidian => "Obsidian",
                WeaponMaterial.Organic => "",
                WeaponMaterial.Other => "",
                _ => ""
            };
        }

        private string GetWeaponTypeDescription(WeaponType type)
        {
            return type switch
            {
                WeaponType.Spear => "Spear",
                WeaponType.Club => "Club",
                WeaponType.HandAxe => "Hand Axe",
                WeaponType.Knife => "Knife",
                WeaponType.SharpStone => "Sharp Stone",
                WeaponType.Unarmed => "Fists",
                WeaponType.Claws => "Claws",
                WeaponType.Fangs => "Fangs",
                WeaponType.Horns => "Horns",
                _ => "Tool"
            };
        }
    }
}================================================================================

File: ./Items/ItemFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Effects;


namespace text_survival.Items
{
    public class ItemFactory
    {
        public static readonly Dictionary<string, Func<Item>> ItemDefinitions = new()
        {
            { "Mushroom", MakeMushroom },
            { "Berries", MakeBerry },
            { "Roots", MakeRoots },
            { "Water", MakeWater },
            { "Stick", MakeStick },
            { "Firewood", MakeFirewood },
            { "Flint", MakeFlint },
            { "Clay", MakeClay },
            { "Stone", MakeStone },
            { "Bone", MakeBone },
            { "Spear", MakeSpear },
            { "Club", MakeClub },
            { "HandAxe", MakeHandAxe },
            { "Knife", MakeKnife },
            { "Hide Shield", MakeHideShield },
            { "Fur Armor", MakeFurArmor },
            { "Healing Herbs", MakeHealingHerbs },
            { "Bandage", MakeBandage },
            { "Torch", MakeTorch },
            { "Fish", MakeFish },
            { "Primitive Weapon", Weapon.GenerateRandomWeapon }
        };

        public static Weapon MakeFists()
        {
            return new Weapon(WeaponType.Unarmed, WeaponMaterial.Organic, "Bare Hands");
        }

        public static FoodItem MakeMushroom()
        {
            var mushroom = new FoodItem("Wild Mushroom", 25, 5)
            {
                Description = "A forest mushroom. Some varieties are nutritious, others are deadly.",
                Weight = 0.1F
            };

            double strength = Utils.RandDouble(1, 15);
            string targetOrgan = Utils.GetRandomFromList(["Stomach", "Liver", "Kidney"]);

            if (Utils.FlipCoin())
            {
                mushroom.HealthEffect = new()
                {
                    Amount = strength,
                    Type = "herbal",
                    TargetPart = targetOrgan,
                    Quality = Utils.RandDouble(0, 1.5)
                };
            }
            else
            {
                mushroom.DamageEffect = new()
                {
                    Amount = strength * .66,
                    IsPenetrating = true,
                    Type = "poison",
                    TargetPart = targetOrgan,
                    Accuracy = 1,
                };
            }
            return mushroom;
        }

        public static FoodItem MakeBerry()
        {
            var item = new FoodItem("Wild Berries", 120, 100);
            string color = Utils.GetRandomFromList(["red", "blue", "black", "purple"]);
            string season = Utils.GetRandomFromList(["autumn", "summer"]);
            item.Description = $"A handful of {color} {season} berries. Sweet and juicy.";
            item.Weight = 0.1F;
            return item;
        }

        public static FoodItem MakeRoots()
        {
            var item = new FoodItem("Foraged Roots", 100, 20)
            {
                Description = "Starchy roots dug from the ground. Tough but nutritious.",
                Weight = 0.3F
            };
            return item;
        }

        public static FoodItem MakeWater()
        {
            var item = new FoodItem("Fresh Water", 0, 1000)
            {
                Description = "Clear water collected from a stream. Stored in a water skin made from animal bladder.",
                Weight = 1
            };
            return item;
        }

        public static Item MakeStick()
        {
            Item stick = new Item("Sturdy Stick")
            {
                Description = "A strong branch, useful for making tools and weapons.",
                Weight = 0.5
            };
            return stick;
        }

        public static Item MakeFirewood()
        {
            var wood = new Item("Firewood")
            {
                Description = "Dry wood gathered for making fires. Essential for warmth and cooking.",
                Weight = 1.5
            };
            return wood;
        }

        public static Item MakeFlint()
        {
            var flint = new Item("Knapping Flint")
            {
                Description = "Sharp-edged stone perfect for making cutting tools and starting fires.",
                Weight = 0.2
            };
            return flint;
        }

        public static Item MakeClay()
        {
            var clay = new Item("River Clay")
            {
                Description = "Malleable clay gathered from a riverbank. Could be shaped into vessels.",
                Weight = 1.0
            };
            return clay;
        }

        public static Item MakeStone()
        {
            var item = new Item("River Stone")
            {
                Description = "A smooth river stone. Useful for tools or cooking.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeBone()
        {
            var bone = new Item("Animal Bone")
            {
                Description = "A sturdy bone from a large animal. Good material for tools and weapons.",
                Weight = 0.3
            };
            return bone;
        }

        public static Weapon MakeSpear()
        {
            Weapon spear = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Hunting Spear", 65)
            {
                Description = "A long wooden shaft with a sharpened flint point. Good for hunting and defense.",
                Weight = 1.5
            };
            return spear;
        }

        public static Weapon MakeClub()
        {
            Weapon club = new Weapon(WeaponType.Club, WeaponMaterial.Wood, "War Club", 60)
            {
                Description = "A heavy wooden club reinforced with stone. Brutal but effective.",
                Weight = 2.0
            };
            return club;
        }

        public static Weapon MakeHandAxe()
        {
            Weapon axe = new Weapon(WeaponType.HandAxe, WeaponMaterial.Stone, "Stone Hand Axe", 70)
            {
                Description = "A sharp stone blade bound to a wooden handle with animal sinew.",
                Weight = 1.8
            };
            return axe;
        }

        public static Weapon MakeKnife()
        {
            Weapon knife = new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Flint Knife", 75)
            {
                Description = "A razor-sharp flint blade with a bone handle. Essential for skinning and cutting.",
                Weight = 0.4
            };
            return knife;
        }

        public static Armor MakeHideShield()
        {
            Armor shield = new Armor("Hide Shield", .15, EquipSpots.Hands, 1)
            {
                Description = "A wooden frame covered with animal hide. Offers basic protection.",
                Weight = 2.0
            };
            return shield;
        }

        public static Armor MakeFurArmor()
        {
            Armor armor = new Armor("Fur Armor", .25, EquipSpots.Chest, 8)
            {
                Description = "A thick fur pelt worn as protection. Offers warmth and some defense against attacks.",
                Weight = 3.0
            };
            return armor;
        }

        public static FoodItem MakeLargeMeat()
        {
            var item = new FoodItem("Large Game Meat", 600, 0)
            {
                Description = "A substantial cut of meat from a large animal. Will need to be cooked.",
                Weight = 1.5
            };
            return item;
        }

        public static FoodItem MakeSmallMeat()
        {
            var item = new FoodItem("Small Game Meat", 200, 0)
            {
                Description = "A modest portion of meat from a small animal. Best cooked before eating.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeHealingHerbs()
        {
            var herbs = new FoodItem("Healing Herbs", 10, 5)
            {
                Description = "A bundle of medicinal plants known for their healing properties.",
                Weight = 0.2,
                NumUses = 1,
                HealthEffect = new()
                {
                    Amount = 15,
                    Type = "herbal",
                    Quality = 0.7,
                    TargetPart = null
                }
            };
            return herbs;
        }

        public static Item MakeBandage()
        {
            var bandage = new ConsumableItem("Bark Bandage")
            {
                Description = "Strips of inner tree bark pounded soft. Can bind wounds and stop bleeding.",
                Weight = 0.1,
                Effects = [
                    new RemoveBleedEffect("bandage", null)
                ]
            };
            return bandage;
        }

        public static Gear MakeTorch()
        {
            Gear torch = new Gear("Pine Torch", 0.8)
            {
                Description = "A branch wrapped with resin-soaked pine needles. Provides light and warmth.",
                Warmth = 5
            };
            return torch;
        }

        public static FoodItem MakeFish()
        {
            var item = new FoodItem("River Fish", 200, 0)
            {
                Description = "A freshly caught fish. Rich in nutrients and relatively easy to obtain near water.",
                Weight = 0.4
            };
            return item;
        }

        public static Item MakeVenomSac()
        {
            Item venom = new WeaponModifierItem("Venom Sac")
            {
                Description = "A fragile sac of venom extracted from a poisonous creature. Could coat a weapon.",
                Weight = 0.1,
                NumUses = 2,
                Damage = 2
            };
            return venom;
        }

        public static Item MakeSpiderSilk()
        {
            Item silk = new ArmorModifierItem("Spider Silk", [EquipSpots.Hands, EquipSpots.Feet, EquipSpots.Head])
            {
                Weight = 0.1,
                Description = "Fine, strong threads collected from giant spider webs. Useful for binding and insulation.",
                Warmth = 0.5
            };
            return silk;
        }

        public static Armor MakeFurHood()
        {
            Armor hood = new Armor("Fur Hood", .05, EquipSpots.Head, 3)
            {
                Description = "A hood made from animal fur. Keeps the head and ears warm in frigid weather.",
                Weight = 0.3
            };
            return hood;
        }

        public static Armor MakeLeatherTunic()
        {
            Armor tunic = new Armor("Leather Tunic", .10, EquipSpots.Chest, 4)
            {
                Description = "A simple tunic made from tanned animal hide. Basic protection from the elements.",
                Weight = 1.5
            };
            return tunic;
        }

        public static Armor MakeLeatherLeggings()
        {
            Armor leggings = new Armor("Leather Leggings", .08, EquipSpots.Legs, 3)
            {
                Description = "Leggings made from tanned animal hide. Protects the legs from brush and minor injuries.",
                Weight = 1.0
            };
            return leggings;
        }

        public static Armor MakeMoccasins()
        {
            Armor shoes = new Armor("Hide Moccasins", .03, EquipSpots.Feet, 2)
            {
                Description = "Soft footwear made from animal hide. More durable than bare feet on rough terrain.",
                Weight = 0.4
            };
            return shoes;
        }

        public static Item MakeMammothTusk()
        {
            Item tusk = new WeaponModifierItem("Mammoth Tusk")
            {
                Description = "A massive curved tusk from a woolly mammoth. Extremely valuable and rare.",
                Weight = 10.0,
                NumUses = 1,
                Damage = 5
            };
            return tusk;
        }

        public static Item MakeSaberToothFang()
        {
            Item fang = new WeaponModifierItem("Saber-Tooth Fang")
            {
                Description = "A long, curved fang from a saber-tooth tiger. Could be fashioned into a deadly weapon.",
                Weight = 0.3,
                NumUses = 1,
                Damage = 4
            };
            return fang;
        }

        public static Item MakeAntlerTine()
        {
            Item antler = new Item("Antler Tine")
            {
                Description = "A prong from a deer or elk antler. Useful for punching holes in hide or as a tool.",
                Weight = 0.2
            };
            return antler;
        }

        public static Item MakeSinew()
        {
            Item sinew = new Item("Animal Sinew")
            {
                Description = "Tough fibrous tissue from animal tendons. Essential for binding, sewing and bowstrings.",
                Weight = 0.1
            };
            return sinew;
        }

        public static Armor MakeBoneNecklace()
        {
            Armor necklace = new Armor("Bone Talisman", 0, EquipSpots.Chest, 0.5)
            {
                Description = "A primitive necklace made from small bones and stones. Said to bring good fortune.",
                Weight = 0.1
            };
            return necklace;
        }

        public static Item MakeObsidianShard()
        {
            Item obsidian = new Item("Obsidian Shard")
            {
                Description = "A piece of naturally occurring volcanic glass. Can be knapped into extremely sharp tools.",
                Weight = 0.2
            };
            return obsidian;
        }

        public static Item MakeOchrePigment()
        {
            Item ochre = new Item("Red Ochre")
            {
                Description = "Earthy clay pigment used for body decoration, cave paintings, and hide treatment.",
                Weight = 0.3
            };
            return ochre;
        }
    }
}================================================================================

File: ./obj/Debug/net8.0/text_survival.GlobalUsings.g.cs
--------------------------------------------------------------------------------
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
================================================================================

File: ./obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
--------------------------------------------------------------------------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
================================================================================

File: ./obj/Debug/net8.0/text_survival.AssemblyInfo.cs
--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("text_survival")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+aa9f647ebc390c36992fcfbfe28c167492205ca9")]
[assembly: System.Reflection.AssemblyProductAttribute("text_survival")]
[assembly: System.Reflection.AssemblyTitleAttribute("text_survival")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

================================================================================

File: ./Level/Skill.cs
--------------------------------------------------------------------------------
﻿

using text_survival.IO;

namespace text_survival.Level
{
    public class Skill
    {
        public int Xp;
        public int Level { get; private set; }
        public string Name { get; set; }
        public int LevelUpThreshold => (Level) * 10;

        public Skill(string name)
        {
            Name = name;
            Xp = 0;
            Level = 0;
        }
        public void GainExperience(int xp)
        {
            Xp += xp;

            if (Xp < LevelUpThreshold) return;
            // else level up
            Xp -= LevelUpThreshold;
            LevelUp();
        }

        public void LevelUp()
        {
            Level++;
            Output.WriteLine("You leveled up ", this, " to level ", Level, "!");
        }

        public override string ToString() => Name;

        public void Describe()
        {
            Output.Write(this, ": ", Level, " (", Xp, "/", LevelUpThreshold, ")");
        }



    }
}
================================================================================

File: ./Level/SkillRegistry.cs
--------------------------------------------------------------------------------
﻿
using text_survival.IO;

namespace text_survival.Level
{
    public class SkillRegistry
    {
        private readonly Dictionary<string, Skill> skills;

        public SkillRegistry(bool fullSkills = true)
        {
            skills = [];
            if (fullSkills)
            {
                skills.Add("Fighting", new Skill("Fighting"));
                skills.Add("Endurance", new Skill("Endurance"));
                skills.Add("Agility", new Skill("Reflexes"));
                skills.Add("Defense", new Skill("Defense"));
                
                skills.Add("Hunting", new Skill("Hunting"));
                skills.Add("Toolmaking", new Skill("Toolmaking"));
                skills.Add("Foraging", new Skill("Foraging"));
                skills.Add("Firecraft", new Skill("Firecraft"));
                skills.Add("Mending", new Skill("Mending"));
                skills.Add("Healing", new Skill("Healing"));
                skills.Add("Shamanism", new Skill("Shamanism"));
            }
            else
            {
                skills.Add("Melee", new Skill("Fighting"));
                skills.Add("Endurance", new Skill("Endurance"));
                skills.Add("Agility", new Skill("Reflexes"));
                skills.Add("Defense", new Skill("Defense"));
            }
        }

        public void AddExperience(string skillName, int xp)
        {
            if (skills.ContainsKey(skillName))
                skills[skillName].GainExperience(xp);
        }

        public int GetLevel(string skillName) => skills.TryGetValue(skillName, out Skill? value) ? value.Level : 1;

        public Skill? GetSkill(string skillName) => skills.TryGetValue(skillName, out Skill? value) ? value : null;

        public void Describe()
        {
            Output.WriteLine("Skills:");
            foreach (var skill in skills.Values)
            {
                Output.WriteLine($"{skill.Name}: {skill.Level} ({skill.Xp}/{skill.LevelUpThreshold})");
            }
        }
    }
}================================================================================

File: ./Level/Perk.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Level
{
    internal class Perk
    {
    }
}
================================================================================

File: ./PlayerComponents/LocationManger.cs
--------------------------------------------------------------------------------
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

class LocationManager
{
    public LocationManager(Location startingLocation)
    {
        Map = new WorldMap(startingLocation.Parent);
        _currentLocation = startingLocation;
        startingLocation.Visited = true;
    }
    private WorldMap Map { get; }
    public Location CurrentLocation
    {
        get
        {
            return _currentLocation;
        }
        set
        {
            Output.WriteLine("You go to the ", value);
            int minutes = Utils.RandInt(1, 10);
            World.Update(minutes);
            Output.WriteLine("You arrive at the ", value, " after walking ", minutes, " minutes.");
            _currentLocation = value;
            Output.WriteLine("You should probably look around.");
        }
    }
    private Location _currentLocation;

    public Zone CurrentZone
    {
        get
        {
            return Map.CurrentZone;
        }
        set
        {
            if (CurrentZone == value)
            {
                Output.WriteLine("There's nowhere to leave. Travel instead.");
                return;
            }
            if (Map.North == value)
            {
                Output.WriteLine("You go north.");
                Map.MoveNorth();
            }
            else if (Map.East == value)
            {
                Output.WriteLine("You go east.");
                Map.MoveEast();
            }
            else if (Map.South == value)
            {
                Output.WriteLine("You go south.");
                Map.MoveSouth();
            }
            else if (Map.West == value)
            {
                Output.WriteLine("You go west.");
                Map.MoveWest();
            }
            else
                throw new Exception("Invalid zone.");
            Location? newLocation = Utils.GetRandomFromList(value.Locations);

            CurrentLocation = newLocation ?? throw new Exception("No Locations In Zone");
            Output.WriteLine("You enter ", value);
            Output.WriteLine(value.Description);
        }
    }

    public bool RemoveItemFromLocation(Item item)
    {
        if (_currentLocation.Items.Contains(item))
        {
            _currentLocation.Items.Remove(item);
            return true;
        }
        return false;
    }

    public void AddItemToLocation(Item item)
    {
        _currentLocation.Items.Add(item);
    }

    public void TravelToAdjacentZone()
    {
        Output.WriteLine("Where would you like to go?");

        Output.WriteLine(1, ". North: ", (Map.North.Visited ? Map.North.Name : " Unknown"));
        Output.WriteLine(2, ". East: ", (Map.East.Visited ? Map.East.Name : " Unknown"));
        Output.WriteLine(3, ". South: ", (Map.South.Visited ? Map.South.Name : " Unknown"));
        Output.WriteLine(4, ". West: ", (Map.West.Visited ? Map.West.Name : " Unknown"));

        Output.WriteLine("0. Cancel");
        int input = Input.ReadInt(0, 4);

        if (input == 0) return;

        int minutes = Utils.RandInt(30, 60);
        Output.WriteLine("You travel for ", minutes, " minutes...");

        switch (input)
        {
            case 1:
                CurrentZone = Map.North;
                break;
            case 2:
                CurrentZone = Map.East;
                break;
            case 3:
                CurrentZone = Map.South;
                break;
            case 4:
                CurrentZone = Map.West;
                break;
        }

        World.Update(minutes);
    }

}================================================================================

File: ./PlayerComponents/CombatManager.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.PlayerComponents;
public class CombatManager
{
    public CombatManager(Actor owner)
    {
        Owner = owner;
    }

    public double CalculateAttackDamage(double baseDamage, double strength, double skillBonus, double otherModifiers)
    {
        double strengthModifier = (strength + 50) / 100;
        double damage = (baseDamage + skillBonus) * strengthModifier * otherModifiers;
        damage *= Utils.RandDouble(0.5, 2);
        return damage >= 0 ? damage : 0;
    }


    public double DetermineDamage()
    {
        double skillBonus = Owner._skillRegistry.GetLevel("Fighting");

        double conditionModifier = (2 - (Owner.ConditionPercent / 100)) / 2 + 0.1;
        return CalculateAttackDamage(
            Owner.ActiveWeapon.Damage, Owner.Body.CalculateStrength(), skillBonus, conditionModifier);
    }

    public double DetermineDodgeChance(Actor target)
    {
        double dodgeLevel = target._skillRegistry != null ? target._skillRegistry.GetLevel("Reflexes") : 0;
        double baseDodge = dodgeLevel / 100;
        double speedDiff = target.Body.CalculateSpeed() - Owner.Body.CalculateSpeed();
        double chance = baseDodge + speedDiff;
        // Output.WriteLine("Debug: Dodge Chance = ", chance);
        chance = Math.Clamp(chance, 0, .95);
        return chance;
    }

    public bool DetermineDodge(Actor target)
    {
        double dodgeChance = DetermineDodgeChance(target);
        if (Utils.DetermineSuccess(dodgeChance))
        {
            Output.WriteLine($"{Owner} dodged the attack!");
            return true;
        }
        return false;
    }

    public bool DetermineHit()
    {
        // Output.WriteLine("Debug: hit Chance: ", Owner.ActiveWeapon.Accuracy);
        double hitChance = Math.Clamp(Owner.ActiveWeapon.Accuracy, .01, .95);
        if (!Utils.DetermineSuccess(hitChance))
        {
            Output.WriteLine($"{Owner} missed!");
            return false;
        }
        return true;
    }

    public bool DetermineBlock(Actor target)
    {
        double blockLevel = target._skillRegistry != null ? target._skillRegistry.GetLevel("Defense") : 0;
        double skillBonus = blockLevel / 100;
        double attributeAvg =  target.Body.CalculateStrength(); // todo 
        double blockAtbAvg = target.ActiveWeapon.BlockChance + attributeAvg / 2;
        double blockChance = blockAtbAvg + skillBonus;
        if (Utils.DetermineSuccess(blockChance))
        {
            Output.WriteLine($"{target} blocked the attack!");
            return true;
        }
        return false;
    }

    public void Attack(Actor target)
    {
        double damage = DetermineDamage();
        if (DetermineDodge(target))
            return;
        if (!DetermineHit())
            return;
        if (DetermineBlock(target))
            return;

        DamageInfo damageInfo = new(
            damage,
            source: Owner.Name,
            isSharp: Owner.ActiveWeapon.Class == Items.WeaponClass.Blade,
            isBlunt: Owner.ActiveWeapon.Class == Items.WeaponClass.Blunt || Owner.ActiveWeapon.Class == Items.WeaponClass.Unarmed,
            accuracy: Owner.ActiveWeapon.Accuracy
        );

        Output.WriteLine($"{Owner} attacked {target} for {Math.Round(damage, 1)} damage!");
        target.Damage(damageInfo);
        // if (Utils.RandFloat(0, 1) < 0.1) // 10% critical hit chance
        //     target.ApplyEffect(new BleedEffect(1, 3));


        Owner._skillRegistry.AddExperience("Fighting", 1);
        Thread.Sleep(1000);
    }


    public Actor Owner { get; }
}
================================================================================

File: ./PlayerComponents/InventoryManager.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

public class InventoryManager
{
    public InventoryManager(EffectRegistry effectRegistry)
    {
        Armor = [];
        _unarmed = ItemFactory.MakeFists();
        Inventory = new Container("Bag", 10);
        _effectRegistry = effectRegistry;
    }
    private Container Inventory { get; }
    public List<Armor> Armor { get; }
    public Gear? HeldItem { get; private set; }
    private EffectRegistry _effectRegistry { get; }
    // weapon
    private Weapon? _weapon;
    private readonly Weapon _unarmed;
    public bool IsArmed => Weapon != _unarmed;
    public bool IsArmored => Armor.Count != 0;

    public Armor? GetArmorInSpot(EquipSpots spot) => Armor.FirstOrDefault(i => i.EquipSpot == spot);
    public Weapon Weapon
    {
        get => _weapon ?? _unarmed;
        set => _weapon = value;
    }

    public void AddToInventory(Item item)
    {
        Output.WriteLine("You put the ", item, " in your ", Inventory);
        Inventory.Add(item);
    }

    public void RemoveFromInventory(Item item)
    {
        Output.WriteLine("You take the ", item, " from your ", Inventory);
        Inventory.Remove(item);
    }

    public double ArmorRating
    {
        get
        {
            double rating = 0;
            foreach (Armor armor in Armor)
            {
                rating += armor.Rating;
                // rating += armor.Type switch
                // {
                //     ArmorClass.Light => Skills.LightArmor.Level * .01,
                //     ArmorClass.Heavy => Skills.HeavyArmor.Level * .01,
                //     _ => throw new ArgumentOutOfRangeException()
                // };
            }
            return rating;
        }
    }

    public double EquipmentWarmth => (HeldItem?.Warmth ?? 0) + Armor.Sum(a => a.Warmth);

    public void Equip(IEquippable item)
    {
        switch (item)
        {
            case Weapon weapon:
                Unequip(Weapon);
                Weapon = weapon;
                break;
            case Armor armor:
                var oldItem = Armor.FirstOrDefault(i => i.EquipSpot == armor.EquipSpot);
                if (oldItem != null) Unequip(oldItem);
                Armor.Add(armor);
                break;
            case Gear gear:
                if (HeldItem != null) Unequip(HeldItem);
                HeldItem = gear;
                break;
            default:
                Output.WriteLine("You can't equip that.");
                return;
        }
        Inventory.Remove((Item)item);
        item.EquipEffects.ForEach(_effectRegistry.AddEffect);
    }
    public void Unequip(IEquippable item)
    {
        if (item is not Gear gear) return;
        if (item == _unarmed) return;

        switch (gear)
        {
            case Weapon weapon:
                Weapon = _unarmed;
                break;
            case Armor armor:
                Armor.Remove(armor);
                break;
            case Gear g:
                HeldItem = null;
                break;
            default:
                Output.WriteLine("You can't unequip that.");
                return;
        }
        Output.WriteLine("You unequip ", gear);
        Inventory.Add(gear);
        gear.EquipEffects.ForEach(_effectRegistry.RemoveEffect);
    }
    public void CheckGear()
    {
        Describe.DescribeGear(this);
        Output.WriteLine("Would you like to unequip an item?");
        if (Input.ReadYesNo()) return;

        Output.WriteLine("Which item would you like to unequip?");
        // get list of all equipment
        var equipment = new List<IEquippable>();
        equipment.AddRange(Armor);
        if (IsArmed) equipment.Add(Weapon);
        if (HeldItem != null) equipment.Add(HeldItem);

        var choice = Input.GetSelectionFromList(equipment, true);
        if (choice == null) return;
        Unequip(choice);
    }

    public void Open(Player player)
    {
        while (!Inventory.IsEmpty)
        {
            Output.WriteLine(Inventory, " (", Inventory.Weight(), "/", Inventory.MaxWeight, "):");

            var options = ItemStack.CreateStacksFromItems(Inventory.Items);
            var selection = Input.GetSelectionFromList(options, true, "Close " + Inventory);
            if (selection == null) return;

            Item item = selection.Take();

            Output.WriteLine("What would you like to do with ", item);
            string? choice = Input.GetSelectionFromList(["Use", "Inspect", "Drop"], true);

            switch (choice)
            {
                case null:
                    continue;
                case "Use":
                    player.UseItem(item);
                    break;
                case "Inspect":
                    Describe.DescribeItem(item);
                    break;
                case "Drop":
                    player.DropItem(item);
                    break;
            }
        }
        Output.WriteLine(Inventory, " is empty.");
    }
}
================================================================================

File: ./PlayerComponents/SpellManager.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.IO;
using text_survival.Level;
using text_survival.Magic;

namespace text_survival.PlayerComponents;

class SpellManager
{
    public SpellManager(SkillRegistry skills)
    {
        _skills = skills;
        _spells.Add(SpellFactory.Bleeding);
        _spells.Add(SpellFactory.Poison);
        _spells.Add(SpellFactory.MinorHeal);
    }
    private readonly List<Spell> _spells = [];
    private readonly SkillRegistry _skills;
    public void SelectSpell(List<Actor> targets)
    {
        //get spell
        Output.WriteLine("Which spell would you like to cast?");
        var spell = Input.GetSelectionFromList(_spells, true);
        if (spell == null) return;

        // get target
        Output.WriteLine("Who would you like to cast ", spell.Name, " on?");
        var target = Input.GetSelectionFromList(targets, true);
        if (target == null) return;

        CastSpell(spell, target);
    }

    public void CastSpell(Spell spell, Actor target)
    {
        if (spell.NeedsTargetPart)
        {
            Output.WriteLine("Select a part to target:");
            var parts = target.Body.GetAllParts();
            var part = Input.GetSelectionFromList(parts)!;
            spell.Cast(target, part);
        }
        else
        {
            spell.Cast(target);
        }
        _skills.AddExperience("Shamanism", 2);
    }
}================================================================================

File: ./PlayerComponents/SurvivalManager.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;
using text_survival.Survival;
using text_survival.Effects;
using text_survival.Bodies;

namespace text_survival.PlayerComponents;

public class SurvivalManager
{
    public SurvivalManager(Actor owner, EffectRegistry effectRegistry)
    {
        Owner = owner;
        HungerModule = new HungerModule();
        ThirstModule = new ThirstModule();
        ExhaustionModule = new ExhaustionModule();
        TemperatureModule = new TemperatureModule();
        _effectRegistry = effectRegistry;
    }

    private readonly EffectRegistry _effectRegistry;
    // public void AddEffect(IEffect effect) => _effectRegistry.AddEffect(effect);
    // public void RemoveEffect(string effectType) => _effectRegistry.RemoveEffect(effectType);

    public void Heal(HealingInfo heal) => Owner.Heal(heal);
    public void Damage(DamageInfo damage)
    {
        Owner.Damage(damage);

        if (!Owner.IsAlive)
        {
            Output.WriteLine(Owner, " died!");
        }
    }


    public void Sleep(int minutes)
    {
        int minutesSlept = 0;
        while (minutesSlept < minutes)
        {
            ExhaustionModule.Rest(1);
            World.Update(1);
            minutesSlept++;
            if (ExhaustionModule.IsFullyRested)
            {
                Output.Write("You wake up feeling refreshed.\n");
                break;
            }
        }
        HealingInfo healing = new HealingInfo()
        {
            Amount = minutesSlept / 10,
            Type = "natural",
            TargetPart = "Body",
            Quality = ExhaustionModule.IsFullyRested ? 1 : .7, // healing quality is better after a full night's sleep
        };

        Heal(healing);
    }


    public void ConsumeFood(FoodItem food)
    {
        // todo handle eating half an item
        // if (HungerModule.Amount - food.Calories < 0)
        // {
        //     Output.Write("You are too full to finish it.\n");
        //     int percentageEaten = (int)(HungerModule.Amount / food.Calories) * 100;
        //     double calories = food.Calories * (100 - percentageEaten);
        //     double waterContent = food.WaterContent * (100 - percentageEaten);
        //     double weight = food.Weight * (100 - percentageEaten);
        //     food.calories = (int)calories;
        //     food.waterContent = (int)waterContent;
        //     food.weight
        //     // food = new FoodItem(food.Name, (int)calories, (int)waterContent, weight);
        //     HungerModule.Amount = 0;
        //     return;
        // }
        HungerModule.AddCalories(food.Calories);
        ThirstModule.AddHydration(food.WaterContent);

        if (food.HealthEffect != null)
        {
            Heal(food.HealthEffect);
        }
        if (food.DamageEffect != null)
        {
            Damage(food.DamageEffect);
        }
    }



    public void Update()
    {
        if (Owner is Player player)
        {
            // todo add more detailed equipment stats like warmth, wind, and water resistance
            double feelsLikeTemp = player.CurrentLocation.GetTemperature() + player.EquipmentWarmth;

            HungerModule.Update();
            ThirstModule.Update();
            ExhaustionModule.Update();
            TemperatureModule.Update(feelsLikeTemp);

            if (HungerModule.IsStarving || TemperatureModule.IsDangerousTemperature)
            {
                var damage = new DamageInfo()
                {
                    Amount = 1,
                    Type = TemperatureModule.IsDangerousTemperature ? "thermal" : "starvation",
                    IsPenetrating = HungerModule.IsStarving,
                };
                player.Damage(damage);
            }
        }
    }

    private Actor Owner { get; }
    private HungerModule HungerModule { get; }
    private ThirstModule ThirstModule { get; }
    private ExhaustionModule ExhaustionModule { get; }
    private TemperatureModule TemperatureModule { get; }

    // general condition, for now avg of exhaustion and body health
    public double ConditionPercent => (ExhaustionModule.ExhaustionPercent + (Owner.Body.Health / Owner.Body.MaxHealth * 100)) / 2;

    public void Describe()
    {
        HungerModule.Describe();
        ThirstModule.Describe();
        ExhaustionModule.Describe();
        TemperatureModule.Describe();
    }

}
================================================================================

File: ./Effects/BleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects;

public class BleedEffect : Effect
{
    private float _damagePerHour;
    
    public BleedEffect(BodyPart targetPart, string source, float severity, float damagePerHour, int durationMin = -1)
        : base("Bleeding", source, targetPart, severity)
    {
        _damagePerHour = damagePerHour;
        
        // Configure effect properties
        SeverityChangeRate = -0.05f; // Natural clotting
        IsStackable = true; // Multiple cuts can stack
        
        // Configure capacity modifiers
        CapacityModifiers["BloodPumping"] = 0.2f; // Reduces blood pumping capacity by 20%
        CapacityModifiers["Consciousness"] = 0.1f; // Minor consciousness impact
    }
    
    protected override void OnApply(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"{target}'s {location} is bleeding!");
    }
    
    protected override void OnUpdate(Actor target)
    {
        // Calculate damage for one minute based on severity
        double damage = _damagePerHour / 60.0 * Severity;
        
        // Apply damage to the specific body part
        var damageInfo = new DamageInfo
        {
            Amount = damage,
            Type = "bleed",
            Source = Source,
            IsPenetrating = true, // Bleeding damage always penetrates
            TargetPart = TargetBodyPart?.Name
        };
        
        target.Damage(damageInfo);
        
        // Occasionally remind player of bleeding
        if (Utils.DetermineSuccess(0.05f) && Severity > 0.3f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"Blood continues to flow from {target}'s {location}...");
        }
    }
    
    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        if (updatedSeverity < 0.2f && oldSeverity >= 0.2f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"The bleeding on {target}'s {location} is slowing.");
        }
    }
    
    protected override void OnRemove(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"The bleeding on {target}'s {location} has stopped.");
    }
}================================================================================

File: ./Effects/RemoveBleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects
{
    public class RemoveBleedEffect : Effect
    {
        public RemoveBleedEffect(string source, BodyPart? targetBodyPart) : base("RemoveBleed", source, targetBodyPart, severity: 1.0f)
        {
        }

        protected override void OnApply(Actor target)
        {
            var effects = target.GetEffectsByKind("bleed");
            if (effects.Count == 0)
            {
                effects = target.GetEffectsByKind("bleeding");
                if (effects.Count == 0)
                {
                    Output.WriteWarning("There was no bleeding to stop");
                    this.Remove(target);
                    return;
                }
            }
            var bleed = effects[0];
            bleed.Remove(target);
            Output.WriteLine(target, " stopped bleeding.");
            this.Remove(target);
        }
    }
}================================================================================

File: ./Effects/HealEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;
public class HealEffect : Effect
{
    private float _healAmountPerHour;
    private string _targetPartName;

    public HealEffect(string source, BodyPart targetPart, float healAmount, int durationMin = 60)
        : base("Healing", source, targetPart, 1.0f)
    {
        _healAmountPerHour = healAmount;
        _targetPartName = targetPart?.Name ?? "body";

        // Configure effect properties
        IsStackable = false; // Healing doesn't stack
        SeverityChangeRate = -1.0f / durationMin; // Decreases to 0 over duration
    }

    protected override void OnApply(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"{Source} begins healing {target}'s {location}.");
    }

    protected override void OnUpdate(Actor target)
    {
        // Calculate healing for one minute
        float healAmount = _healAmountPerHour / 60.0f;

        // Apply healing
        var healInfo = new HealingInfo
        {
            Amount = healAmount,
            Quality = 1.0,
            Source = Source,
            TargetPart = _targetPartName
        };

        target.Heal(healInfo);

        // Visual effect based on severity (how much healing is left)
        if (Utils.DetermineSuccess(0.05f))
        {
            string location = _targetPartName;
            if (Severity > 0.7f)
            {
                Output.WriteLine($"Fresh healing is occurring in {target}'s {location}.");
            }
            else if (Severity > 0.3f)
            {
                Output.WriteLine($"The healing in {target}'s {location} continues steadily.");
            }
            else
            {
                Output.WriteLine($"The healing in {target}'s {location} is nearly complete.");
            }
        }
    }

    protected override void OnRemove(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"The healing process on {target}'s {location} is complete.");
    }
}================================================================================

File: ./Effects/EffectRegistry.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;
public class EffectRegistry(Actor owner)
{
    public void AddEffect(Effect effect)
    {
        if (_effects.Contains(effect)) return;

        BodyPart? part = effect.TargetBodyPart;
        if (part != null)
        {
            if (!effect.IsStackable)
            {
                var existingEffect = _effects.FirstOrDefault(e => e.TargetBodyPart == part && e.EffectKind == effect.EffectKind);
                if (existingEffect != null)
                {
                    double newSeverity = Math.Max(existingEffect.Severity, effect.Severity);
                    existingEffect.UpdateSeverity(_owner, newSeverity);
                    return;
                }
            }
        }

        _effects.Add(effect);
        effect.Apply(_owner);
    }

    public void RemoveEffect(Effect effect)
    {
        if (_effects.Remove(effect))
        {
            effect.Remove(_owner);
        }
        else
        {
            Output.WriteWarning("ERROR: couldn't find effect to remove.");
        }
    }
    public void Update()
    {
        _effects.ForEach(e => e.Update(_owner));
        // Clean up inactive effects
        _effects.RemoveAll(e => !e.IsActive);
    }


    public double GetPartCapacityModifier(string capacity, BodyPart part) => GetEffectsOnBodyPart(part).Sum(e => e.CapacityModifiers.GetValueOrDefault(capacity) * e.Severity);
    public double GetBodyCapacityModifier(string capacity) => _effects.Where(e => e.TargetBodyPart == null).Sum(e => e.CapacityModifiers.GetValueOrDefault(capacity) * e.Severity);


    public List<Effect> GetEffectsOnBodyPart(BodyPart part) => [.. _effects.Where(e => e.TargetBodyPart == part)];
    public List<Effect> GetEffectsByKind(string kind) => [.. _effects.Where(e => e.EffectKind.ToLower() == kind.ToLower())];


    private readonly Actor _owner = owner;
    private List<Effect> _effects = [];
}================================================================================

File: ./Effects/PoisonEffect.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

public class PoisonEffect : Effect
{
    private float _damagePerHour;
    private string _poisonType;
    
    public PoisonEffect(string poisonType, string source, float severity, float damagePerHour, int durationMin = 60)
        : base("Poison", source, null, severity) // Poison is typically whole-body
    {
        _damagePerHour = damagePerHour;
        _poisonType = poisonType;
        
        // Configure effect properties
        SeverityChangeRate = -0.02f; // Slow natural detoxification
        IsStackable = true; // Multiple poison sources can stack
        
        // Configure capacity modifiers - affect whole body
        CapacityModifiers["Consciousness"] = 0.3f * severity;
        CapacityModifiers["Manipulation"] = 0.2f * severity;
        CapacityModifiers["Moving"] = 0.2f * severity;
        CapacityModifiers["BloodFiltration"] = 0.4f * severity;
    }
    
    protected override void OnApply(Actor target)
    {
        Output.WriteLine($"{target} has been poisoned with {_poisonType}!");
    }
    
    protected override void OnUpdate(Actor target)
    {
        // Calculate damage for one minute based on severity
        double damage = _damagePerHour / 60.0 * Severity;
        
        // Apply poison damage randomly to internal organs
        // Get list of internal parts
        var internalParts = target.Body.GetAllParts()
            .Where(p => p.IsInternal && !p.IsDestroyed)
            .ToList();
            
        if (internalParts.Count > 0)
        {
            // Target a random internal organ for damage
            var targetPart = internalParts[Utils.RandInt(0, internalParts.Count - 1)];
            
            var damageInfo = new DamageInfo
            {
                Amount = damage,
                Type = "poison",
                Source = Source,
                IsPenetrating = true, // Poison always penetrates
                TargetPart = targetPart.Name
            };
            
            target.Damage(damageInfo);
        }
        else
        {
            // Fallback to general damage
            var damageInfo = new DamageInfo
            {
                Amount = damage,
                Type = "poison",
                Source = Source,
                IsPenetrating = true
            };
            
            target.Damage(damageInfo);
        }
        
        // Symptoms based on severity
        if (Severity > 0.7 && Utils.DetermineSuccess(0.2))
        {
            Output.WriteLine($"{target} vomits violently from the {_poisonType} poisoning.");
        }
        else if (Severity > 0.4f && Utils.DetermineSuccess(0.1))
        {
            Output.WriteLine($"{target} trembles from the effects of the {_poisonType} poison.");
        }
    }
    
    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update capacity modifiers based on new severity
        CapacityModifiers["Consciousness"] = 0.3 * updatedSeverity;
        CapacityModifiers["Manipulation"] = 0.2 * updatedSeverity;
        CapacityModifiers["Moving"] = 0.2 * updatedSeverity;
        
        if (updatedSeverity < 0.3 && oldSeverity >= 0.3)
        {
            Output.WriteLine($"The {_poisonType} poisoning is becoming less severe.");
        }
    }
    
    protected override void OnRemove(Actor target)
    {
        Output.WriteLine($"{target} has recovered from {_poisonType} poisoning.");
    }
}================================================================================

File: ./Effects/Effect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects
{
    // public interface IEffect
    // {
    //     string EffectType { get; }
    //     bool IsActive { get; }
    //     // float Severity { get; }
    //     // int DurationMin { get; } // Total duration in minutes
    //     // int RemainingDurationMin { get; } // Remaining duration in minutes

    //     void Apply(IActor target);
    //     void Update(IActor target);
    //     void Remove(IActor target);
    // }

    public abstract class Effect
    {
        protected Effect(string effectKind, string source, BodyPart? targetBodyPart = null, double severity = 1, double severityChangeRate = 0)
        {
            EffectKind = effectKind;
            Source = source;
            TargetBodyPart = targetBodyPart;
            Severity = severity;
            SeverityChangeRate = severityChangeRate;

            IsActive = true;
            IsStackable = false;
            RequiresTreatment = false;
        }

        public string EffectKind { get; protected set; }
        public string Source { get; } // what caused this effect (e.g., cold, wound poison)
        public BodyPart? TargetBodyPart { get; set; }
        public bool IsStackable { get; protected set; }
        public bool IsActive { get; protected set; }
        public double Severity { get; protected set; }
        public double SeverityChangeRate { get; protected set; } // per severity reduction per hour
        public bool RequiresTreatment { get; protected set; }
        public Dictionary<string, double> CapacityModifiers { get; } = [];
        // public List<TreatmentOption> TreatmentOptions {get;}

        // main algorithm methods - typically don't override
        public void Apply(Actor target)
        {
            IsActive = true;
            OnApply(target);
        }

        public void Update(Actor target)
        {
            if (!IsActive) return;

            if (!RequiresTreatment && SeverityChangeRate > 0)
            {
                double minuteChange = SeverityChangeRate / 60;
                double oldSeverity = Severity;
                Severity = Math.Max(0, Severity + minuteChange);

                if (Math.Abs(Severity - oldSeverity) > .01)
                {
                    OnSeverityChange(target, oldSeverity, Severity);
                }

                if (Severity <= 0)
                {
                    Remove(target);
                    return;
                }
            }

            OnUpdate(target);
        }
        public void Remove(Actor target)
        {
            if (!IsActive) return;
            OnRemove(target);
            IsActive = false;
        }
        public virtual void UpdateSeverity(Actor target, double severityChange)
        {
            if (!IsActive) return;

            double oldSeverity = Severity;

            Severity = Math.Clamp(Severity + severityChange, 0, 1);

            if (Math.Abs(oldSeverity - Severity) > 0.01)
            {
                OnSeverityChange(target, oldSeverity, Severity);
            }
        }


        // hook methods that can be implemented by sub classes
        protected virtual void OnApply(Actor target) { }
        protected virtual void OnUpdate(Actor target) { }
        protected virtual void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity) { }
        protected virtual void OnRemove(Actor target) { }


        // UI methods
        public string GetSeverityDescription()
        {
            if (Severity < 0.3f) return "Minor";
            if (Severity < 0.7f) return "Moderate";
            if (Severity < 0.9f) return "Severe";
            return "Critical";
        }
        public virtual string Describe()
        {
            string severityDesc = GetSeverityDescription();
            string locationDesc = TargetBodyPart != null ? $" on {TargetBodyPart.Name}" : "";
            return $"{severityDesc} {EffectKind}{locationDesc}";
        }
    }
}================================================================================

File: ./Command.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public interface ICommand
    {
        public string Name { get; set; }
        public void Execute();
    }

    public class Command<TPlayer> : ICommand
    {
        public string Name { get; set; }
        public Action<TPlayer> Act { get; set; }
        public TPlayer? Player { get; set; }

        public Command(string name, Action<TPlayer> act)
        {
            Name = name;
            Act = act;
        }

        public void Execute()
        {
            if (Player == null)
            {
                throw new Exception("Player is null");
            }
            Act.Invoke(Player);
        }

        public override string ToString() => Name;
    }
}
================================================================================

File: ./Bodies/Injury.cs
--------------------------------------------------------------------------------
using text_survival.Effects;

namespace text_survival.Bodies;
public class Injury : Effect
{
    public eInjuryType InjuryType { get; }

    public enum eInjuryType
    {
        Cut,
        Bruise,
        Break,
        Burn,
        Frostbite,
        Infection
    }

    public Injury(eInjuryType type, string source, BodyPart bodyPart, float severity) : base(type.ToString(), source, bodyPart, severity)
    {
        InjuryType = type;
        Severity = Math.Clamp(severity, 0, 1);

        // Configure based on type
        switch (type)
        {
            case eInjuryType.Cut:
                EffectKind = "Cut";
                SeverityChangeRate = -0.05; // Per day
                CapacityModifiers["Manipulation"] = 0.3;
                CapacityModifiers["Moving"] = 0.1;
                break;

            case eInjuryType.Bruise:
                EffectKind = "Bruise";
                SeverityChangeRate = -0.1; // Per day
                CapacityModifiers["Manipulation"] = 0.1;
                CapacityModifiers["Moving"] = 0.1;
                break;

            case eInjuryType.Break:
                EffectKind = "Broken";
                SeverityChangeRate = -0.01; // Very slow healing
                CapacityModifiers["Manipulation"] = 0.8;
                CapacityModifiers["Moving"] = 0.8;
                break;

            case eInjuryType.Burn:
                EffectKind = "Burn";
                SeverityChangeRate = -0.03;
                CapacityModifiers["Manipulation"] = 0.4;
                break;

            case eInjuryType.Frostbite:
                EffectKind = "Frostbite";
                SeverityChangeRate = -0.02;
                CapacityModifiers["Manipulation"] = 0.5;
                CapacityModifiers["Moving"] = 0.5;
                break;

            case eInjuryType.Infection:
                EffectKind = "Infection";
                SeverityChangeRate = 0.02; // Gets worse over time
                CapacityModifiers["Manipulation"] = 0.2;
                CapacityModifiers["Vitality"] = 0.4;
                break;
        }
    }

    // public override void ApplyTreatment(TreatmentInfo treatment)
    // {
    //     // Different treatments have different effectiveness
    //     double effectiveAmount = 0;

    //     switch (treatment.Type)
    //     {
    //         case "bandage":
    //             if (InjuryType == eInjuryType.Cut || InjuryType == eInjuryType.Burn)
    //             {
    //                 effectiveAmount = 0.2;
    //             }
    //             break;

    //         case "splint":
    //             if (InjuryType == eInjuryType.Break)
    //             {
    //                 effectiveAmount = 0.1;
    //             }
    //             break;

    //         case "antibiotics":
    //             if (InjuryType == eInjuryType.Infection)
    //             {
    //                 effectiveAmount = 0.5;
    //             }
    //             break;

    //         case "warmth":
    //             if (InjuryType == eInjuryType.Frostbite)
    //             {
    //                 effectiveAmount = 0.3;
    //             }
    //             break;
    //     }

    //     // Apply quality factor
    //     effectiveAmount *= treatment.Quality;

    //     // Reduce severity
    //     Severity -= effectiveAmount;
    //     Severity = Math.Clamp(Severity, 0, 1);
    // }
}================================================================================

File: ./Bodies/BodyPart.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Bodies;
public class BodyPart
{
    // Core properties
    public string Name { get; }
    public double Health { get; private set; }
    public double MaxHealth { get; }
    public bool IsVital { get; }
    public bool IsInternal { get; }
    public bool IsDamaged => Health < MaxHealth;
    public bool IsDestroyed => Health <= 0;

    public double Coverage { get; set; } // Percentage of parent this part covers
    public double EffectiveCoverage { get; private set; }

    // Hierarchy
    public BodyPart? Parent { get; private set; }
    private List<BodyPart> _parts = new();
    public IReadOnlyList<BodyPart> Parts => _parts.AsReadOnly();

    // Physical state
    private Dictionary<string, double> _baseCapacities = new();

    public BodyPart(string name, double maxHealth, bool isVital, bool isInternal, double coverage)
    {
        Name = name;
        MaxHealth = maxHealth;
        Health = maxHealth;
        IsVital = isVital;
        IsInternal = isInternal;
        Coverage = coverage;
        _baseCapacities = new Dictionary<string, double>();
    }

    // Capacity management
    public void SetBaseCapacity(string capacity, double value)
    {
        _baseCapacities[capacity] = value;
    }

    public double GetCapacity(string capacity)
    {
        if (!_baseCapacities.TryGetValue(capacity, out double baseValue))
        {
            return 0;
        }

        // Apply health scaling
        return baseValue * (Health / MaxHealth);
    }

    public IReadOnlyDictionary<string, double> GetCapacities()
    {
        var result = new Dictionary<string, double>();
        foreach (var pair in _baseCapacities)
        {
            result[pair.Key] = GetCapacity(pair.Key);
        }
        return result;
    }


    // Hierarchical structure
    public void AddPart(BodyPart part)
    {
        part.Parent = this;
        _parts.Add(part);
    }

    public void Heal(HealingInfo healingInfo)
    {
        if (IsDestroyed) return;

        // Handle targeted healing
        if (healingInfo.TargetPart != null && healingInfo.TargetPart != Name)
        {
            // Try to find the targeted part
            var targetPart = FindPartByName(healingInfo.TargetPart);
            if (targetPart != null)
            {
                targetPart.Heal(healingInfo);
                return;
            }
        }

        // Distribute healing
        if (_parts.Count > 0 && healingInfo.TargetPart == null)
        {
            // Prioritize damaged parts for healing
            var damagedParts = _parts.Where(p => p.IsDamaged).ToList();
            if (damagedParts.Count > 0)
            {
                damagedParts[Utils.RandInt(0, damagedParts.Count - 1)].Heal(healingInfo);
                return;
            }

            // Random distribution if no parts are damaged
            if (Utils.FlipCoin())
            {
                BodyPart p = _parts[Utils.RandInt(0, _parts.Count - 1)];
                p.Heal(healingInfo);
                return;
            }
        }

        // Apply healing to this part
        double adjustedAmount = healingInfo.Amount * healingInfo.Quality;
        Health += adjustedAmount;
        if (Health > MaxHealth)
        {
            Health = MaxHealth;
        }
    }

    public void CalculateEffectiveCoverage()
    {
        if (Parent == null)
        {
            EffectiveCoverage = 1.0; // Root part has 100% chance
            return;
        }

        // My coverage of parent × parent's effective coverage
        EffectiveCoverage = (Coverage / 100.0) * Parent.EffectiveCoverage;

        // Calculate for all children
        foreach (var part in _parts)
        {
            part.CalculateEffectiveCoverage();
        }
    }

    public void Damage(DamageInfo damageInfo)
    {
        if (IsDestroyed) return;

        if (damageInfo.TargetPart == null)
        {
            // Standard untargeted damage
            DamageUntargeted(damageInfo);
            return;
        }

        // Handle targeted damage - but still allow for sub-part hits
        if (damageInfo.TargetPart == Name)
        {
            if (_parts.Count == 0)
            {
                ApplyDamage(damageInfo);
                return;
            }


            if (Utils.DetermineSuccess(damageInfo.Accuracy))
            {
                // Direct hit on the targeted part
                ApplyDamage(damageInfo);
                return;
            }

            // Even when targeting, there's a chance to hit sub-parts
            // Higher accuracy for targeted hits - use 75% of normal child coverage
            var partChances = new Dictionary<BodyPart, double>();
            double totalChildCoverage = 0;

            foreach (var part in _parts)
            {
                // Reduce child coverage to make it more likely to hit the targeted part
                double adjustedCoverage = part.Coverage * 0.75;
                partChances[part] = adjustedCoverage;
                totalChildCoverage += adjustedCoverage;
            }

            // Add self with remaining coverage - more likely than with random hits
            double selfCoverage = 100 - totalChildCoverage;
            partChances[this] = selfCoverage;

            BodyPart hit = Utils.GetRandomWeighted(partChances);
            if (hit == this)
            {
                ApplyDamage(damageInfo);
            }
            else
            {
                // When hitting a child on a targeted attack, we should
                // propagate that this was intentional targeting
                damageInfo.TargetPart = hit.Name; // Update target to child part
                damageInfo.Accuracy *= 0.8; // Reduce accuracy for child hit
                hit.Damage(damageInfo);
            }
            return;
        }
        else // Handle targeted damage for a different part (searching)
        {
            // Look for the targeted part among children
            var targetedPart = FindPartByName(damageInfo.TargetPart);

            if (targetedPart != null && Utils.DetermineSuccess(damageInfo.Accuracy)) // chance to miss based on accuracy
            {
                // Found the part - propagate damage to it
                targetedPart.Damage(damageInfo);
                return;
            }

            // Target not found as a descendant - try to hit this part instead
            // But with reduced damage since the intended target was missed
            damageInfo.Amount = damageInfo.Amount * 0.7; // Reduced damage for missing intended target
            damageInfo.TargetPart = null; // Clear targeting since we're defaulting

            // Process as untargeted hit
            DamageUntargeted(damageInfo);
        }
    }

    // Separate method for untargeted damage distribution
    private void DamageUntargeted(DamageInfo damageInfo)
    {
        // Distribute damage based on coverage
        if (_parts.Count > 0)
        {
            // Get all parts with their coverage values
            var partChances = new Dictionary<BodyPart, double>();
            double totalChildCoverage = 0;

            foreach (var part in _parts)
            {
                partChances[part] = part.Coverage;
                totalChildCoverage += part.Coverage;
            }

            // Add self with remaining coverage
            double selfCoverage = 100 - totalChildCoverage;
            partChances[this] = selfCoverage;

            BodyPart hit = Utils.GetRandomWeighted(partChances);
            if (hit == this)
            {
                ApplyDamage(damageInfo);
            }
            else
            {
                hit.Damage(damageInfo);
            }
            return;

        }

        // Default if no children or calculation issue
        ApplyDamage(damageInfo);
    }

    // Helper method to find a part by name in the hierarchy
    private BodyPart? FindPartByName(string partName)
    {
        if (Name == partName) return this;

        foreach (var part in _parts)
        {
            var foundPart = part.FindPartByName(partName);
            if (foundPart != null) return foundPart;
        }

        return null;
    }

    // Method to actually apply damage
    private void ApplyDamage(DamageInfo damageInfo)
    {
        // Apply damage reduction for internal parts if damage is not penetrating
        double damageAmount = damageInfo.Amount;
        if (IsInternal && !damageInfo.IsPenetrating)
        {
            damageAmount *= 0.5; // 50% damage reduction for internal parts
        }

        Health -= damageAmount;
        Output.WriteLine(this, " took ", damageAmount, " damage");
        // Handle destruction
        if (IsDestroyed)
        {
            Health = 0;
            if (IsVital && Parent != null)
            {
                var criticalDamage = new DamageInfo
                {
                    Amount = Parent.MaxHealth * 0.5,
                    Type = "critical",
                    Source = damageInfo.Source,
                    IsPenetrating = true // Critical damage always penetrates
                };
                Parent.Damage(criticalDamage);
            }
        }
    }
    public override string ToString() => Name;
}================================================================================

File: ./Bodies/Body.cs
--------------------------------------------------------------------------------

using text_survival.Effects;

namespace text_survival.Bodies;

public class BodyStats
{
    public BodyPartFactory.BodyTypes type;
    public double overallWeight;
    public double fatPercent;
    public double musclePercent;
}

public class Body
{
    // Root part and core properties
    private readonly BodyPart _rootPart;
    public double Health => _rootPart.Health;
    public double MaxHealth => _rootPart.MaxHealth;
    public bool IsDestroyed => _rootPart.IsDestroyed;

    private EffectRegistry _effectRegistry;

    // Physical composition
    private double _bodyFat;
    private double _muscle;
    private double _weight;
    private readonly double _baseWeight;

    // Physical systems
    private double _coreTemperature = 98.6; // Fahrenheit
    private double _targetMetabolismRate = 2000; // Calories per day

    public Body(BodyStats stats, EffectRegistry effectRegistry)
    {
        _effectRegistry = effectRegistry;
        _rootPart = BodyPartFactory.CreateBody(stats.type, stats.overallWeight);

        // Initialize physical composition
        _bodyFat = stats.overallWeight * (stats.fatPercent / 100);
        _muscle = stats.overallWeight * (stats.musclePercent / 100);
        _baseWeight = stats.overallWeight - _bodyFat - _muscle;
        UpdateWeight();
    }

    // Physical composition properties
    public double BodyFat
    {
        get => _bodyFat;
        set
        {
            _bodyFat = Math.Max(value, 0);
            UpdateWeight();
        }
    }

    public double Muscle
    {
        get => _muscle;
        set
        {
            _muscle = Math.Max(value, 0);
            UpdateWeight();
        }
    }

    public double BodyFatPercentage => _bodyFat / Weight;
    public double MusclePercentage => _muscle / Weight;
    public double Weight => _weight;

    // Core temperature and metabolism
    public double CoreTemperature => _coreTemperature;
    public double BasalMetabolicRate => CalculateMetabolicRate();

    // Update physical state
    private void UpdateWeight()
    {
        _weight = _baseWeight + _bodyFat + _muscle;
    }

    // Calculate metabolic rate based on composition
    private double CalculateMetabolicRate()
    {
        // Base BMR uses the Harris-Benedict equation (simplified)
        double bmr = 370 + (21.6 * _muscle) + (6.17 * _bodyFat);

        // Adjust for injuries and conditions
        double healthFactor = _rootPart.Health / _rootPart.MaxHealth;
        bmr *= 0.7 + (0.3 * healthFactor); // Injured bodies need more energy to heal

        return bmr;
    }

    // Forwarding methods to root part
    public void Damage(DamageInfo damageInfo) => _rootPart.Damage(damageInfo);
    public void Heal(HealingInfo healingInfo) => _rootPart.Heal(healingInfo);

    // Update body state over time
    public void Update(TimeSpan timePassed, EnvironmentInfo environment)
    {
        // Handle temperature regulation
        UpdateTemperature(environment.Temperature, environment.EquipmentWarmth, timePassed);

        // Handle metabolism and energy expenditure
        UpdateMetabolism(environment.ActivityLevel, timePassed);
    }

    // Temperature regulation
    private void UpdateTemperature(double environmentalTemp, double insulationFactor, TimeSpan timePassed)
    {
        // Calculate temperature differential
        double tempDifferential = environmentalTemp - _coreTemperature;

        // Body fat provides natural insulation
        double naturalInsulation = 0.1 + (BodyFatPercentage / 2);

        // Combined insulation factor
        double totalInsulation = naturalInsulation + insulationFactor;

        // Calculate temperature change rate (degrees per hour)
        double hourlyChange = tempDifferential * (1.0 - totalInsulation) / 5.0;

        // Apply for the time that has passed
        double hoursElapsed = timePassed.TotalHours;
        _coreTemperature += hourlyChange * hoursElapsed;

        // Trigger shivering or sweating based on temperature
        if (_coreTemperature < 97.0)
        {
            // Shivering increases metabolism to generate heat
            _targetMetabolismRate *= 1.2;
        }
        else if (_coreTemperature > 100.0)
        {
            // Sweating increases water loss
            // This would connect to the thirst system
        }
    }

    // Metabolism updates
    private void UpdateMetabolism(double activityLevel, TimeSpan timePassed)
    {
        // Calculate calorie burn based on BMR, activity, and time
        double hourlyBurn = BasalMetabolicRate / 24.0 * activityLevel;
        double calories = hourlyBurn * timePassed.TotalHours;

        // If calories aren't provided externally, burn fat
        double fatBurnRate = calories / 7700.0; // ~7700 calories per kg of fat
        BodyFat -= fatBurnRate;

        // If completely out of fat, burn muscle
        if (BodyFat <= 0 && _muscle > 0)
        {
            double muscleBurnRate = calories / 7700.0 * 0.8; // Muscle burns less efficiently
            Muscle -= muscleBurnRate;
        }
    }

    // Calculate derived attributes
    public double CalculateStrength()
    {
        double manipulationCapacity = GetCapacity("Manipulation");
        double bloodPumping = GetCapacity("BloodPumping"); // Energy delivery

        // Base strength that everyone has
        double baseStrength = 0.3; // 30% strength from structural aspects

        // Muscle contribution with diminishing returns
        double muscleContribution;
        if (MusclePercentage < 0.2) // Below normal
            muscleContribution = MusclePercentage * 2.5; // Rapid gains when building from low muscle
        else if (MusclePercentage < 0.4) // Normal to athletic
            muscleContribution = 0.5 + (MusclePercentage - 0.2) * 1.0; // Moderate gains
        else // Athletic+
            muscleContribution = 0.7 + (MusclePercentage - 0.4) * 0.5; // Diminishing returns

        // Energy state affects strength expression
        double energyFactor = Math.Min(bloodPumping, 1.0);

        // Very low body fat impairs strength
        double fatPenalty = (BodyFatPercentage < 0.05) ? (0.05 - BodyFatPercentage) * 3.0 : 0;

        return manipulationCapacity * (baseStrength + muscleContribution * energyFactor - fatPenalty);
    }

    public double CalculateSpeed()
    {
        double movingCapacity = GetCapacity("Moving");
        double muscleBonus = Math.Min(MusclePercentage * 0.5, 0.2); // Up to 20% bonus from muscle
        double fatPenalty;

        // Minimal fat has no penalty, excess has increasing penalties
        if (BodyFatPercentage < 0.1) // 10% is minimal necessary fat
            fatPenalty = 0;
        else
            fatPenalty = (BodyFatPercentage - 0.1) * 1.2; // Steeper penalty for excess fat

        // Weight ratio with diminishing penalty
        double weightRatio = Math.Pow(_baseWeight / Weight, 0.7); // Less severe exponent

        return movingCapacity * (1 + muscleBonus - fatPenalty) * weightRatio;
    }
    private double CalculateVitality()
    {
        double breathing = GetCapacity("Breathing");
        double bloodPumping = GetCapacity("BloodPumping");
        double digestion = GetCapacity("Digestion");

        // Base vitality that scales more gently with body composition
        double baseMultiplier = 0.7;  // Everyone gets 70% baseline
        double muscleContribution = MusclePercentage * 0.25;  // Up to 25% from muscle
        double fatContribution;

        // Essential fat is beneficial, excess isn't
        if (BodyFatPercentage < .10)
            fatContribution = BodyFatPercentage * 0.5;  // Fat is very important when low
        else if (BodyFatPercentage < .25)
            fatContribution = 0.05;  // Optimal fat gives 5%
        else
            fatContribution = 0.05 - (BodyFatPercentage - .25) * 0.1;  // Excess fat penalizes slightly

        return (breathing + bloodPumping + digestion) / 3 * (baseMultiplier + muscleContribution + fatContribution);
    }

    private double CalculatePerception()
    {
        double sight = GetCapacity("Sight");
        double hearing = GetCapacity("Hearing");

        return (sight + hearing) / 2;
    }

    private double CalculateColdResistance()
    {
        // Base cold resistance that everyone has
        double baseColdResistance = 0.5;
        double fatInsulation;

        if (BodyFatPercentage < 0.05)
            fatInsulation = (BodyFatPercentage / 0.05) * 0.1;  // Linear up to 5%
        else if (BodyFatPercentage < 0.15)
            fatInsulation = 0.1 + ((BodyFatPercentage - 0.05) / 0.1) * 0.15;  // From 0.1 to 0.25
        else
            fatInsulation = 0.25 + ((BodyFatPercentage - 0.15)) * 0.15;  // Diminishing returns after 15%

        return baseColdResistance + fatInsulation;
    }


    private double GetCapacity(string capacity)
    {
        var parts = GetAllParts().Where(p => p.GetCapacity(capacity) > 0);
        var values = parts.Select(p => GetEffectivePartCapacity(p, capacity)).ToList();
        if (values.Sum() <= 0) return 0;

        double result;
        if (capacity is "Moving" or "Manipulation" or "Breathing" or "Consciousness"
        or "BloodPumping" or "Digestion" or "Eating" or "Talking")
        {
            result = values.Min();
        }
        else if (capacity is "Sight" or "Hearing" or "BloodFiltration")
        {
            result = values.Average();
        }
        else
        {
            result = values.Min();
        }
        double bodyModifier = _effectRegistry.GetBodyCapacityModifier(capacity);
        result *= (1 + bodyModifier);
        result = Math.Max(0, result);
        return result;
    }

    private double GetEffectivePartCapacity(BodyPart part, string capacityName)
    {
        if (part.IsDestroyed) return 0;

        // Get base capacity (already includes health scaling)
        double baseCapacity = part.GetCapacity(capacityName);
        if (baseCapacity <= 0) return 0;

        // Apply effect modifiers for this part
        double modifier = _effectRegistry.GetPartCapacityModifier(capacityName, part);
        return Math.Max(0, baseCapacity * (1.0 + modifier));
    }


    // Helper to get all body parts
    public List<BodyPart> GetAllParts()
    {
        var result = new List<BodyPart>();
        CollectBodyParts(_rootPart, result);
        return result;
    }

    private void CollectBodyParts(BodyPart part, List<BodyPart> result)
    {
        result.Add(part);
        foreach (var child in part.Parts)
        {
            CollectBodyParts(child, result);
        }
    }

    // Environment info for updates
    public class EnvironmentInfo
    {
        public double Temperature { get; set; } = 70.0; // Fahrenheit
        public double EquipmentWarmth { get; set; } = 0.0;
        public double ActivityLevel { get; set; } = 1.0; // 1.0 = normal
    }
}================================================================================

File: ./Bodies/BodyInterfaces.cs
--------------------------------------------------------------------------------

namespace text_survival.Bodies;


// Comprehensive damage information
public class DamageInfo
{
    public DamageInfo() { }
    public DamageInfo(double amount,
                      string type = "physical",
                      string? source = null,
                      string? targetPart = null,
                      bool isPenetrating = false,
                      bool isBlunt = false,
                      bool isSharp = false,
                      double accuracy = .9)
    {
        Amount = amount;
        Type = type;
        Source = source;
        TargetPart = targetPart;
        IsPenetrating = isPenetrating;
        IsBlunt = isBlunt;
        IsSharp = isSharp;
        Accuracy = accuracy;
    }

    public double Amount { get; set; }
    public string Type { get; set; } = "physical"; // physical, thermal, poison, etc.
    public string? Source { get; set; }
    public string? TargetPart { get; set; } // Optional specific target
    public bool IsPenetrating { get; set; } = false;
    public bool IsSharp { get; set; } = false;
    public bool IsBlunt { get; set; } = false;
    public double Accuracy { get; set; } = .9;
}

// Comprehensive healing information
public class HealingInfo
{
    public double Amount { get; set; }
    public string Type { get; set; } = "natural"; // natural, medical, magical
    public string? TargetPart { get; set; }
    public double Quality { get; set; } = 1.0; // Effectiveness multiplier
    public string? Source { get; set; }
}

================================================================================

File: ./Bodies/BodyPartFactory.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Bodies;

public static class BodyPartFactory
{

    public enum BodyTypes
    {
        Human,
        Quadruped,
        Serpentine,
        Arachnid,
        Flying
    }

    public static BodyPart CreateBody(BodyTypes type, double baseHP)
    {
        return type switch
        {
            BodyTypes.Human => CreateHumanBody(baseHP),
            BodyTypes.Quadruped => CreateQuadrupedBody(baseHP),
            BodyTypes.Serpentine => CreateSerpentineBody(baseHP),
            BodyTypes.Arachnid => CreateArachnidBody(baseHP),
            BodyTypes.Flying => CreateFlyingBody(baseHP),
            _ => throw new NotImplementedException("Invalid body type")
        };
    }

    // Create a snake body
    public static BodyPart CreateSerpentineBody(double hp)
    {
        // Main body
        BodyPart body = new BodyPart("Body", hp, true, false, 100);

        // Head (smaller proportion for snakes - 15%)
        BodyPart head = CreateSnakeHead(hp * 0.15);
        body.AddPart(head);

        // Internal organs
        BodyPart heart = new BodyPart("Heart", hp * 0.05, true, true, 5);
        heart.SetBaseCapacity("BloodPumping", 1.0);
        body.AddPart(heart);

        BodyPart lungs = new BodyPart("Lung", hp * 0.05, true, true, 5);
        lungs.SetBaseCapacity("Breathing", 1.0);
        body.AddPart(lungs);

        // Spine running through the body
        BodyPart spine = new BodyPart("Spine", hp * 0.15, true, true, 15);
        spine.SetBaseCapacity("Moving", 1.0);
        body.AddPart(spine);

        // Segments - create multiple body segments
        int segmentCount = 5;
        for (int i = 1; i <= segmentCount; i++)
        {
            BodyPart segment = CreateSnakeSegment(hp * 0.12, $"Segment {i}");
            body.AddPart(segment);
        }

        // Tail
        BodyPart tail = new BodyPart("Tail", hp * 0.1, false, false, 10);
        tail.SetBaseCapacity("Moving", 0.3);
        body.AddPart(tail);

        // Calculate effective coverage
        body.CalculateEffectiveCoverage();

        return body;
    }

    // Helper method for snake head
    private static BodyPart CreateSnakeHead(double hp)
    {
        BodyPart head = new BodyPart("Head", hp, true, false, 15);

        // Eyes
        BodyPart leftEye = new BodyPart("Left Eye", hp * 0.1, false, false, 5);
        leftEye.SetBaseCapacity("Sight", 0.5);
        head.AddPart(leftEye);

        BodyPart rightEye = new BodyPart("Right Eye", hp * 0.1, false, false, 5);
        rightEye.SetBaseCapacity("Sight", 0.5);
        head.AddPart(rightEye);

        // Jaw with venom glands
        BodyPart jaw = new BodyPart("Jaw", hp * 0.3, false, false, 30);
        head.AddPart(jaw);

        BodyPart venomGland = new BodyPart("Venom Gland", hp * 0.15, false, true, 15);
        jaw.AddPart(venomGland);

        BodyPart tongue = new BodyPart("Tongue", hp * 0.05, false, false, 5);
        jaw.AddPart(tongue);

        return head;
    }

    // Helper method for snake body segments
    private static BodyPart CreateSnakeSegment(double hp, string name)
    {
        BodyPart segment = new BodyPart(name, hp, false, false, 12);
        segment.SetBaseCapacity("Moving", 0.2);
        return segment;
    }

    // Create an arachnid body (spider)
    public static BodyPart CreateArachnidBody(double hp)
    {
        // Create the main body (cephalothorax + abdomen)
        BodyPart body = new BodyPart("Body", hp, true, false, 100);

        // Cephalothorax - head and thorax combined
        BodyPart cephalothorax = new BodyPart("Cephalothorax", hp * 0.4, true, false, 40);
        body.AddPart(cephalothorax);

        // Eyes - spiders have multiple eyes
        for (int i = 1; i <= 8; i++)
        {
            BodyPart eye = new BodyPart($"Eye {i}", hp * 0.01, false, false, 1);
            eye.SetBaseCapacity("Sight", 0.125); // Total sight = 8 eyes * 0.125 = 1.0
            cephalothorax.AddPart(eye);
        }

        // Fangs
        BodyPart fangs = new BodyPart("Fangs", hp * 0.05, false, false, 5);
        cephalothorax.AddPart(fangs);

        BodyPart venomGland = new BodyPart("Venom Gland", hp * 0.05, false, true, 5);
        fangs.AddPart(venomGland);

        // Heart
        BodyPart heart = new BodyPart("Heart", hp * 0.05, true, true, 5);
        heart.SetBaseCapacity("BloodPumping", 1.0);
        cephalothorax.AddPart(heart);

        // Abdomen
        BodyPart abdomen = new BodyPart("Abdomen", hp * 0.3, true, false, 30);
        body.AddPart(abdomen);

        // Silk glands in abdomen
        BodyPart silkGland = new BodyPart("Silk Gland", hp * 0.05, false, true, 5);
        abdomen.AddPart(silkGland);

        // Spinnerets
        BodyPart spinnerets = new BodyPart("Spinnerets", hp * 0.05, false, false, 5);
        abdomen.AddPart(spinnerets);

        // Eight legs
        for (int i = 1; i <= 8; i++)
        {
            string legPosition;
            if (i <= 4)
                legPosition = $"Front {(i <= 2 ? "Left" : "Right")} Leg {(i % 2 == 0 ? 2 : 1)}";
            else
                legPosition = $"Rear {(i <= 6 ? "Left" : "Right")} Leg {(i % 2 == 0 ? 2 : 1)}";

            BodyPart leg = CreateArachnidLeg(hp * 0.025, legPosition);
            body.AddPart(leg);
        }

        // Calculate effective coverage
        body.CalculateEffectiveCoverage();

        return body;
    }

    // Helper method for spider leg
    private static BodyPart CreateArachnidLeg(double hp, string name)
    {
        BodyPart leg = new BodyPart(name, hp, false, false, 2.5);
        leg.SetBaseCapacity("Moving", 0.125); // Each leg contributes 1/8 of total movement

        // Leg segments
        BodyPart femur = new BodyPart("Femur", hp * 0.3, false, false, 30);
        leg.AddPart(femur);

        BodyPart patella = new BodyPart("Patella", hp * 0.2, false, false, 20);
        leg.AddPart(patella);

        BodyPart tibia = new BodyPart("Tibia", hp * 0.3, false, false, 30);
        leg.AddPart(tibia);

        BodyPart tarsus = new BodyPart("Tarsus", hp * 0.2, false, false, 20);
        leg.AddPart(tarsus);

        return leg;
    }

    // Create a flying body (for bats)
    public static BodyPart CreateFlyingBody(double hp)
    {
        // Torso
        BodyPart torso = new BodyPart("Torso", hp, true, false, 100);

        // Head
        BodyPart head = CreateHead(hp * 0.15);
        torso.AddPart(head);

        // Internal organs
        BodyPart heart = CreateHeart(hp * 0.05);
        torso.AddPart(heart);

        BodyPart leftLung = CreateLungs(hp * 0.05, "Left Lung");
        torso.AddPart(leftLung);

        BodyPart rightLung = CreateLungs(hp * 0.05, "Right Lung");
        torso.AddPart(rightLung);

        // Wings (modified arms/forelimbs)
        BodyPart leftWing = CreateWing(hp * 0.2, "Left Wing");
        torso.AddPart(leftWing);

        BodyPart rightWing = CreateWing(hp * 0.2, "Right Wing");
        torso.AddPart(rightWing);

        // Legs
        BodyPart leftLeg = CreateLeg(hp * 0.1, "Left Leg");
        torso.AddPart(leftLeg);

        BodyPart rightLeg = CreateLeg(hp * 0.1, "Right Leg");
        torso.AddPart(rightLeg);

        // Calculate effective coverage
        torso.CalculateEffectiveCoverage();

        return torso;
    }

    // Helper method for wings
    private static BodyPart CreateWing(double hp, string name)
    {
        BodyPart wing = new BodyPart(name, hp, false, false, 20);
        wing.SetBaseCapacity("Moving", 0.5); // Wings provide flight capability

        // Wing structure includes modified arm bones and wing membrane
        BodyPart humerus = new BodyPart("Humerus", hp * 0.2, false, false, 20);
        wing.AddPart(humerus);

        BodyPart radius = new BodyPart("Radius", hp * 0.15, false, false, 15);
        wing.AddPart(radius);

        BodyPart digits = new BodyPart("Digits", hp * 0.15, false, false, 15);
        wing.AddPart(digits);

        BodyPart membrane = new BodyPart("Membrane", hp * 0.5, false, false, 50);
        wing.AddPart(membrane);

        return wing;
    }
    public static BodyPart CreateHumanBody(double hp)
    {
        // Torso (main part)
        BodyPart torso = new BodyPart("Torso", hp, true, false, 100);

        // Neck (7.5% of torso)
        BodyPart neck = CreateNeck(hp * 0.075);
        torso.AddPart(neck);

        // Spine (2.5% of torso)
        BodyPart spine = CreateSpine(hp * .025);
        torso.AddPart(spine);

        // Ribcage (3.6% of torso)
        BodyPart ribcage = CreateRibcage(hp * 0.036);
        torso.AddPart(ribcage);

        // Sternum (1.5% of torso)
        BodyPart sternum = CreateSternum(hp * 0.015);
        torso.AddPart(sternum);

        // Internal organs
        // Stomach (2.5% of torso)
        BodyPart stomach = CreateStomach(hp * 0.025);
        torso.AddPart(stomach);

        // Heart (2.0% of torso)
        BodyPart heart = CreateHeart(hp * 0.02);
        torso.AddPart(heart);

        // Lungs (2.5% each, total 5.0% of torso)
        BodyPart leftLung = CreateLungs(hp * 0.025, "Left Lung");
        torso.AddPart(leftLung);

        BodyPart rightLung = CreateLungs(hp * 0.025, "Right Lung");
        torso.AddPart(rightLung);

        // Kidneys (1.7% each, total 3.4% of torso)
        BodyPart leftKidney = CreateKidney(hp * 0.017, "Left Kidney");
        torso.AddPart(leftKidney);

        BodyPart rightKidney = CreateKidney(hp * 0.017, "Right Kidney");
        torso.AddPart(rightKidney);

        // Liver (2.5% of torso)
        BodyPart liver = CreateLiver(hp * 0.025);
        torso.AddPart(liver);

        // Pelvis (2.5% of torso)
        BodyPart pelvis = CreatePelvis(hp * 0.025);
        torso.AddPart(pelvis);

        // Shoulders (12% of torso, 6% each)
        BodyPart leftShoulder = CreateShoulder(hp * 0.06, "Left Shoulder");
        torso.AddPart(leftShoulder);

        BodyPart rightShoulder = CreateShoulder(hp * 0.06, "Right Shoulder");
        torso.AddPart(rightShoulder);

        // Legs (14% of torso, 7% each)
        BodyPart leftLeg = CreateLeg(hp * 0.07, "Left Leg");
        torso.AddPart(leftLeg);

        BodyPart rightLeg = CreateLeg(hp * 0.07, "Right Leg");
        torso.AddPart(rightLeg);

        // Calculate effective coverage
        torso.CalculateEffectiveCoverage();

        return torso;
    }

    public static BodyPart CreateQuadrupedBody(double hp)
    {

        // Torso
        BodyPart torso = new BodyPart("Torso", hp, true, false, 100);

        // Head (10% of torso)
        BodyPart head = CreateHead(hp * 0.625);
        torso.AddPart(head);

        // Internal organs with appropriate coverage
        BodyPart heart = CreateHeart(hp * 0.375);
        torso.AddPart(heart);

        BodyPart leftLung = CreateLungs(hp * 0.375, "Left Lung");
        torso.AddPart(leftLung);

        BodyPart rightLung = CreateLungs(hp * 0.375, "Right Lung");
        torso.AddPart(rightLung);

        // Legs (higher coverage for quadrupeds)
        BodyPart frontLeftLeg = CreateLeg(hp * 0.75, "Front Left Leg");
        torso.AddPart(frontLeftLeg);

        BodyPart frontRightLeg = CreateLeg(hp * 0.75, "Front Right Leg");
        torso.AddPart(frontRightLeg);

        BodyPart rearLeftLeg = CreateLeg(hp * 0.75, "Rear Left Leg");
        torso.AddPart(rearLeftLeg);

        BodyPart rearRightLeg = CreateLeg(hp * 0.75, "Rear Right Leg");
        torso.AddPart(rearRightLeg);

        // Calculate effective coverage
        torso.CalculateEffectiveCoverage();

        return torso;
    }

    public static BodyPart CreateGenericBody(string name, double hp)
    {
        return new BodyPart(name, hp, true, false, 100);
    }

    public static BodyPart CreateNeck(double hp)
    {
        BodyPart neck = new BodyPart("Neck", hp, true, false, 7.5);
        neck.SetBaseCapacity("Eating", 0.5);
        neck.SetBaseCapacity("Talking", 0.5);
        neck.SetBaseCapacity("Breathing", 0.5);

        // Head (80% of neck)
        BodyPart head = CreateHead(hp);
        neck.AddPart(head);

        return neck;
    }

    public static BodyPart CreateHead(double hp)
    {
        BodyPart head = new BodyPart("Head", hp, true, false, 80.0);

        // Skull (18% of head)
        BodyPart skull = new BodyPart("Skull", hp * 0.625, false, true, 18.0);
        head.AddPart(skull);

        // Brain (80% of skull)
        BodyPart brain = CreateBrain(hp * 0.25);
        skull.AddPart(brain);

        // Eyes (7% each, total 14% of head)
        BodyPart rightEye = CreateEye(hp * 0.25, "Right Eye");
        head.AddPart(rightEye);

        BodyPart leftEye = CreateEye(hp * 0.25, "Left Eye");
        head.AddPart(leftEye);

        // Ears (7% each, total 14% of head)
        BodyPart leftEar = CreateEar(hp * 0.3, "Left Ear");
        head.AddPart(leftEar);

        BodyPart rightEar = CreateEar(hp * 0.3, "Right Ear");
        head.AddPart(rightEar);

        // Nose (10% of head)
        BodyPart nose = new BodyPart("Nose", hp * 0.25, false, false, 10.0);
        head.AddPart(nose);

        // Jaw (15% of head)
        BodyPart jaw = CreateJaw(hp * 0.5);
        head.AddPart(jaw);

        return head;
    }

    public static BodyPart CreateShoulder(double hp, string name = "Shoulder")
    {
        BodyPart shoulder = new BodyPart(name, hp, false, false, 6.0);
        shoulder.SetBaseCapacity("Manipulation", 0.5);

        // Clavicle (9% of shoulder)
        BodyPart clavicle = CreateClavicle(hp * 0.625);
        shoulder.AddPart(clavicle);

        // Arm (77% of shoulder)
        BodyPart arm = CreateArm(hp * 0.75, name.Replace("Shoulder", "Arm"));
        shoulder.AddPart(arm);

        return shoulder;
    }

    public static BodyPart CreateArm(double hp, string name = "Arm")
    {
        BodyPart arm = new BodyPart(name, hp, false, false, 77.0);
        arm.SetBaseCapacity("Manipulation", 0.5);

        // Humerus (10% of arm)
        BodyPart humerus = CreateHumerus(hp * 0.625);
        arm.AddPart(humerus);

        // Radius (10% of arm)
        BodyPart radius = CreateRadius(hp * 0.5);
        arm.AddPart(radius);

        // Hand (14% of arm)
        BodyPart hand = CreateHand(hp * 0.5, name.Replace("Arm", "Hand"));
        arm.AddPart(hand);

        return arm;
    }

    public static BodyPart CreateHand(double hp, string name = "Hand")
    {
        BodyPart hand = new BodyPart(name, hp, false, false, 14.0);
        hand.SetBaseCapacity("Manipulation", 0.5);

        // Fingers (each with appropriate coverage of hand)
        BodyPart thumb = CreateFinger(hp * 0.2, name.Replace("Hand", "Thumb"));
        hand.AddPart(thumb);

        BodyPart indexFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Index Finger"));
        hand.AddPart(indexFinger);

        BodyPart middleFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Middle Finger"));
        hand.AddPart(middleFinger);

        BodyPart ringFinger = CreateFinger(hp * 0.2, name.Replace("Hand", "Ring Finger"));
        hand.AddPart(ringFinger);

        BodyPart pinky = CreateFinger(hp * 0.2, name.Replace("Hand", "Pinky"));
        hand.AddPart(pinky);

        return hand;
    }

    public static BodyPart CreateFinger(double hp, string name = "Finger")
    {
        BodyPart finger = new BodyPart(name, hp, false, false, 7.0); // Average coverage
        finger.SetBaseCapacity("Manipulation", 0.08);
        return finger;
    }

    public static BodyPart CreateLeg(double hp, string name = "Leg")
    {
        BodyPart leg = new BodyPart(name, hp, false, false, 7.0);
        leg.SetBaseCapacity("Moving", 0.5);

        // Femur (10% of leg)
        BodyPart femur = CreateFemur(hp * 0.625);
        leg.AddPart(femur);

        // Tibia (10% of leg)
        BodyPart tibia = CreateTibia(hp * 0.625);
        leg.AddPart(tibia);

        // Foot (10% of leg)
        BodyPart foot = CreateFoot(hp * 0.625, name.Replace("Leg", "Foot"));
        leg.AddPart(foot);

        return leg;
    }

    public static BodyPart CreateFoot(double hp, string name = "Foot")
    {
        BodyPart foot = new BodyPart(name, hp, false, false, 10.0);
        foot.SetBaseCapacity("Moving", 0.5);

        // Toes (each with appropriate coverage of foot)
        BodyPart bigToe = CreateToe(hp * 0.2, name.Replace("Foot", "Big Toe"));
        foot.AddPart(bigToe);

        BodyPart secondToe = CreateToe(hp * 0.2, name.Replace("Foot", "Second Toe"));
        foot.AddPart(secondToe);

        BodyPart middleToe = CreateToe(hp * 0.2, name.Replace("Foot", "Middle Toe"));
        foot.AddPart(middleToe);

        BodyPart fourthToe = CreateToe(hp * 0.2, name.Replace("Foot", "Fourth Toe"));
        foot.AddPart(fourthToe);

        BodyPart littleToe = CreateToe(hp * 0.2, name.Replace("Foot", "Little Toe"));
        foot.AddPart(littleToe);

        return foot;
    }

    public static BodyPart CreateToe(double hp, string name = "Toe")
    {
        BodyPart toe = new BodyPart(name, hp, false, false, 7.0); // Average coverage
        toe.SetBaseCapacity("Moving", 0.04);
        return toe;
    }

    public static BodyPart CreateBrain(double hp)
    {
        BodyPart brain = new BodyPart("Brain", hp, true, true, 80.0);
        brain.SetBaseCapacity("Consciousness", 1.0);
        return brain;
    }

    public static BodyPart CreateEye(double hp, string name = "Eye")
    {
        BodyPart eye = new BodyPart(name, hp, false, false, 7.0);
        eye.SetBaseCapacity("Sight", 0.5);
        return eye;
    }

    public static BodyPart CreateMouth(double hp)
    {
        BodyPart mouth = new BodyPart("Mouth", hp, false, false, 15.0);
        mouth.SetBaseCapacity("Eating", 0.5);
        mouth.SetBaseCapacity("Talking", 0.5);
        return mouth;
    }

    public static BodyPart CreateJaw(double hp)
    {
        BodyPart jaw = new BodyPart("Jaw", hp, false, false, 15.0);
        jaw.SetBaseCapacity("Eating", 0.5);
        jaw.SetBaseCapacity("Talking", 0.5);

        // Tongue (0.1% of jaw as per RimWorld)
        BodyPart tongue = CreateTongue(hp * 0.25);
        jaw.AddPart(tongue);

        return jaw;
    }

    public static BodyPart CreateTongue(double hp)
    {
        BodyPart tongue = new BodyPart("Tongue", hp, false, true, 0.1);
        tongue.SetBaseCapacity("Talking", 0.5);
        return tongue;
    }

    public static BodyPart CreateLungs(double hp, string name = "Lungs")
    {
        BodyPart lungs = new BodyPart(name, hp, true, true, 2.5);
        lungs.SetBaseCapacity("Breathing", 0.5);
        return lungs;
    }

    public static BodyPart CreateEar(double hp, string name = "Ear")
    {
        BodyPart ear = new BodyPart(name, hp, false, false, 7.0);
        ear.SetBaseCapacity("Hearing", 0.5);
        return ear;
    }

    public static BodyPart CreateHeart(double hp)
    {
        BodyPart heart = new BodyPart("Heart", hp, true, true, 2.0);
        heart.SetBaseCapacity("BloodPumping", 1.0);
        return heart;
    }

    public static BodyPart CreateStomach(double hp)
    {
        BodyPart stomach = new BodyPart("Stomach", hp, true, true, 2.5);
        stomach.SetBaseCapacity("Digestion", 0.5);
        return stomach;
    }

    public static BodyPart CreateLiver(double hp)
    {
        BodyPart liver = new BodyPart("Liver", hp, true, true, 2.5);
        liver.SetBaseCapacity("Digestion", 0.5);
        return liver;
    }

    public static BodyPart CreateKidney(double hp, string name = "Kidney")
    {
        BodyPart kidney = new BodyPart(name, hp, true, true, 1.7);
        kidney.SetBaseCapacity("BloodFiltration", 0.5);
        return kidney;
    }

    public static BodyPart CreateSpine(double hp)
    {
        BodyPart spine = new BodyPart("Spine", hp, false, true, 2.5);
        spine.SetBaseCapacity("Moving", 1.0);
        return spine;
    }

    public static BodyPart CreateRibcage(double hp)
    {
        BodyPart ribcage = new BodyPart("Ribcage", hp, false, true, 3.6);
        ribcage.SetBaseCapacity("Breathing", 0.5);
        return ribcage;
    }

    public static BodyPart CreateSternum(double hp)
    {
        BodyPart sternum = new BodyPart("Sternum", hp, false, true, 1.5);
        sternum.SetBaseCapacity("Breathing", 0.5);
        return sternum;
    }

    public static BodyPart CreatePelvis(double hp)
    {
        BodyPart pelvis = new BodyPart("Pelvis", hp, false, true, 2.5);
        pelvis.SetBaseCapacity("Moving", 1.0);
        return pelvis;
    }

    public static BodyPart CreateClavicle(double hp)
    {
        BodyPart clavicle = new BodyPart("Clavicle", hp, false, true, 9.0);
        clavicle.SetBaseCapacity("Manipulation", 0.5);
        return clavicle;
    }

    public static BodyPart CreateHumerus(double hp)
    {
        BodyPart humerus = new BodyPart("Humerus", hp, false, true, 10.0);
        humerus.SetBaseCapacity("Manipulation", 0.5);
        return humerus;
    }

    public static BodyPart CreateRadius(double hp)
    {
        BodyPart radius = new BodyPart("Radius", hp, false, true, 10.0);
        radius.SetBaseCapacity("Manipulation", 0.5);
        return radius;
    }

    public static BodyPart CreateFemur(double hp)
    {
        BodyPart femur = new BodyPart("Femur", hp, false, true, 10.0);
        femur.SetBaseCapacity("Moving", 0.5);
        return femur;
    }

    public static BodyPart CreateTibia(double hp)
    {
        BodyPart tibia = new BodyPart("Tibia", hp, false, true, 10.0);
        tibia.SetBaseCapacity("Moving", 0.5);
        return tibia;
    }
}
================================================================================

File: ./IO/Input.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.IO
{
    public static class Input
    {
        private static ManualResetEvent manualResetEvent = new ManualResetEvent(false);
        // private static string userInput;
        // public static void OnUserInputReceived(string input)
        // {
        //     userInput = input;
        //     manualResetEvent.Set();
        // }
        public static string Read()
        {
            string? input = "";
            if (Config.io == Config.IOType.Console)
            {
                input = Console.ReadLine();
            }
            else if (Config.io == Config.IOType.Web)
            {
                // await user input from web
                //input = AwaitInput();
                throw new NotImplementedException();
            }

            return input ?? "";
        }

        // public static string AwaitInput()
        // {
        //     manualResetEvent.WaitOne();
        //     manualResetEvent.Reset();
        //     return userInput;
        // }

        public static int ReadInt()
        {
            while (true)
            {
                string? input = Read();
                if (int.TryParse(input, out int result))
                {
                    return result;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number.\n");
                }
            }
        }

        public static int ReadInt(int low, int high)
        {
            while (true)
            {
                int input = ReadInt();
                if (input >= low && input <= high)
                {
                    return input;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number between ", low, " and ", high, ".\n");
                }
            }
        }

        public static bool ReadYesNo()
        {
            while (true)
            {
                string? input = Read().Trim().ToLower();
                if (input == "y" || input == "yes")
                {
                    return true;
                }
                else if (input == "n" || input == "no")
                {
                    return false;
                }
                else
                {
                    Output.Write("Invalid input. Please enter 'y' or 'n'.\n");
                }
            }
        }

        public static T? GetSelectionFromList<T>(List<T> list, bool cancelOption = false, string cancelMessage = "Cancel")
        {
            list.ForEach(i =>
            {
                if (i != null) Output.WriteLine(list.IndexOf(i) + 1, ". ", i);
            });

            int input;
            if (cancelOption)
            {
                Output.WriteLine(0, ". ", cancelMessage);
                input = ReadInt(0, list.Count);
                if (input == 0)
                {
                    return default;
                }
            }
            else
            {
                input = ReadInt(1, list.Count);
            }

            return list[input - 1];
        }
    }
}
================================================================================

File: ./IO/Output.cs
--------------------------------------------------------------------------------
﻿using System.Text;
using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival.IO
{
    public static class Output
    {
        public static int SleepTime = 10;
        public static Queue<string> OutputQueue = new Queue<string>();

        public static ConsoleColor DetermineTextColor(object x)
        {
            return x switch
            {
                string => ConsoleColor.Gray,
                int or float or double => ConsoleColor.Green,
                Npc => ConsoleColor.Red,
                Item => ConsoleColor.Cyan,
                Container => ConsoleColor.Yellow,
                Player => ConsoleColor.Green,
                Zone => ConsoleColor.Blue,
                Location => ConsoleColor.DarkYellow,
                Enum => ConsoleColor.White,
                null => ConsoleColor.Red,
                _ => ConsoleColor.White,
            };
        }

        public static void Write(params object[] args)
        {

            if (Config.io == Config.IOType.Console)
            {
                foreach (var arg in args)
                {
                    string text = GetFormattedText(arg);
                    Console.ForegroundColor = DetermineTextColor(arg);
                    Console.Write(text);
                    Thread.Sleep(SleepTime);
                }
            }
            else if (Config.io == Config.IOType.Web)
            {
                throw new NotImplementedException();
                //EventHandler.Publish(new WriteEvent(text));
            }
            
        }

        private static string GetFormattedText(params object[] args)
        {
            string result = string.Empty;

            foreach (var arg in args)
            {
                switch (arg)
                {
                    case float f:
                        result += $"{f:F1}";
                        break;
                    case double d:
                        result += $"{d:F1}";
                        break;
                    case null:
                        result += "[NULL]";
                        break;
                    default:
                        result += arg.ToString();
                        break;
                }
            }
            return result;

        }

        public static void WriteLine(params object[] args)
        {
            Write(args);
            Write("\n");
        }


        public static void WriteWarning(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Yellow;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        public static void WriteDanger(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Red;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }
    }
}
================================================================================

File: ./Program.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival
{
    public class Program
    {
        static void Main()
        {
            Output.SleepTime = 500;
            Output.WriteLine("You wake up in the forest, with no memory of how you got there.");
            Output.WriteLine("Light snow is falling, and you feel the air getting colder.");
            Output.WriteLine("You need to find shelter, food, and water to survive.");
            Output.SleepTime = 10;

            Zone startingArea = new Zone("Clearing", "A small clearing in the forest.", new LocationTable());
            Container oldBag = new Container("Old bag", 10);
            Location log = new Location("Hollow log", startingArea);
            oldBag.Add(ItemFactory.MakeKnife());
            oldBag.Add(ItemFactory.MakeMoccasins());
            oldBag.Add(ItemFactory.MakeLeatherTunic());
            oldBag.Add(ItemFactory.MakeLeatherLeggings());
            log.Containers.Add(oldBag);
            startingArea.Locations.Add(log);
            Player player = new Player(log);
            World.Player = player;
            Actions actions = new(player);
            while (player.IsAlive)
            {
                actions.Act();
            }
        }
    }
}================================================================================

File: ./Survival/ThirstModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class ThirstModule
    {
        public bool IsParched => Amount >= Max;
        private double Rate = 4000F / (24F * 60F); // mL per minute
        private double Max = 3000.0F; // mL
        private double Amount { get; set; }
        public ThirstModule()
        {
            Amount = 0;
        }
        public void AddHydration(double mL){
            Amount -= mL;
            if (Amount < 0){
                Amount = 0;
            }
        }
        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
                Amount = Max;
        }
        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Thirst: ", percent, "%");
        }
    }
}================================================================================

File: ./Survival/TemperatureModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class TemperatureModule
    {
        public const double BaseBodyTemperature = 98.6F;
        public double BodyTemperature { get; private set; }
        public bool IsWarming { get; private set; }
        public TemperatureEnum TemperatureEffect { get; private set; }

        public bool IsDangerousTemperature { get; private set; }

        public TemperatureModule()
        {

            BodyTemperature = BaseBodyTemperature;
            TemperatureEffect = TemperatureEnum.Warm;
            IsDangerousTemperature = false;
        }
        public enum TemperatureEnum
        {
            Warm,
            Cool,
            Cold,
            Freezing,
            Hot,
            HeatExhaustion,
        }

        public void Update(double feelsLikeTemperature)
        {
            TemperatureEnum oldTemperature = TemperatureEffect;
            UpdateTemperatureTick(feelsLikeTemperature);
            if (oldTemperature != TemperatureEffect)
            {
                WriteTemperatureEffectMessage(TemperatureEffect);
            }
        }
        private void UpdateTemperatureEffect()
        {
            if (BodyTemperature >= 97.7 && BodyTemperature <= 99.5)
            {
                // Normal body temperature, no effects
                TemperatureEffect = TemperatureEnum.Warm;
            }
            else if (BodyTemperature >= 95.0 && BodyTemperature < 97.7)
            {
                // Mild hypothermia effects
                TemperatureEffect = TemperatureEnum.Cool;
            }
            else if (BodyTemperature >= 89.6 && BodyTemperature < 95.0)
            {
                // Moderate hypothermia effects
                TemperatureEffect = TemperatureEnum.Cold;
            }
            else if (BodyTemperature < 89.6)
            {
                // Severe hypothermia effects
                TemperatureEffect = TemperatureEnum.Freezing;
            }
            else if (BodyTemperature > 99.5 && BodyTemperature <= 104.0)
            {
                // Heat exhaustion effects
                TemperatureEffect = TemperatureEnum.Hot;
            }
            else if (BodyTemperature > 104.0)
            {
                // Heat stroke effects
                TemperatureEffect = TemperatureEnum.HeatExhaustion;
            }
        }

        public static void WriteTemperatureEffectMessage(TemperatureEnum tempEnum)
        {
            switch (tempEnum)
            {
                case TemperatureEnum.Warm:
                    Output.WriteLine("You feel normal.");
                    break;
                case TemperatureEnum.Cool:
                    Output.WriteWarning("You feel cool.");
                    break;
                case TemperatureEnum.Cold:
                    Output.WriteWarning("You feel cold.");
                    break;
                case TemperatureEnum.Freezing:
                    Output.WriteDanger("You are freezing cold.");
                    break;
                case TemperatureEnum.Hot:
                    Output.WriteWarning("You feel hot.");
                    break;
                case TemperatureEnum.HeatExhaustion:
                    Output.WriteDanger("You are burning up.");
                    break;
                default:
                    Output.WriteDanger("Error: Temperature effect not found.");
                    break;
            }
        }
        private void UpdateTemperatureTick(double feelsLikeTemperature)
        {
            BodyTemperature += .1;

            double skinTemp = BodyTemperature - 8.4;
            float rate = 1F / 120F;

            double tempChange = (feelsLikeTemperature - skinTemp) * rate;
            BodyTemperature += tempChange;

            IsWarming = tempChange > 0;

            UpdateTemperatureEffect();

            if (BodyTemperature < 89.6)
            {
                IsDangerousTemperature = true;
            }
            else if (BodyTemperature >= 104.0)
            {
                IsDangerousTemperature = true;
            }
            else
            {
                IsDangerousTemperature = false;
            }
        }

        public void Describe()
        {
            string tempChange = IsWarming ? "Warming up" : "Getting colder";
            Output.WriteLine("Body Temperature: ", BodyTemperature, "°F (", TemperatureEffect, ")");
        }
    }
}
================================================================================

File: ./Survival/HungerModule.cs
--------------------------------------------------------------------------------
﻿
using text_survival.IO;

namespace text_survival.Survival
{
    public class HungerModule
    {
        public bool IsStarving => Amount >= Max;
        private double Rate = 2500.0 / (24.0 * 60.0); // calories per minute
        private double Max = 3500; // calories
        private double Amount { get; set; }


        public HungerModule()
        {
            Amount = 0;
        }

        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
                Amount = Max;
        }

        public void AddCalories(double calories)
        {
            Amount -= calories;
            if (Amount < 0)
            {
                Amount = 0;
            }
        }

        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Hunger: ", percent, "%");
        }
    }
}


================================================================================

File: ./Survival/ExhaustionModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class ExhaustionModule
    {
        public bool IsExhausted => Amount >= Max;
        public bool IsFullyRested => Amount <= 0;
        public double ExhaustionPercent => (Amount / Max) * 100;
        private float Rate = 480F / (24F * 60F); // minutes per minute (8 hours per 24)
        private float Max = 480.0F; // minutes (8 hours)
        public float Amount { get; private set; }

        public ExhaustionModule()
        {
            Amount = 0;
        }

        public void Rest(int minutes)
        {
            Amount -= minutes * Rate;
            if (Amount < 0)
            {
                Amount = 0;
            }
        }

        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
            {
                Amount = Max;
            }
        }

        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("Exhaustion: ", percent, "%");
        }
    }
}================================================================================

File: ./World.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;

namespace text_survival
{
    public static class World
    {
        public static TimeOnly Time { get; set; } = new TimeOnly(hour: 9, minute: 0);

        public static Player Player { get; set; }
        public static Zone CurrentArea => Player.CurrentZone;

        public static void Update(int minutes)
        {
            for (int i = 0; i < minutes; i++)
            {
                Player.Update();
                CurrentArea.Update();
                Time = Time.AddMinutes(1);
            }
        }

        public enum TimeOfDay
        {
            Night,
            Dawn,
            Morning,
            Afternoon,
            Noon,
            Evening,
            Dusk
        }

        public static TimeOfDay GetTimeOfDay()
        {
            return Time.Hour switch
            {
                < 5 => TimeOfDay.Night,
                < 6 => TimeOfDay.Dawn,
                < 11 => TimeOfDay.Morning,
                < 13 => TimeOfDay.Noon,
                < 17 => TimeOfDay.Afternoon,
                < 20 => TimeOfDay.Evening,
                < 21 => TimeOfDay.Dusk,
                _ => TimeOfDay.Night
            };
        }

    }
}
================================================================================

File: ./Utils/Utils.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Utils
    {
        private static readonly Random random = new Random(DateTime.Now.Millisecond);

        static Utils()
        {
            random = new Random(DateTime.Now.Millisecond);
        }

        public static int Roll(int sides)
        {
            return random.Next(1, sides + 1);
        }

        public static bool DetermineSuccess(double chance)
        {
            return (random.NextDouble() < chance);
        }

        public static int RandInt(int low, int high)
        {
            return random.Next(low, high + 1);
        }

        public static float RandFloat(float low, float high)
        {
            return (float)random.NextDouble() * (high - low) + low;
        }

        public static double RandDouble(double low, double high)
        {
            return random.NextDouble() * (high - low) + low;
        }

        public static bool FlipCoin()
        {
            return random.Next(2) == 0;
        }

        public static T? GetRandomEnum<T>() where T : Enum
        {
            Array values = Enum.GetValues(typeof(T));
            return (T?)values.GetValue(Roll(values.Length) - 1);
        }

        public static T GetRandomFromList<T>(List<T> list)
        {
            if (list.Count == 0)
            {
                throw new Exception("List is empty.");
            }
            return list[Roll(list.Count) - 1];
        }
        
    public static T GetRandomWeighted<T>(IDictionary<T, double> choices)
    {
        if (choices == null || choices.Count == 0)
            throw new ArgumentException("Cannot select from an empty collection", nameof(choices));
            
        double totalWeight = choices.Sum(pair => pair.Value);
        if (totalWeight <= 0)
            throw new ArgumentException("Total weight must be positive", nameof(choices));
            
        double roll = random.NextDouble() * totalWeight;
        
        double cumulativeWeight = 0;
        foreach (var pair in choices)
        {
            cumulativeWeight += pair.Value;
            if (roll <= cumulativeWeight)
                return pair.Key;
        }
        
        // This should never happen if weights are positive
        return choices.Keys.Last();
    }
    }
}
================================================================================

File: ./Utils/WeightedTable.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival;

public class GenericWeightedTable<T> where T : class
{
    protected Dictionary<Func<T>, double> weightedFactories = [];

    public GenericWeightedTable() { }
    public void AddFactory(Func<T> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual T GenerateRandom()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)();
    }
}

public class LootTable : GenericWeightedTable<Item>
{
    public void AddItem(Func<Item> itemFactory, double weight = 1)
    {
        AddFactory(itemFactory, weight);
    }

    public Item GenerateRandomItem()
    {
        return base.GenerateRandom();
    }
}

public class LocationTable
{
    protected Dictionary<Func<Zone, Location>, double> weightedFactories = [];

    public void AddFactory(Func<Zone, Location> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual Location GenerateRandom(Zone parent)
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)(parent);
    }
}


public class NpcTable : GenericWeightedTable<Npc>
{
    public void AddActor(Func<Npc> actorFactory, double weight = 1)
    {
        AddFactory(actorFactory, weight);
    }
}================================================================================

File: ./Magic/SpellFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;

namespace text_survival.Magic
{
    public static class SpellFactory
    {
        public static Spell MinorHeal => new Spell("Minor Heal", new HealEffect("healing spell", null, 10), true);
        public static Spell Bleeding => new Spell("Bleeding", new BleedEffect(null, "bleed spell", 1, 10, 60), true);
        public static Spell Poison => new Spell("Poison", new PoisonEffect("magic", "poison spell", 1, 5, 180), false);
    }
}
================================================================================

File: ./Magic/Spell.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;

namespace text_survival.Magic;

public class Spell
{
    public string Name { get; private set; }
    public bool NeedsTargetPart { get; private set; }
    private Effect Effect { get; }


    public Spell(string name, Effect effect, bool needsTargetPart)
    {
        Name = name;
        Effect = effect;
        NeedsTargetPart = needsTargetPart;
    }

    public void Cast(Actor target)
    {
        target.ApplyEffect(Effect);
    }
    public void Cast(Actor target, BodyPart part)
    {
        Effect.TargetBodyPart = part;
        target.ApplyEffect(Effect);
    }



}
================================================================================

File: ./Combat.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.IO;

namespace text_survival
{
    public static class Combat
    {
        public static void CombatLoop(Player player, Actor enemy)
        {
            Output.WriteLine("You encounter: ", enemy, "!");
            player.IsEngaged = true;
            enemy.IsEngaged = true;
            if (enemy.Body.CalculateSpeed() > player.Body.CalculateSpeed())
            {
                enemy.Attack(player);
            }
            while (player.IsAlive && enemy.IsAlive)
            {
                if (!player.IsEngaged || !player.IsAlive) break;
                PlayerTurn(player, enemy);

                if (!enemy.IsEngaged || !enemy.IsAlive) break;
                enemy.Attack(player);

                World.Update(1);
            }
            player.IsEngaged = false;
            enemy.IsEngaged = false;

            if (!player.IsAlive)
                Output.WriteDanger("You died!");
            else if (!enemy.IsAlive)
            {
                Output.WriteLine("You killed ", enemy, "!");
            }
        }



        public static void PlayerTurn(Player player, Actor enemy)
        {
            Output.WriteLine("What do you want to do?");

            List<string> options = ["Attack", "Cast Spell", "Flee"];

            string? choice = Input.GetSelectionFromList(options);

            switch (choice)
            {
                case "Attack":
                    player.Attack(enemy);
                    break;
                case "Cast Spell":
                    player.SelectSpell();
                    break;
                case "Flee":
                    if (SpeedCheck(player, enemy))
                    {
                        Output.WriteLine("You got away!");
                        enemy.IsEngaged = false;
                        player.IsEngaged = false;
                    }
                    else
                    {
                        Output.WriteLine("You weren't fast enough to get away from ", enemy, "!");
                        player._skillRegistry.AddExperience("Athletics", 1); // XP for flee attempt
                    }
                    break;
                default:
                    throw new InvalidOperationException("Invalid Selection");
            }
        }

        public static bool SpeedCheck(Player player, Actor? enemy = null)
        {
            if (player.CurrentLocation.Npcs.Count == 0) return true;

            enemy ??= GetFastestNpc(player.CurrentLocation);

            double playerCheck = CalcSpeedCheck(player);
            double enemyCheck = CalcSpeedCheck(enemy);

            return playerCheck >= enemyCheck;
        }

        public static Npc GetFastestNpc(Location location)
        {
            double enemyCheck = 0;
            Npc fastestNpc = location.Npcs.First();
            foreach (Npc npc in location.Npcs)
            {
                if (npc == fastestNpc) continue;
                if (!npc.IsAlive) continue;
                var currentNpcCheck = CalcSpeedCheck(npc);
                if (currentNpcCheck < enemyCheck) continue;
                fastestNpc = npc;
                enemyCheck = currentNpcCheck;
            }
            return fastestNpc;
        }

        public static double CalcSpeedCheck(Actor actor)
        {
            double athleticsBonus = actor._skillRegistry.GetLevel("Agility");
            return actor.Body.CalculateSpeed() + athleticsBonus;
        }
    }
}================================================================================

File: ./Config.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival
{
    public static class Config
    {
        public enum IOType
        {
            Console,
            Web
        }
        public static IOType io = IOType.Console;
    }
}
================================================================================

File: ./Environments/Location.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.Environments;

public class Location
{
    public string Name;
    public bool Visited = false;
    public bool IsFound { get; set; } = false;
    public List<Npc> Npcs = [];
    public List<Item> Items = [];
    public List<Container> Containers = [];
    virtual public Zone Parent { get; }
    public List<LocationFeature> Features = [];

    #region Initialization

    public Location(string name, Zone parent)
    {
        Name = name;
        Parent = parent;
        NpcSpawner = new();
        // InitializeNpcs(numNpcs);
    }

    // public static readonly List<string> genericLocationAdjectives = ["", "Old", "Dusty", "Cool", "Breezy", "Quiet", "Ancient", "Ominous", "Sullen", "Forlorn", "Desolate", "Secret", "Hidden", "Forgotten", "Cold", "Dark", "Damp", "Wet", "Dry", "Warm", "Icy", "Snowy", "Frozen"];

    public T? GetFeature<T>() where T : LocationFeature => Features.OfType<T>().FirstOrDefault();

    public void SpawnNpcs(int numNpcs)
    {
        for (int i = 0; i < numNpcs; i++)
        {
            var npc = NpcSpawner.GenerateRandomNpc();
            if (npc is not null)
                Npcs.Add(npc);
        }
    }
    protected virtual NpcSpawner NpcSpawner { get; }


    #endregion Initialization
    public void Interact(Player player)
    {
        Output.WriteLine("You consider heading to the " + Name + "...");
        Output.WriteLine("Do you want to go there? (y/n)");
        if (Input.ReadYesNo())
        {
            player.CurrentLocation = this;
        }
        else
        {
            Output.WriteLine("You decide to stay.");
        }
    }
    public Command<Player> InteractCommand => new("Go to " + Name + (Visited ? " (Visited)" : ""), Interact);
    public double GetTemperature()
    {
        // Get zone's weather temperature (in Fahrenheit)
        double zoneTemp = Parent.Weather.TemperatureInFahrenheit;

        // Start with this base temperature
        double locationTemp = zoneTemp;

        // ------ STEP 1: Apply inherent location modifiers ------
        double overheadCoverage = 0;
        double windProtection = 0;
        var locationType = GetFeature<EnvironmentFeature>();
        if (locationType != null)
        {
            locationTemp += locationType.TemperatureModifier;
            overheadCoverage = locationType.NaturalOverheadCoverage;
            windProtection = locationType.NaturalWindProtection;
        }

        // ------ STEP 2: Apply weather exposure effects ------
        // Wind chill when windy
        double effectiveWindSpeed = 0;
        if (Parent.Weather.WindSpeed > 0.1) // Only significant wind
        {
            effectiveWindSpeed = Parent.Weather.WindSpeed * (1 - windProtection);
            double windSpeedMph = effectiveWindSpeed * 30; // Scale 0-1 to approx mph
            locationTemp = CalculateWindChillNWS(locationTemp, windSpeedMph);
        }

        // Sun warming effects during daytime with clear skies
        double sunIntensity = Parent.Weather.SunlightIntensity;
        double sunExposure = 1 - overheadCoverage;
        // Sun can add up to 10°F on a cold day
        double sunWarming = sunIntensity * sunExposure * 10;

        // Sun effect is more noticeable when cold
        double temperatureAdjustment = sunWarming * Math.Max(0.5, Math.Min(1, (50 - locationTemp) / 30));
        locationTemp += temperatureAdjustment;

        // Precipitation effects
        double precipitation = Parent.Weather.Precipitation;
        precipitation *= 1 - overheadCoverage;
        // todo, determine if this effects temp directly or if we use this elsewhere 
        double precipitationCooling = precipitation * 5; //  simple up to 5°F cooling for now
        locationTemp -= precipitationCooling * (1 - overheadCoverage);

        // ------ STEP 3: Apply shelter effects if present ------
        double insulation = 0;
        var shelter = GetFeature<ShelterFeature>();
        if (shelter != null)
        {
            // Start with minimum temperature a shelter can maintain (in °F)
            double minShelterTemp = 40; // About 4.4°C, what a good shelter can maintain from body heat
            // Calculate warming effect based on insulation quality
            double tempDifference = minShelterTemp - locationTemp;
            insulation = Math.Clamp(shelter.TemperatureInsulation, 0, .9); // cap at 90%
            insulation *= 1 - (precipitation * .3); // precipitation can reduce insulation up to 30%
            insulation *= 1 - (effectiveWindSpeed * .3); // and wind another 30 on top of that

            locationTemp += tempDifference * insulation;
        }

        // If there's a heat source, add its effect
        var heatSource = GetFeature<HeatSourceFeature>();
        if (heatSource != null && heatSource.IsActive)
        {
            // Insulation increases effectiveness of heat sources
            double heatEffect = heatSource.HeatOutput * Math.Max(insulation, .40); // heat sources are less effective outside
            locationTemp += heatEffect;
        }

        return locationTemp;
    }

    public double CalculateWindChillNWS(double temperatureF, double windSpeedMph)
    {
        // NWS formula is only valid for temperatures <= 50°F and wind speeds >= 3 mph
        if (temperatureF > 50 || windSpeedMph < 3)
        {
            return temperatureF;
        }
        // Calculate using the NWS Wind Chill Temperature (WCT) formula
        // https://www.weather.gov/media/epz/wxcalc/windChill.pdf
        // WCT = 35.74 + 0.6215T - 35.75(V^0.16) + 0.4275T(V^0.16)
        // Where T = Air Temperature (°F), V = Wind Speed (mph)
        double windPowFactor = Math.Pow(windSpeedMph, 0.16);
        return 35.74 + (0.6215 * temperatureF) - (35.75 * windPowFactor) + (0.4275 * temperatureF * windPowFactor);
    }

    public void Update()
    {
        // Locations.ForEach(i => i.Update());
        Npcs.ForEach(n => n.Update());
    }

    public override string ToString() => Name;
}================================================================================

File: ./Environments/LocationFeatures.cs/EnvironmentFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class EnvironmentFeature : LocationFeature
{
    public enum LocationType
    {
        OpenPlain,      // No natural shelter
        Forest,         // Trees provide some wind/rain protection
        Cave,           // Natural temperature moderation
        Cliff,          // Wind protection from one direction
        RiverBank,      // Water nearby, but exposure
        HighGround      // More wind but better visibility
    }
    private LocationType Type;
    public double TemperatureModifier { get; } = 0; // degrees F adjustment
    public double NaturalOverheadCoverage { get; } = 0;
    public double NaturalWindProtection { get; } = 0;

    public EnvironmentFeature(Location location, double tempModifier, double overheadCoverage, double windProtection) : base("shelter", location)
    {
        TemperatureModifier = tempModifier;
        NaturalOverheadCoverage = overheadCoverage;
        NaturalWindProtection = windProtection;
    }
    public EnvironmentFeature(Location location, LocationType type)
        : base("locationType", location)
    {
        Type = type;

        switch (type)
        {
            case LocationType.Forest:
                NaturalWindProtection = 0.4;     // 40% wind reduction
                NaturalOverheadCoverage = 0.3;   // 30% precipitation protection
                TemperatureModifier = 3.0;       // 3°F warmer in winter, cooler in summer
                break;

            case LocationType.Cave:
                NaturalWindProtection = 0.9;     // 90% wind protection
                NaturalOverheadCoverage = 0.95;  // 95% precipitation protection
                TemperatureModifier = 15.0;      // 15°F warmer in winter, cooler in summer
                break;

            case LocationType.Cliff:
                NaturalWindProtection = 0.6;     // 60% wind protection
                NaturalOverheadCoverage = 0.2;   // 20% precipitation protection
                TemperatureModifier = 2.0;       // 2°F temperature moderation
                break;

            case LocationType.RiverBank:
                NaturalWindProtection = 0.1;     // 10% wind protection
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -2.0;      // 2°F cooler from water proximity
                break;

            case LocationType.HighGround:
                NaturalWindProtection = -0.2;    // 20% increased wind
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -4.0;      // 4°F cooler from elevation
                break;

            case LocationType.OpenPlain:
            default:
                NaturalWindProtection = 0.0;
                NaturalOverheadCoverage = 0.0;
                TemperatureModifier = 0.0;
                break;
        }
    }

    // Get description of the location type
    public string GetDescription()
    {
        return Type switch
        {
            LocationType.Forest => "A forest with trees providing some shelter from the elements.",
            LocationType.Cave => "A cave offering protection from wind and precipitation.",
            LocationType.Cliff => "A cliff face providing some protection from the wind.",
            LocationType.RiverBank => "The bank of a river, exposed but with access to water.",
            LocationType.HighGround => "Higher elevation with increased exposure to wind.",
            LocationType.OpenPlain => "An open area with no natural protection.",
            _ => "An undefined location type."
        };
    }

}================================================================================

File: ./Environments/LocationFeatures.cs/ForageFeature.cs
--------------------------------------------------------------------------------
﻿using text_survival.Items;

namespace text_survival.Environments;

public class ForageFeature(Location location, double resourceDensity = 1) : LocationFeature("forage", location)
{
    private double baseResourceDensity = resourceDensity;
    private int numberOfHoursForaged = 0;
    private Dictionary<Func<Item>, double> resourceRarities = [];
    private double ResourceDensity => baseResourceDensity / (numberOfHoursForaged + 1);

    public void Forage(int hours)
    {
        // todo: change the order of operations here
        List<Item> itemsFound = [];
        foreach (Func<Item> factory in resourceRarities.Keys)
        {
            double chance = ResourceDensity * resourceRarities[factory];

            for (int i = 0; i < hours; i++)
            {
                if (Utils.DetermineSuccess(chance))
                {
                    var item = factory();
                    item.IsFound = true;
                    ParentLocation.Items.Add(item);
                    numberOfHoursForaged++;
                }
            }
        }
        World.Update(hours * 60);
    }

    public void AddResource(Func<Item> factory, double rarity)
    {
        resourceRarities.Add(factory, rarity);
    }
}
================================================================================

File: ./Environments/LocationFeatures.cs/LocationFeature.cs
--------------------------------------------------------------------------------

using text_survival.Survival;

namespace text_survival.Environments;

public abstract class LocationFeature
{
    public string Name { get; private set; }
    protected Location ParentLocation { get; private set; }
    public LocationFeature(string name, Location location)
    {
        Name = name;
        ParentLocation = location;
    }
    // public virtual void Initialize() { }
    // public virtual void Update() { }
}



================================================================================

File: ./Environments/LocationFeatures.cs/ShelterFeature.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ShelterFeature : LocationFeature
{
    // todo add enums and presets like environment features
    public double TemperatureInsulation { get; } = 0; // ambient temp protection 0-1
    public double OverheadCoverage { get; } = 0; // rain / snow / sun protection 0-1
    public double WindCoverage { get; } = 0; // wind protection 0-1
    // public double Durability {get; private}
    public ShelterFeature(Location location, double tempInsulation, double overheadCoverage, double windCoverage) : base("shelter", location)
    {
        TemperatureInsulation = tempInsulation;
        OverheadCoverage = overheadCoverage;
        WindCoverage = windCoverage;
    }
    
}================================================================================

File: ./Environments/LocationFeatures.cs/HeatSourceFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class HeatSourceFeature : LocationFeature
{
    public bool IsActive { get; private set; }
    public double HeatOutput { get; private set; } // In Fahrenheit
    public double FuelRemaining { get; private set; } // 0-1 scale
    public double FuelConsumptionRate { get; private set; } // Per hour
    
    public HeatSourceFeature(Location location, double heatOutput = 15.0) 
        : base("heatSource", location)
    {
        IsActive = false;
        HeatOutput = heatOutput; // Default 15°F increase
        FuelRemaining = 0;
        FuelConsumptionRate = 0.1; // 10% per hour
    }
    
    public void AddFuel(double amount)
    {
        FuelRemaining = Math.Min(1.0, FuelRemaining + amount);
        
        // Activate if adding fuel to inactive source
        if (!IsActive && FuelRemaining > 0)
            IsActive = true;
    }
    
    // Update for fuel consumption
    public void Update(TimeSpan elapsed)
    {
        if (!IsActive || FuelRemaining <= 0)
            return;
            
        // Calculate fuel consumption
        double hoursElapsed = elapsed.TotalHours;
        double fuelUsed = FuelConsumptionRate * hoursElapsed;
        
        FuelRemaining = Math.Max(0, FuelRemaining - fuelUsed);
        
        // Deactivate if out of fuel
        if (FuelRemaining <= 0)
            IsActive = false;
    }
    
    // Manually activate/deactivate
    public void SetActive(bool active)
    {
        // Can only activate if there's fuel
        if (active && FuelRemaining > 0)
            IsActive = true;
        else if (!active)
            IsActive = false;
    }
}================================================================================

File: ./Environments/Zone.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class Zone
    {
        public string Name { get; }
        public string Description { get; }
        public bool Visited = false;
        private double BaseTemperature { get; }
        public int Elevation { get; }
        public virtual List<Location> Locations { get; } = [];
        private LocationTable LocationTable;
        public ZoneWeather Weather;


        public Zone(string name, string description, LocationTable locationTable, double baseTemp = 20, int elevation = 0)
        {
            Name = name;
            Description = description;
            BaseTemperature = baseTemp;
            Elevation = elevation;
            LocationTable = locationTable;
            Weather = new(this);
            if (!LocationTable.IsEmpty())
            {
                for (int i = 0; i < 3; i++)
                {
                    Locations.Add(LocationTable.GenerateRandom(this));
                }
            }

        }

        // private double GetTemperatureModifier()
        // {
        //     double modifier = 0;
        //     if (World.GetTimeOfDay() == World.TimeOfDay.Morning)
        //     {
        //         modifier = -.10;
        //     }
        //     else if (World.GetTimeOfDay() == World.TimeOfDay.Afternoon)
        //     {
        //         modifier = .20;
        //     }
        //     else if (World.GetTimeOfDay() == World.TimeOfDay.Evening)
        //     {
        //         modifier = .15;
        //     }
        //     else if (World.GetTimeOfDay() == World.TimeOfDay.Night)
        //     {
        //         modifier = -.30;
        //     }
        //     modifier += Utils.RandDouble(-.1, .1);
        //     return modifier;
        // }
        // public double GetTemperature()
        // {
        //     double effect = GetTemperatureModifier();
        //     return effect * BaseTemperature;
        // }

        public void Update()
        {
            Locations.ForEach(x => x.Update());
        }

        // protected static readonly List<string> genericAdjectives = ["", "Open", "Dark", "Ominous", "Shady", "Lonely", "Ancient",];
        public override string ToString() => Name;

    }
}
================================================================================

File: ./Environments/WorldMap.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class WorldMap
    {
        private Dictionary<(int, int), Zone> map = new();

        private int X;
        private int Y;

        public WorldMap(Zone startingZone)
        {
            X = 0;
            Y = 0;
            map.Add((X, Y), startingZone);
            startingZone.Visited = true;
        }

        public Zone CurrentZone => GetZone(X, Y);
        public Zone North => GetZone(X, Y + 1);
        public Zone South => GetZone(X, Y - 1);
        public Zone East => GetZone(X + 1, Y);
        public Zone West => GetZone(X - 1, Y);


        public void MoveNorth() => MoveTo(X, Y + 1);
        public void MoveSouth() => MoveTo(X, Y - 1);
        public void MoveEast() => MoveTo(X + 1, Y);
        public void MoveWest() => MoveTo(X - 1, Y);


        private void MoveTo(int x, int y)
        {
            Zone zone = GetZone(x, y) ?? throw new Exception("Invalid zone.");
            X = x;
            Y = y;
            zone.Visited = true;
        }

        private Zone GetZone(int x, int y)
        {
            Zone? zone = map.GetValueOrDefault((x, y));
            if (zone == null)
            {
                zone = GenerateRandomZone();
                map.Add((x, y), zone);
            }
            return zone;
        }

        private Zone GenerateRandomZone()
        {
            // todo
            return Utils.GetRandomFromList([ZoneFactory.MakeForestZone(), ZoneFactory.MakeCaveSystemZone()]);
        }

    }
}
================================================================================

File: ./Environments/ZoneFactory.cs
--------------------------------------------------------------------------------
namespace text_survival.Environments;

public static class ZoneFactory
{
    public static Zone MakeForestZone(string name = "", string description = "", double baseTemp = 20)
    {
        // Create a location table specifically for forest locations
        LocationTable forestLocationTable = new LocationTable();
        
        // Add various forest location types with appropriate weights
        forestLocationTable.AddFactory(LocationFactory.MakeForest, 3.0); // Most common
        
        // You can add more forest-related locations here when implemented
        // forestLocationTable.AddLocation(() => LocationFactory.MakeClearing(null), 2.0);
        // forestLocationTable.AddLocation(() => LocationFactory.MakeGrove(null), 1.5);
        // forestLocationTable.AddLocation(() => LocationFactory.MakeThicket(null), 1.0);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            string[] forestZoneNames = { "Forest", "Woods", "Woodland", "Timberland", "Wildwood" };
            string[] forestZoneAdjectives = { "", "Deep", "Ancient", "Verdant", "Mysterious", "Shadowy", "Enchanted", "Wild", "Dark", "Dense", "Northern", "Southern", "Eastern", "Western" };
            
            // Pick a random adjective and name
            string adjective = forestZoneAdjectives[Utils.RandInt(0, forestZoneAdjectives.Length - 1)];
            string zoneName = forestZoneNames[Utils.RandInt(0, forestZoneNames.Length - 1)];
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            string[] forestDescriptions = 
            {
                "A vast expanse of trees stretching as far as the eye can see.",
                "Tall trees with a dense canopy above, filtering sunlight to the forest floor.",
                "A quiet forest with the occasional sounds of wildlife echoing through the trees.",
                "Trees of various species create a diverse ecosystem rich with life.",
                "A sprawling woodland with paths winding between ancient trees and undergrowth."
            };
            
            description = forestDescriptions[Utils.RandInt(0, forestDescriptions.Length - 1)];
        }
        
        // Create and return the forest zone
        return new Zone(name, description, forestLocationTable, baseTemp);
    }
    
    public static Zone MakeCaveSystemZone(string name = "", string description = "", double baseTemp = 10)
    {
        // Create a location table specifically for cave system locations
        LocationTable caveLocationTable = new LocationTable();
        
        // Add various cave location types with appropriate weights
        caveLocationTable.AddFactory(LocationFactory.MakeCave, 3.0); // Most common
        
        // You can add more cave-related locations here when implemented
        // caveLocationTable.AddLocation(() => LocationFactory.MakeCavern(null), 2.0);
        // caveLocationTable.AddLocation(() => LocationFactory.MakeRavine(null), 1.5);
        // caveLocationTable.AddLocation(() => LocationFactory.MakeCrystalCave(null), 1.0);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            string[] caveZoneNames = { "Cave System", "Caverns", "Underground Complex", "Grotto Network", "Subterranean Labyrinth" };
            string[] caveZoneAdjectives = { "", "Deep", "Ancient", "Crystal", "Mysterious", "Dark", "Echoing", "Forgotten", "Hidden", "Vast", "Winding" };
            
            // Pick a random adjective and name
            string adjective = caveZoneAdjectives[Utils.RandInt(0, caveZoneAdjectives.Length - 1)];
            string zoneName = caveZoneNames[Utils.RandInt(0, caveZoneNames.Length - 1)];
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            string[] caveDescriptions = 
            {
                "A maze of dark tunnels and chambers stretching deep into the earth.",
                "A network of interconnected caves with stalactites hanging from the ceiling.",
                "Cool, damp caverns with the sound of water dripping echoing in the darkness.",
                "An intricate system of underground passages formed over thousands of years.",
                "A sprawling subterranean network with chambers of varying sizes and depths."
            };
            
            description = caveDescriptions[Utils.RandInt(0, caveDescriptions.Length - 1)];
        }
        
        // Create and return the cave system zone with cooler base temperature
        return new Zone(name, description, caveLocationTable, baseTemp);
    }
    
    // // Method to create a complete world with multiple zones
    // public static List<Zone> CreateWorld()
    // {
    //     List<Zone> world = new List<Zone>();
        
    //     // Create various zones
    //     Zone forestZone = MakeForestZone();
    //     world.Add(forestZone);
        
    //     Zone caveZone = MakeCaveSystemZone();
    //     world.Add(caveZone);
        
    //     // Fix parent references for all zones
    //     foreach (var zone in world)
    //     {
    //         FixParentReferences(zone);
    //     }
        
    //     return world;
    // }
}================================================================================

File: ./Environments/Weather.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ZoneWeather
{

    // todo: improve sunrise and sunset logic,
    // todo: add more continuity and state to more granular changes
    public double BaseTemperature { get; private set; } // In Celsius
    public WeatherCondition CurrentCondition { get; private set; }
    public double Precipitation { get; private set; } // 0-1 intensity
    public double WindSpeed { get; private set; }    // 0-1 intensity
    public double CloudCover { get; private set; }   // 0-1 coverage

    // Season tracking
    public enum Season { Winter, Spring, Summer, Fall }
    public Season CurrentSeason { get; private set; } = Season.Fall; // Start in fall

    // Weather conditions for Ice Age Europe
    public enum WeatherCondition
    {
        Clear,      // Clear, cold skies
        Cloudy,     // Overcast conditions
        Misty,      // Low visibility with moisture
        LightSnow,  // Light snowfall (common in Ice Age)
        Rainy,      // Cold rain (uncommon but possible)
        Blizzard,   // Heavy snow with wind (dangerous)
        Stormy      // Thunderstorms (rare, mostly summer)
    }

    // Add to ZoneWeather class
    public double SunlightIntensity
    {
        get
        {
            // No sun at night
            if (!IsDaytime())
                return 0;

            // Base sun intensity from time of day
            double timeOfDayFactor = GetSunIntensityByTime();

            // Reduction factors from weather conditions
            double cloudReduction = CloudCover * 0.9; // Clouds block up to 90% of sunlight

            // Additional reduction based on weather condition
            double conditionReduction = CurrentCondition switch
            {
                WeatherCondition.Misty => 0.6,
                WeatherCondition.Blizzard => 0.9,
                WeatherCondition.LightSnow => 0.3,
                WeatherCondition.Rainy => 0.5,
                WeatherCondition.Stormy => 0.8,
                _ => 0.0
            };
            // Calculate final intensity (0-1)
            double baseIntensity = timeOfDayFactor * (1 - cloudReduction);
            return baseIntensity * (1 - conditionReduction);
        }
    }

    private bool IsDaytime()
    {
        // todo: flesh this out and combine it with the temperature cycle 
        int hour = World.Time.Hour;

        // Seasonal variation in daylight hours
        int sunriseHour, sunsetHour;

        switch (CurrentSeason)
        {
            case Season.Winter:
                sunriseHour = 8;  // Late sunrise
                sunsetHour = 16;  // Early sunset
                break;
            case Season.Spring:
            case Season.Fall:
                sunriseHour = 6;  // Normal sunrise
                sunsetHour = 18;  // Normal sunset
                break;
            case Season.Summer:
                sunriseHour = 4;  // Early sunrise
                sunsetHour = 20;  // Late sunset
                break;
            default:
                sunriseHour = 6;
                sunsetHour = 18;
                break;
        }

        return hour >= sunriseHour && hour < sunsetHour;
    }

    private double GetSunIntensityByTime()
    {
        // Get sun intensity purely based on time of day (0-1)
        int hour = World.Time.Hour;
        int minute = World.Time.Minute;

        // No sunlight before sunrise or after sunset
        if (!IsDaytime())
            return 0;

        // Convert to minutes since sunrise (0-720)
        double minutesSinceSunrise = ((hour - 6) * 60) + minute;
        double dayLengthMinutes = 12 * 60; // 12 hours of daylight

        // Calculate angle for sine function (0 to π over the day)
        double angle = (minutesSinceSunrise / dayLengthMinutes) * Math.PI;

        // Sine wave peaks at noon (6 hours after sunrise)
        return Math.Sin(angle);
    }

    // Time and update tracking
    private TimeSpan _weatherDuration;
    private TimeSpan _timeSinceChange = TimeSpan.Zero;

    // Zone this weather belongs to
    private Zone _zone;

    public ZoneWeather(Zone zone)
    {
        _zone = zone;

        // Initialize with fall weather
        BaseTemperature = 0; // 0°C is about 32°F - freezing point
        CurrentCondition = WeatherCondition.Clear;
        Precipitation = 0;
        WindSpeed = 0.3; // Moderate wind - 30% of maximum
        CloudCover = 0.3; // Light clouds - 30% coverage

        _weatherDuration = TimeSpan.FromHours(6);
    }

    public void Update(TimeSpan elapsed)
    {
        _timeSinceChange += elapsed;

        // Time to change weather?
        if (_timeSinceChange >= _weatherDuration)
        {
            GenerateNewWeather();
            _timeSinceChange = TimeSpan.Zero;
        }
    }

    private void GenerateNewWeather()
    {
        // Generate new weather conditions based on season and zone
        // Determine base temperature range for season
        double minTemp, maxTemp;
        double precipChance;
        double snowRatio; // Chance of precipitation being snow vs rain

        switch (CurrentSeason)
        {
            case Season.Winter:
                minTemp = -30; // -30°C (-22°F) extreme winter low
                maxTemp = -5;  // -5°C (23°F) winter "warm" day
                precipChance = 0.2; // 20% chance of precipitation
                snowRatio = 0.95;   // 95% of precip is snow in winter
                break;

            case Season.Spring:
                minTemp = -15; // -15°C (5°F) cold spring night
                maxTemp = 5;   // 5°C (41°F) mild spring day
                precipChance = 0.25; // 25% chance of precipitation
                snowRatio = 0.6;    // 60% of precip is snow in spring
                break;

            case Season.Summer:
                minTemp = -5;  // -5°C (23°F) cold summer night
                maxTemp = 15;  // 15°C (59°F) warm summer day
                precipChance = 0.15; // 15% chance of precipitation
                snowRatio = 0.2;    // 20% of precip is snow in summer
                break;

            case Season.Fall:
                minTemp = -10; // -10°C (14°F) cold fall night
                maxTemp = 5;   // 5°C (41°F) mild fall day
                precipChance = 0.2;  // 20% chance of precipitation
                snowRatio = 0.7;    // 70% of precip is snow in fall
                break;

            default:
                minTemp = -15;
                maxTemp = 0;
                precipChance = 0.2;
                snowRatio = 0.8;
                break;
        }

        // Apply zone-specific modifications
        if (_zone.Elevation > 0)
        {
            // Higher elevation = colder (-0.6°C per 100m elevation)
            double elevationEffect = _zone.Elevation * -0.006; // -0.6% per 100m
            minTemp += elevationEffect;
            maxTemp += elevationEffect;
        }

        // Get time of day temperature modifier (0-1 scale)
        double timeOfDayFactor = GetTimeOfDayFactor();

        // Calculate random temperature within range, biased toward colder
        // For example: With Spring (-15°C to 5°C) at noon (factor=1.0):
        // Temperature range = -15 + (5-(-15)) * random(0,0.8) * 1.0 = -15 to +1°C
        double temperatureRange = maxTemp - minTemp;
        double randomFlux = Utils.RandDouble(0, 1);

        BaseTemperature = minTemp + (temperatureRange * randomFlux * timeOfDayFactor);

        // Determine weather condition
        if (Utils.RandDouble(0, 1) < precipChance) // Precipitation check (0.15-0.25 chance)
        {
            // Determine type of precipitation
            double snowVsRainRoll = Utils.RandDouble(0, 1);

            if (snowVsRainRoll < snowRatio) // Snow event
            {
                // Determine if blizzard (rare) or light snow (common)
                if (Utils.RandDouble(0, 1) < 0.15) // 15% of snow events are blizzards
                {
                    CurrentCondition = WeatherCondition.Blizzard;
                    Precipitation = Utils.RandDouble(0.7, 1.0); // 70-100% intensity
                    WindSpeed = Utils.RandDouble(0.7, 1.0);     // 70-100% of max wind
                    CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                }
                else
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.6); // 20-60% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.5);     // 20-50% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
                }
            }
            else // Rain event (uncommon in Ice Age)
            {
                // Only happens when temperature is above freezing
                if (BaseTemperature > 0)
                {
                    // Determine if stormy (very rare) or rainy
                    if (CurrentSeason == Season.Summer && Utils.RandDouble(0, 1) < 0.1) // 10% of summer rain is storms
                    {
                        CurrentCondition = WeatherCondition.Stormy;
                        Precipitation = Utils.RandDouble(0.6, 0.9); // 60-90% intensity
                        WindSpeed = Utils.RandDouble(0.5, 0.8);     // 50-80% of max wind
                        CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(2); // 1-3 hours
                    }
                    else
                    {
                        CurrentCondition = WeatherCondition.Rainy;
                        Precipitation = Utils.RandDouble(0.3, 0.6); // 30-60% intensity
                        WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                        CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                    }
                }
                else // Temperature too cold for rain, adjust to snow
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.5); // 20-50% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(5); // 1-9 hours
                }
            }
        }
        else // No precipitation
        {
            // Choose between clear, cloudy or misty
            double clearVsCloudyRoll = Utils.RandDouble(0, 1);

            if (clearVsCloudyRoll < 0.4) // 40% chance for clear
            {
                CurrentCondition = WeatherCondition.Clear;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.1, 0.5);     // 10-50% of max wind
                CloudCover = Utils.RandDouble(0, 0.2);      // 0-20% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(9); // 1-17 hours
            }
            else if (clearVsCloudyRoll < 0.8) // 40% chance for cloudy
            {
                CurrentCondition = WeatherCondition.Cloudy;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.2, 0.6);     // 20-60% of max wind
                CloudCover = Utils.RandDouble(0.5, 0.8);    // 50-80% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
            }
            else // 20% chance for misty
            {
                CurrentCondition = WeatherCondition.Misty;
                Precipitation = Utils.RandDouble(0, 0.1);   // 0-10% light moisture
                WindSpeed = Utils.RandDouble(0, 0.2);       // 0-20% of max wind
                CloudCover = Utils.RandDouble(0.6, 0.9);    // 60-90% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(3); // 1-5 hours
            }
        }
    }

    private TimeSpan GenerateRandomWeatherDuration(int typicalHours = 6)
    {
        // int minHours = 1; // using roll instead which has 1 as default
        int maxHours = (typicalHours * 2) - 1;

        // triangular distribution - similar to normal dist, 
        // where values in the center are more common and extremes are rare
        // kind of like rolling dice, it's rare to roll 3 ones or 3 sixes
        int r1 = Utils.Roll(maxHours);
        int r2 = Utils.Roll(maxHours);
        int r3 = Utils.Roll(maxHours);
        double sum = r1 + r2 + r3;
        double average = sum / 3.0;
        int minutes = (int)(average * 60);
        return TimeSpan.FromMinutes(minutes);
    }

    private double GetTimeOfDayFactor()
    {
        // Returns 0-1 value representing relative temperature (0=coldest, 1=warmest)
        // todo combine this with seasonal day/ night lengths
        int minutesInDay = 24 * 60;
        int coldestTime = 4 * 60; // 4 AM

        int currentMinute = World.Time.Hour * 60 + World.Time.Minute;
        double minSinceColdest = currentMinute - coldestTime;
        double percentOfDay = minSinceColdest / minutesInDay; // scale so .5 is warmest and 0/1 is coldest
        double radians = 2 * Math.PI * percentOfDay; // scale for Cos

        // cos(x) => -1 to 1, but we need to shift to 0-1 so divide by 2 and shift up by 
        // but also the cos function needs to be flipped since cos(0 or 1) = 1, but we want 0 and 1 to be the min, so just * -1
        double temperature = -1 * (Math.Cos(radians) / 2) + .5; // Cos results in -1 to 1, so scale to 0-1 (divide 2, shift)

        return temperature;
    }

    // Convert Celsius to Fahrenheit
    public double TemperatureInFahrenheit => (BaseTemperature * 9 / 5) + 32;

    // Get detailed weather description
    public string GetWeatherDescription()
    {
        string temp = GetTemperatureDescription();
        string conditions = GetConditionsDescription();
        string wind = GetWindDescription();

        return $"{temp} {conditions} {wind}";
    }

    private string GetTemperatureDescription()
    {
        if (BaseTemperature < -25)
            return "It's brutally cold.";
        else if (BaseTemperature < -15)
            return "It's extremely cold.";
        else if (BaseTemperature < -5)
            return "It's very cold.";
        else if (BaseTemperature < 0)
            return "It's freezing cold.";
        else if (BaseTemperature < 5)
            return "It's cold.";
        else if (BaseTemperature < 10)
            return "It's cool.";
        else
            return "It's mild."; // As warm as it gets in Ice Age
    }

    private string GetConditionsDescription()
    {
        switch (CurrentCondition)
        {
            case WeatherCondition.Clear:
                return "The sky is clear.";

            case WeatherCondition.Cloudy:
                return "The sky is cloudy and gray.";

            case WeatherCondition.Misty:
                return "A cold mist hangs in the air.";

            case WeatherCondition.Rainy:
                if (Precipitation < 0.5)
                    return "A cold drizzle is falling.";
                else
                    return "Cold rain is falling steadily.";

            case WeatherCondition.LightSnow:
                if (Precipitation < 0.3)
                    return "A few snowflakes drift through the air.";
                else
                    return "Snow is falling steadily.";

            case WeatherCondition.Blizzard:
                return "A blizzard rages with heavy snow and wind.";

            case WeatherCondition.Stormy:
                return "A thunderstorm rumbles overhead.";

            default:
                return "";
        }
    }

    private string GetWindDescription()
    {
        if (WindSpeed < 0.2)           // 0-20%
            return "The air is still.";
        else if (WindSpeed < 0.4)      // 20-40%
            return "A light breeze blows.";
        else if (WindSpeed < 0.6)      // 40-60%
            return "A cold wind blows steadily.";
        else if (WindSpeed < 0.8)      // 60-80%
            return "Strong, bitter winds howl across the landscape.";
        else                           // 80-100%
            return "Powerful, freezing gusts threaten to knock you over.";
    }

    // Set season
    public void SetSeason(Season season)
    {
        CurrentSeason = season;
        GenerateNewWeather(); // Update weather for new season
    }
}


================================================================================

File: ./Environments/LocationFactory.cs
--------------------------------------------------------------------------------
using System.Diagnostics;
using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;
using text_survival.Survival;

namespace text_survival.Environments;

public static class LocationFactory
{
    public static Location MakeForest(Zone parent)
    {
        // Create a base forest location
        Location location = new Location("Forest", parent);
        
        // Generate a more descriptive name
        string[] forestNames = { "Forest", "Woodland", "Grove", "Thicket", "Pine Stand", "Birch Grove" };
        string[] forestAdjectives = { 
            "Ancient", "Overgrown", "Dense", "Old", "Misty", "Silent", "Frozen", "Snowy",
            "Windswept", "Breezy", "Quiet", "Primeval", "Shadowy", "Pristine", "Forgotten", 
            "Cold", "Frosty", "Dark", "Verdant", "Mossy", "Wet"
        };
        
        // Pick a random adjective and name
        string adjective = forestAdjectives[Utils.RandInt(0, forestAdjectives.Length - 1)];
        string name = forestNames[Utils.RandInt(0, forestNames.Length - 1)];
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with high resource density for forests (1.2)
        ForageFeature forageFeature = new ForageFeature(location, 1.2);
        
        // Add natural resources to the forage feature - more forest-appropriate items
        forageFeature.AddResource(ItemFactory.MakeBerry, 5.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeWater, 2.0);     // Available but not as common
        forageFeature.AddResource(ItemFactory.MakeMushroom, 4.0);  // Common in forests
        forageFeature.AddResource(ItemFactory.MakeStick, 8.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFirewood, 4.0);   // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 3.0);     // Fairly common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for forest
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Forest));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomForestItem();
            item.IsFound = true;
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);   // Common
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Rare
        
        // Determine if we should add NPCs initially (40% chance)
        if (Utils.RandInt(0, 9) < 4)
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            for (int i = 0; i < npcCount; i++)
            {
                location.Npcs.Add(npcSpawner.GenerateRandom());
            }
        }
        
        return location;
    }
    
    public static Location MakeCave(Zone parent)
    {
        // Create a base cave location
        Location location = new Location("Cave", parent);
        
        // Generate a more descriptive name
        string[] caveNames = { "Cave", "Cavern", "Grotto", "Hollow", "Shelter" };
        string[] caveAdjectives = { 
            "Dark", "Shadowy", "Damp", "Deep", "Frozen", "Narrow", "Winding", "Ancient", 
            "Hidden", "Secluded", "Limestone", "Rocky", "Echoing", "Protected", "Cold", 
            "Crystal", "Alabaster", "Granite", "Marble", "Glowing", "Frosty", "Icy"
        };
        
        // Pick a random adjective and name
        string adjective = caveAdjectives[Utils.RandInt(0, caveAdjectives.Length - 1)];
        string name = caveNames[Utils.RandInt(0, caveNames.Length - 1)];
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with moderate resource density for caves (0.8)
        ForageFeature forageFeature = new ForageFeature(location, 0.8);
        
        // Add resources to the forage feature - cave-appropriate items
        forageFeature.AddResource(ItemFactory.MakeMushroom, 3.0);  // Can find mushrooms in caves
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 2.0);     // More common in caves
        forageFeature.AddResource(ItemFactory.MakeClay, 1.0);      // Near cave entrances
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.3); // Rare but valuable
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for cave
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cave));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomCaveItem();
            item.IsFound = true;
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeSpider, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeRat, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeBat, 4.0);
        npcSpawner.AddActor(NpcFactory.MakeCaveBear, 0.5);
        
        // Determine if we should add NPCs initially (50% chance)
        if (Utils.RandInt(0, 9) < 5)
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            for (int i = 0; i < npcCount; i++)
            {
                location.Npcs.Add(npcSpawner.GenerateRandom());
            }
        }
        
        return location;
    }
    
    public static Location MakeRiverbank(Zone parent)
    {
        // Create a base riverbank location
        Location location = new Location("Riverbank", parent);
        
        // Generate a more descriptive name
        string[] riverNames = { "River", "Stream", "Creek", "Brook", "Rapids", "Ford", "Shallows" };
        string[] riverAdjectives = { 
            "Rushing", "Flowing", "Clear", "Muddy", "Wide", "Narrow", "Rocky", "Sandy",
            "Frozen", "Icy", "Shallow", "Deep", "Cold", "Misty", "Foggy", "Meandering", 
            "Winding", "Fast-flowing", "Gentle", "Quiet", "Noisy", "Bubbling", "Glistening"
        };
        
        // Pick a random adjective and name
        string adjective = riverAdjectives[Utils.RandInt(0, riverAdjectives.Length - 1)];
        string name = riverNames[Utils.RandInt(0, riverNames.Length - 1)];
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with good resource density for riverbanks (1.1)
        ForageFeature forageFeature = new ForageFeature(location, 1.1);
        
        // Add resources to the forage feature - river-appropriate items
        forageFeature.AddResource(ItemFactory.MakeWater, 10.0);    // Very abundant
        forageFeature.AddResource(ItemFactory.MakeFish, 6.0);      // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 4.0);     // Common near water
        forageFeature.AddResource(ItemFactory.MakeClay, 5.0);      // Common at riverbanks
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // River stones
        forageFeature.AddResource(ItemFactory.MakeFlint, 1.0);     // Occasionally found
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for riverbank
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.RiverBank));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomRiverbankItem();
            item.IsFound = true;
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner for riverbanks
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 2.0);   // Predators come to water
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Bears fish at rivers
        
        // Determine if we should add NPCs initially (30% chance)
        if (Utils.RandInt(0, 9) < 3)
        {
            location.Npcs.Add(npcSpawner.GenerateRandom());
        }
        
        return location;
    }
    
    public static Location MakePlain(Zone parent)
    {
        // Create a base plains location
        Location location = new Location("Plain", parent);
        
        // Generate a more descriptive name
        string[] plainNames = { "Plain", "Steppe", "Grassland", "Prairie", "Meadow", "Tundra" };
        string[] plainAdjectives = { 
            "Open", "Windy", "Cold", "Frozen", "Vast", "Rolling", "Endless", "Barren",
            "Grassy", "Windswept", "Desolate", "Frosty", "Icy", "Exposed", "Empty", 
            "Bleak", "Stark", "Harsh", "Rocky", "Flat", "Wild", "Mammoth"
        };
        
        // Pick a random adjective and name
        string adjective = plainAdjectives[Utils.RandInt(0, plainAdjectives.Length - 1)];
        string name = plainNames[Utils.RandInt(0, plainNames.Length - 1)];
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with low-moderate resource density for plains (0.7)
        ForageFeature forageFeature = new ForageFeature(location, 0.7);
        
        // Add resources to the forage feature - plains-appropriate items
        forageFeature.AddResource(ItemFactory.MakeRoots, 6.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeBerry, 2.0);     // Less common
        forageFeature.AddResource(ItemFactory.MakeStick, 1.0);     // Rare (few trees)
        forageFeature.AddResource(ItemFactory.MakeStone, 4.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for open plain
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.OpenPlain));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomPlainsItem();
            item.IsFound = true;
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner - plains have megafauna!
        var npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);               // Common
        npcSpawner.AddActor(NpcFactory.MakeWoollyMammoth, 0.5);      // Rare but possible
        npcSpawner.AddActor(NpcFactory.MakeSaberToothTiger, 0.7);    // Uncommon
        
        // Determine if we should add NPCs initially (40% chance)
        if (Utils.RandInt(0, 9) < 4)
        {
            location.Npcs.Add(npcSpawner.GenerateRandom());
        }
        
        return location;
    }
    
    public static Location MakeHillside(Zone parent)
    {
        // Create a base hillside location
        Location location = new Location("Hillside", parent);
        
        // Generate a more descriptive name
        string[] hillNames = { "Hill", "Ridge", "Slope", "Hillside", "Crag", "Bluff", "Knoll" };
        string[] hillAdjectives = { 
            "Rocky", "Steep", "Gentle", "Windswept", "Exposed", "Barren", "Craggy",
            "Rugged", "Snowy", "Icy", "Cold", "Stone", "High", "Misty", "Foggy", 
            "Eroded", "Ancient", "Weathered", "Protected", "Shaded", "Treacherous"
        };
        
        // Pick a random adjective and name
        string adjective = hillAdjectives[Utils.RandInt(0, hillAdjectives.Length - 1)];
        string name = hillNames[Utils.RandInt(0, hillNames.Length - 1)];
        location.Name = (adjective + " " + name).Trim();
        
        // Create a ForageFeature with moderate resource density for hillsides (0.9)
        ForageFeature forageFeature = new ForageFeature(location, 0.9);
        
        // Add resources to the forage feature - hillside-appropriate items
        forageFeature.AddResource(ItemFactory.MakeStone, 8.0);        // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 3.0);        // More common on hillsides
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.5); // Rare but possible
        forageFeature.AddResource(ItemFactory.MakeRoots, 2.0);         // Less common
        forageFeature.AddResource(ItemFactory.MakeOchrePigment, 1.0);  // Sometimes found on hills
        
        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);
        
        // Add an environment feature for hillside (using cliff as closest match)
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cliff));
        
        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomHillsideItem();
            item.IsFound = true;
            location.Items.Add(item);
        }
        
        // Configure the NPC spawner for hillsides
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 2.0);    // Snakes like rocky areas
        
        // Determine if we should add NPCs initially (30% chance)
        if (Utils.RandInt(0, 9) < 3)
        {
            location.Npcs.Add(npcSpawner.GenerateRandom());
        }
        
        return location;
    }
    
    // Helper methods to generate random location-appropriate items
    
    private static Item GetRandomForestItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 5.0 },
            { ItemFactory.MakeBerry, 4.0 },
            { ItemFactory.MakeStick, 8.0 },
            { ItemFactory.MakeFirewood, 5.0 },
            { ItemFactory.MakeTorch, 0.5 },
            { ItemFactory.MakeSpear, 0.2 },
            { ItemFactory.MakeHealingHerbs, 1.0 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomCaveItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 4.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 3.0 },
            { ItemFactory.MakeTorch, 1.0 },
            { ItemFactory.MakeBone, 4.0 },
            { ItemFactory.MakeObsidianShard, 0.5 },
            { ItemFactory.MakeOchrePigment, 0.2 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomRiverbankItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeWater, 8.0 },
            { ItemFactory.MakeFish, 5.0 },
            { ItemFactory.MakeClay, 6.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 2.0 },
            { ItemFactory.MakeRoots, 3.0 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomPlainsItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeRoots, 6.0 },
            { ItemFactory.MakeStone, 5.0 },
            { ItemFactory.MakeBone, 3.0 },
            { ItemFactory.MakeSinew, 1.0 },
            { ItemFactory.MakeBerry, 2.0 },
            { ItemFactory.MakeMammothTusk, 0.1 } // Very rare find
        };
        
        return Utils.GetRandomWeighted(options)();
    }
    
    private static Item GetRandomHillsideItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 5.0 },
            { ItemFactory.MakeObsidianShard, 1.0 },
            { ItemFactory.MakeOchrePigment, 2.0 },
            { ItemFactory.MakeHandAxe, 0.2 }
        };
        
        return Utils.GetRandomWeighted(options)();
    }
}================================================================================

