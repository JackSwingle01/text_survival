File: ./Player.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.Magic;
using text_survival.PlayerComponents;


namespace text_survival;

public class Player : Actor
{
    private readonly LocationManager locationManager;
    public readonly InventoryManager inventoryManager;
    public readonly SkillRegistry Skills;
    public readonly List<Spell> _spells = [SpellFactory.Bleeding, SpellFactory.Poison, SpellFactory.MinorHeal];

    public override void Update()
    {
        EffectRegistry.Update();
        var context = new SurvivalContext
        {
            ActivityLevel = 2,
            LocationTemperature = locationManager.CurrentLocation.GetTemperature(),
            ClothingInsulation = inventoryManager.ClothingInsulation,
        };
        Body.Update(TimeSpan.FromMinutes(1), context);
    }
    public void Sleep(int minutes)
    {
        bool fullyRested = Body.Rest(1);
        if (fullyRested)
        {
            Output.Write("You wake up feeling refreshed.\n");
        }

    }
    public override Weapon ActiveWeapon
    {
        get => inventoryManager.Weapon; protected set
        {
            inventoryManager.Weapon = value;
        }
    }

    // Location-related methods
    public override Location CurrentLocation
    {
        get => locationManager.CurrentLocation;
        set => locationManager.CurrentLocation = value;
    }

    public Zone CurrentZone => locationManager.CurrentZone;

    #region Constructor

    public Player(Location startingLocation) : base("Player", Body.BaselinePlayerStats)
    {
        Name = "Player";
        locationManager = new LocationManager(startingLocation);
        inventoryManager = new(EffectRegistry);
        Skills = new SkillRegistry();
    }


    #endregion Constructor

    public void DropItem(Item item)
    {
        inventoryManager.RemoveFromInventory(item);
        locationManager.AddItemToLocation(item);
    }

    public void TakeItem(Item item)
    {
        locationManager.RemoveItemFromLocation(item);
        inventoryManager.AddToInventory(item);
    }


    // public override BodyPart? Damage(DamageInfo damageInfo)
    // {
    //     var part = Body.Damage(damageInfo);
    //     // if (!IsAlive)
    //     // {
    //     //     // end program
    //     //     Output.WriteDanger("You died!");
    //     //     Environment.Exit(0);
    //     // }
    //     return part;
    // }

    public void DescribeSurvivalStats()
    {
        Body.DescribeSurvivalStats();
    }

    public void UseItem(Item item)
    {
        // handle special logic for each item type
        if (item is FoodItem food)
        {
            string eating_type = food.WaterContent > food.Calories ? "drink" : "eat";
            Output.Write($"You {eating_type} the ", food, "...");
            Body.Consume(food);
        }
        else if (item is ConsumableItem consumable)
        {
            foreach (Effect e in consumable.Effects)
            {
                EffectRegistry.AddEffect(e);
            }
        }
        else if (item is Gear gear)
        {
            Output.WriteLine("You equip the ", gear);
            inventoryManager.Equip(gear);
            foreach (Effect effect in gear.EquipEffects)
            {
                EffectRegistry.AddEffect(effect);
            }
        }

        else if (item is WeaponModifierItem weaponMod)
        {
            if (ModifyWeapon(weaponMod.Damage))
            {
                Output.WriteLine("You use the ", weaponMod, " to modify your ", inventoryManager.Weapon);
            }
            else
            {
                Output.WriteLine("You don't have a weapon equipped to modify.");
                return;
            }
        }
        else if (item is ArmorModifierItem armorMod)
        {
            if (ModifyArmor(armorMod.ValidArmorTypes[0], armorMod.Rating, armorMod.Warmth))
            {
                Output.WriteLine("You use the ", armorMod, " to modify your armor.");
            }
            else
            {
                Output.WriteLine("You don't have any armor you can use that on.");
                return;
            }
        }
        else
        {
            Output.Write("You don't know what to use the ", item, " for...\n");
            return;
        }
        // shared logic for all item types
        if (item.NumUses != -1)
        {
            item.NumUses -= 1;
            if (item.NumUses == 0)
            {
                inventoryManager.RemoveFromInventory(item);
            }
        }
        World.Update(1);
    }

    public bool ModifyWeapon(double damage)
    {
        if (!inventoryManager.IsArmed) return false;

        inventoryManager.Weapon.Damage += damage;
        return true;
    }
    public bool ModifyArmor(EquipSpots spot, double rating = 0, double warmth = 0)
    {
        Armor? armor = inventoryManager.GetArmorInSpot(spot);
        if (armor is null) return false;

        armor.Rating += rating;
        armor.Insulation += warmth;
        return true;
    }


    public void Travel() => locationManager.TravelToAdjacentZone();
}




public class SurvivalStatsUpdate
{
    public double Temperature;
    public double Calories;
    public double Hydration;
    public double Exhaustion;
}================================================================================

File: ./CombatUtils.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;

namespace text_survival;

public static class CombatUtils
{
    public static bool SpeedCheck(Player player, Actor enemy)
    {
        double playerCheck = CalcSpeedCheck(player);
        double enemyCheck = CalcSpeedCheck(enemy);

        return playerCheck >= enemyCheck;
    }

    public static Npc? GetFastestHostileNpc(Location location)
    {
        double fastestCheck = 0;
        Npc? fastestNpc = null;
        foreach (Npc npc in location.Npcs)
        {
            if (npc == fastestNpc) continue;
            if (!npc.IsAlive) continue;
            if (!npc.IsHostile) continue;

            fastestNpc ??= npc;

            var currentNpcCheck = CalcSpeedCheck(npc);
            if (currentNpcCheck > fastestCheck)
            {
                fastestNpc = npc;
                fastestCheck = currentNpcCheck;
            }
        }
        return fastestNpc;
    }

    public static double CalcSpeedCheck(Actor actor)
    {
        double athleticsBonus = 0;
        if (actor is Player player)
        {
            athleticsBonus = player.Skills.Reflexes.Level;
        }
        return actor.Body.CalculateSpeed() + athleticsBonus;
    }
}
================================================================================

File: ./CombatNarrator.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Items;

namespace text_survival;

public static class CombatNarrator
{
    private static readonly Dictionary<WeaponClass, List<string>> AttackVerbs = new()
    {
        { WeaponClass.Blade, new List<string> { "slashes", "cuts", "slices", "carves" } },
        { WeaponClass.Blunt, new List<string> { "bashes", "strikes", "smashes", "cracks" } },
        { WeaponClass.Pierce, new List<string> { "stabs", "pierces", "impales", "punctures" } },
        { WeaponClass.Claw, new List<string> { "tears", "rips", "rends", "shreds" } },
        { WeaponClass.Unarmed, new List<string> { "punches", "strikes", "hits", "pounds" } }
    };

    private static readonly Dictionary<WeaponType, List<string>> SpecialAttackDescriptions = new()
    {
        { WeaponType.Spear, new List<string> { "lunges with", "thrusts forward with", "strikes with" } },
        { WeaponType.Claws, new List<string> { "swipes with", "tears with", "mauls with" } },
        { WeaponType.Fangs, new List<string> { "bites with", "snaps with", "sinks" } },
        { WeaponType.Knife, new List<string> { "slashes with", "jabs with", "slices with" } },
        { WeaponType.Club, new List<string> { "swings", "brings down", "thumps with" } }
    };

    public static string DescribeAttack(Actor attacker, Actor target, double damage, string targetPart, bool isHit, bool isDodged, bool isBlocked)
    {
        var sb = new System.Text.StringBuilder();

        // 1. Attack Initiation
        sb.Append(DescribeAttackAttempt(attacker, target, targetPart));

        // 2. Attack Resolution
        if (isDodged)
            sb.Append(DescribeDodge(attacker, target));
        else if (isBlocked)
            sb.Append(DescribeBlock(attacker, target));
        else if (!isHit)
            sb.Append(DescribeMiss(attacker, target));
        else
            sb.Append(DescribeHit(attacker, target, damage, targetPart));

        return sb.ToString();
    }

    private static string DescribeAttackAttempt(Actor attacker, Actor target, string targetPart)
    {
        WeaponType weaponType = attacker.ActiveWeapon.Type;
        string weaponName = attacker.ActiveWeapon.Name;

        if (attacker is Player)
        {
            // Get special description based on weapon type if available
            if (SpecialAttackDescriptions.TryGetValue(weaponType, out var specialDescs))
            {
                string desc = specialDescs[Utils.RandInt(0, specialDescs.Count - 1)];
                return $"You {desc} your {weaponName}, at {target.Name}'s {targetPart}. ";
            }
            else
            {
                return $"You attack with your {weaponName}, aiming at {target.Name}'s {targetPart}. ";
            }
        }
        else
        {
            // Enemy attacking player
            if (SpecialAttackDescriptions.TryGetValue(weaponType, out var specialDescs))
            {
                string desc = specialDescs[Utils.RandInt(0, specialDescs.Count - 1)];
                return $"The {attacker.Name} {desc} its {weaponName} at your {targetPart}. ";
            }
            else
            {
                return $"The {attacker.Name} attacks with its {weaponName}, lunging at your {targetPart}. ";
            }
        }
    }

    private static string DescribeDodge(Actor attacker, Actor target)
    {
        if (target is Player)
            return $"You quickly sidestep the {attacker.Name}'s attack!";
        else
            return $"The {target.Name} nimbly evades your strike!";
    }

    private static string DescribeBlock(Actor attacker, Actor target)
    {
        if (target is Player)
            return $"You raise your {target.ActiveWeapon.Name} and deflect the attack!";
        else
            return $"The {target.Name} blocks your blow with its {target.ActiveWeapon.Name}!";
    }

    private static string DescribeMiss(Actor attacker, Actor target)
    {
        if (attacker is Player)
            return "Your attack misses, throwing you slightly off balance!";
        else
            return $"The {attacker.Name}'s attack whistles past you, missing entirely!";
    }

    private static string DescribeHit(Actor attacker, Actor target, double damage, string targetPart)
    {
        WeaponClass weaponClass = attacker.ActiveWeapon.Class;

        // Get appropriate attack verb based on weapon class
        string attackVerb;
        if (AttackVerbs.TryGetValue(weaponClass, out var verbs))
            attackVerb = verbs[Utils.RandInt(0, verbs.Count - 1)];
        else
            attackVerb = "strikes";

        // Describe damage severity
        string damageDesc = GetDamageSeverity(damage);

        // Describe hit
        if (attacker is Player)
        {
            return $"Your attack {attackVerb} the {target.Name}'s {targetPart}, dealing {damageDesc} damage! ({Math.Round(damage, 1)})";
        }
        else
        {
            return $"The {attacker.Name}'s attack {attackVerb} your {targetPart}, dealing {damageDesc} damage! ({Math.Round(damage, 1)})";
        }
    }

    private static string GetDamageSeverity(double damage)
    {
        if (damage <= 2) return "minimal";
        if (damage <= 5) return "light";
        if (damage <= 10) return "moderate";
        if (damage <= 15) return "severe";
        if (damage <= 25) return "critical";
        return "devastating";
    }

    public static string DescribeTargetStatus(string partName, double healthPercent)
    {
        if (healthPercent <= 0)
            return $"The {partName} is completely destroyed!";
        if (healthPercent < 0.15)
            return $"The {partName} is maimed and barely functioning!";
        if (healthPercent < 0.35)
            return $"The {partName} is gravely injured!";
        if (healthPercent < 0.6)
            return $"The {partName} is wounded.";
        if (healthPercent < 0.9)
            return $"The {partName} is lightly injured.";

        return "";
    }

    public static string DescribeCombatStart(Actor player, Actor enemy)
    {
        List<string> possibleStarts = new()
        {
            $"A {enemy.Name} emerges, its {enemy.ActiveWeapon.Name} at the ready!",
            $"A {enemy.Name} appears and prepares to attack!",
            $"You find yourself face to face with a {enemy.Name}!",
            $"A hostile {enemy.Name} blocks your path!",
            $"A {enemy.Name} lunges towards you suddenly!"
        };

        // Add special descriptions for certain enemy types
        if (enemy.Name.Contains("Wolf"))
            possibleStarts.Add("You hear growling as a wolf steps out from the shadows, fangs bared!");
        else if (enemy.Name.Contains("Bear"))
            possibleStarts.Add("A massive bear rears up on its hind legs, letting out a terrifying roar!");
        else if (enemy.Name.Contains("Snake"))
            possibleStarts.Add("A venomous snake rises up, hood flared, ready to strike!");

        return possibleStarts[Utils.RandInt(0, possibleStarts.Count - 1)];
    }
}================================================================================

File: ./Actors/Animal.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;

namespace text_survival.Actors
{
    public class Animal : Npc
    {
        public override Weapon ActiveWeapon { get; protected set; }

        public Animal(string name, Weapon weapon, BodyStats bodyStats) : base(name, weapon, bodyStats)
        {
            Name = name;
            ActiveWeapon = weapon;
        }


        public override string ToString() => Name;
    }
}================================================================================

File: ./Actors/IBuffable.cs
--------------------------------------------------------------------------------
﻿// using text_survival.Magic;

// namespace text_survival.Actors
// {
//     public interface IBuffable //: IActor
//     {
//         public List<Buff> Buffs { get; }

//         public void AddBuff(Buff buff)
//         {
//             if (buff.Target == null)
//                 buff.ApplyTo(this);
//             Buffs.Add(buff);
//         }
//         public void RemoveBuff(Buff buff)
//         {
//             if (buff.Target == this)
//                 buff.Remove();
//             Buffs.Remove(buff);
//         }

//     }
// }
================================================================================

File: ./Actors/ICombatant.cs
--------------------------------------------------------------------------------
﻿
// using text_survival.Items;
// using text_survival.Level;

// namespace text_survival.Actors
// {
//     public interface ICombatant
//     {
//         bool IsAlive { get; }
//         bool IsEngaged { get; set; }
//         Weapon ActiveWeapon { get; }
//         Attributes Attributes { get; }
//         SkillRegistry _skillRegistry {get;}
//         double ConditionPercent { get; }
//         void Attack(ICombatant target);
//         // double DetermineDamage();
//         // double DetermineHitChance(ICombatant defender);
//         // double DetermineDodgeChance(ICombatant attacker);
//         // double DetermineBlockChance(ICombatant attacker);

//     }
// }
================================================================================

File: ./Actors/NPCFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;

namespace text_survival.Actors
{
    public static class NpcFactory
    {
        public static Animal MakeRat()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 2, // large rat
                fatPercent = 0.15,   // 15% fat
                musclePercent = 0.40 // 40% muscle
            };

            // Create a natural weapon for the rat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "teeth", 100)
            {
                Damage = 2,
                Accuracy = 1.2
            };

            Animal rat = new("Rat", weapon, bodyStats)
            {
                Description = "A rat with fleas."
            };
            rat.AddLoot(ItemFactory.MakeSmallMeat());
            return rat;
        }

        public static Animal MakeWolf()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 40,   // 40 kg - average wolf
                fatPercent = 0.20,    // 20% fat
                musclePercent = 0.60  // 60% muscle - wolves are muscular
            };

            // Create a natural weapon for the wolf
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.1
            };

            Animal wolf = new("Wolf", weapon, bodyStats)
            {
                Description = "A wolf."
            };
            wolf.AddLoot(ItemFactory.MakeLargeMeat());
            return wolf;
        }

        public static Animal MakeBear()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 250,  // 250 kg - large bear
                fatPercent = 0.30,    // 30% fat - bears have more fat reserves
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "claws", 100)
            {
                Damage = 20,
                Accuracy = 0.9
            };

            Animal bear = new("Bear", weapon, bodyStats)
            {
                Description = "A bear."
            };
            bear.AddLoot(ItemFactory.MakeLargeMeat());
            return bear;
        }

        public static Animal MakeSnake()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Serpentine,
                overallWeight = 5,    // 5 kg - medium sized snake
                fatPercent = 0.10,    // 10% fat
                musclePercent = 0.80  // 80% muscle - snakes are almost all muscle
            };

            // Create a natural weapon for the snake
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.0
            };

            Animal snake = new("Snake", weapon, bodyStats)
            {
                Description = "A venomous snake."
            };

            LootTable loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSmallMeat, 2);
            loot.AddItem(ItemFactory.MakeVenomSac);
            snake.AddLoot(loot.GenerateRandomItem());

            // TODO: Apply venom effect
            // snake.ApplyEffect(new PoisonEffect("venom", "natural", 0.8, 2, 180));

            return snake;
        }

        public static Animal MakeBat()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Flying,
                overallWeight = 0.2,   // 200g - small bat
                fatPercent = 0.20,     // 20% fat 
                musclePercent = 0.65   // 65% muscle - flying requires strong muscles
            };

            // Create a natural weapon for the bat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Tiny Teeth", 100)
            {
                Damage = 2,
                Accuracy = 0.9
            };

            Animal bat = new("Bat", weapon, bodyStats)
            {
                Description = "A small bat with leathery wings."
            };

            return bat;
        }

        public static Animal MakeSpider()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Arachnid,
                overallWeight = 0.1,   // 100g - large spider
                fatPercent = 0.05,     // 5% fat
                musclePercent = 0.45   // 45% muscle
            };

            // Create a natural weapon for the spider
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Mandibles", 100)
            {
                Damage = 5,
                Accuracy = 1.2
            };

            Animal spider = new("Spider", weapon, bodyStats)
            {
                Description = "A venomous spider with long hairy legs."
            };

            // TODO: Apply venom effect
            // spider.ApplyEffect(new PoisonEffect("venom", "natural", 0.6, 1, 120));

            var loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSpiderSilk);
            loot.AddItem(ItemFactory.MakeVenomSac);
            spider.AddLoot(loot.GenerateRandomItem());

            return spider;
        }

        public static Animal MakeCaveBear()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 350,  // 350 kg - larger than a regular bear
                fatPercent = 0.35,    // 35% fat - more for cave survival
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the cave bear - stronger than regular bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "Massive Claws", 100)
            {
                Damage = 25,
                Accuracy = 0.85
            };

            Animal caveBear = new("Cave Bear", weapon, bodyStats)
            {
                Description = "An enormous cave bear with massive claws. It's adapted to cave dwelling and hunting in darkness."
            };

            // Add more meat due to larger size
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());

            return caveBear;
        }

        public static Animal MakeWoollyMammoth()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 6000,  // 6 tons - enormous
                fatPercent = 0.35,     // 35% fat for cold protection
                musclePercent = 0.50   // 50% muscle
            };

            // Create a natural weapon for the mammoth
            var weapon = new Weapon(WeaponType.Horns, WeaponMaterial.Organic, "Tusks", 100)
            {
                Damage = 35,
                Accuracy = 0.7
            };

            Animal mammoth = new("Woolly Mammoth", weapon, bodyStats)
            {
                Description = "A massive woolly mammoth with long curved tusks and a thick fur coat."
            };

            // Add large amount of meat and other rare resources
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());

            return mammoth;
        }

        public static Animal MakeSaberToothTiger()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Quadruped,
                overallWeight = 300,   // 300 kg - large cat
                fatPercent = 0.15,     // 15% fat
                musclePercent = 0.70   // 70% muscle - extremely powerful
            };

            // Create a natural weapon for the saber-tooth
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Massive Fangs", 100)
            {
                Damage = 30,
                Accuracy = 1.0
            };

            Animal saberTooth = new("Saber-Tooth Tiger", weapon, bodyStats)
            {
                Description = "A fearsome predator with long saber-like canine teeth."
            };

            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());
            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());

            return saberTooth;
        }

        // Human NPCs with various weapons
        public static Npc MakeTribalHunter()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 65,
                fatPercent = 0.15,
                musclePercent = 0.60
            };

            // Create a hunting spear
            var weapon = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Wooden Spear", 75)
            {
                Damage = 8,
                Accuracy = 1.2
            };

            // Create hunter with spear
            Npc hunter = new("Tribal Hunter", weapon, bodyStats)
            {
                Description = "A lean, muscular hunter from a nearby tribe."
            };

            // Add some basic equipment to loot
            hunter.AddLoot(ItemFactory.MakeSmallMeat());

            return hunter;
        }

        public static Npc MakeTribalWarrior()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 70,
                fatPercent = 0.15,
                musclePercent = 0.65
            };

            // Create a war club
            var weapon = new Weapon(WeaponType.Club, WeaponMaterial.Stone, "War-Club", 80)
            {
                Damage = 12,
                Accuracy = 0.9
            };

            // Create warrior with club
            Npc warrior = new("Tribal Warrior", weapon, bodyStats)
            {
                Description = "A fierce warrior with ritual paint markings."
            };

            // Add some loot
            warrior.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Knapped-Flint Scraper", 60));

            return warrior;
        }

        public static Npc MakeTribalShaman()
        {
            var bodyStats = new BodyStats
            {
                type = BodyPartFactory.BodyTypes.Human,
                overallWeight = 60,
                fatPercent = 0.20,
                musclePercent = 0.45
            };

            // Create a ritual staff
            var weapon = new Weapon(WeaponType.Knife, WeaponMaterial.Bone, "Shamanic Bone-Knife", 90)
            {
                Damage = 6,
                Accuracy = 1.1
            };

            // Create shaman with staff
            Npc shaman = new("Tribal Shaman", weapon, bodyStats)
            {
                Description = "An elderly shaman adorned with animal bones and feathers."
            };

            // Add some rare loot
            shaman.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Obsidian, "Night-Glass Ritual Knife", 95));

            return shaman;
        }
    }
}================================================================================

File: ./Actors/Actor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.Items;
using text_survival.PlayerComponents;

namespace text_survival.Actors;

public abstract class Actor
{
    public string Name;
    public virtual Location? CurrentLocation { get; set; }
    public virtual void Attack(Actor target, IBodyPart? bodyPart = null) => combatManager.Attack(target, bodyPart);

    public virtual void Damage(DamageInfo damage) => Body.Damage(damage);
    public virtual void Heal(HealingInfo heal) => Body.Heal(heal);

    public bool IsEngaged { get; set; }
    public bool IsAlive => !Body.IsDestroyed;
    public abstract Weapon ActiveWeapon { get; protected set; }

    public virtual void Update()
    {
        EffectRegistry.Update();
        var context = new SurvivalContext
        {
            ActivityLevel = 2,
            LocationTemperature = CurrentLocation.GetTemperature(),
        };
        Body.Update(TimeSpan.FromMinutes(1), context);
    }
    public Body Body { get; init; }
    public EffectRegistry EffectRegistry { get; init; }
    protected CombatManager combatManager { get; init; }

    public override string ToString() => Name;

    protected Actor(string name, BodyStats stats)
    {
        Name = name;
        EffectRegistry = new EffectRegistry(this);
        this.combatManager = new CombatManager(this);
        Body = new Body(Name, stats, EffectRegistry);
    }
}


================================================================================

File: ./Actors/NPC.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Items;
using text_survival.Bodies;

namespace text_survival.Actors
{
    public class Npc : Actor
    {
        #region Properties

        // Basic properties
        public string Description { get; set; }
        public bool IsFound { get; set; }
        public bool IsHostile { get; private set; }
        public override Weapon ActiveWeapon { get; protected set; }

        // IPhysicalEntity implementation
        public double Health => Body.Health;
        public double MaxHealth => Body.MaxHealth;
        public bool IsDestroyed => Body.IsDestroyed;

        // Internal components

        public Container Loot { get; }

        #endregion

        #region Constructor

        public Npc(string name, Weapon weapon, BodyStats stats) : base(name, stats)
        {
            Description = "";
            IsHostile = true;
            ActiveWeapon = weapon;
            Loot = new Container(name, 10);
        }

        #endregion

        #region Inventory and Loot Methods

        public void AddLoot(Item item) => Loot.Add(item);

        #endregion

        public override string ToString() => Name;
    }
}================================================================================

File: ./Items/Container.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Items
{
    public class Container(string name, float maxWeight)
    {
        private string _name = name;
        public string Name { get => IsEmpty ? _name + " (Empty)" : _name; set => _name = value; }
        public double Weight() => Items.Sum(item => item.Weight);
        public float MaxWeight { get; set; } = maxWeight;
        public List<Item> Items { get; } = [];
        public bool IsEmpty => Items.Count == 0;
        public bool IsFound { get; set; }

        public Item GetItem(int index) => Items[index];
        public Item GetItemByName(string itemName) => Items.First(i => i.Name.Equals(itemName));

        // public virtual void Open(Player player)
        // {
        //     while (!IsEmpty)
        //     {
        //         Output.WriteLine(this, ":");

        //         var items = new List<Item>(Items);
        //         Item takeAll = new Item("Take all");
        //         if (items.Count > 1)
        //         {
        //             items.Add(takeAll);
        //         }

        //         var itemStacks = ItemStack.CreateStacksFromItems(items);

        //         var selection = Input.GetSelectionFromList(itemStacks, true, "Close " + this);
        //         if (selection == null) return;

        //         Item selectedItem = selection.Pop();

        //         if (selectedItem == takeAll)
        //         {
        //             TakeAll(player);
        //             return;
        //         }

        //         Output.WriteLine("What would you like to do with ", selectedItem);
        //         string? choice = Input.GetSelectionFromList(["Take", "Inspect"], true);
        //         switch (choice)
        //         {
        //             case null:
        //                 continue;
        //             case "Take":
        //                 Remove(selectedItem);
        //                 player.TakeItem(selectedItem);
        //                 break;
        //             case "Inspect":
        //                 selectedItem.Describe();
        //                 break;
        //             case "Use":
        //                 Remove(selectedItem);
        //                 player.TakeItem(selectedItem);
        //                 player.UseItem(selectedItem);
        //                 break;
        //         }
        //     }
        //     Output.WriteLine(this, " is empty.");
        // }


     
        public override string ToString() => Name;

        public void Add(Item item)
        {
            if (item.Weight + Weight() > MaxWeight)
            {
                Output.Write("The ", this, "is full!\n");
                return;
            }
            Items.Add(item);
        }

        public void Remove(Item item) => Items.Remove(item);
        public int Count() => Items.Count;

    }
}
================================================================================

File: ./Items/Item.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Items
{
    public class Item
    {
        public string Name { get; set; }
        public double Weight { get; set; } // in kg
        public string Description { get; set; } = "";
        public double Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
        public bool IsFound { get; set; }
        public int NumUses { get; set; }

        public Item(string name, double weight = 1, int quality = 50)
        {
            Name = name;
            Weight = weight;
            Quality = quality;
            NumUses = -1; // not consumable
        }

        public void Describe()
        {
            Output.Write(this, " => ", Description, " ");
            if (this is Weapon weapon)
            {
                Output.Write("Damage: ", weapon.Damage, " hp, ");
                Output.Write("Hit Chance: ", weapon.Accuracy * 100, "%, ");
                if (weapon.BlockChance != 0)
                {
                    Output.Write(", BlockChance: ", weapon.BlockChance * 100, "%, ");
                }
            }
            else if (this is Armor armor)
            {
                if (armor.Rating != 0)
                    Output.Write("Defense: ", armor.Rating * 100, "%, ");

                if (armor.Insulation != 0)
                    Output.Write("Warmth: ", armor.Insulation, "F, ");
            }

            if (Weight != 0)
            {
                Output.Write("Weight: ", Weight, "kg");
            }
            Output.WriteLine();
        }
        public override string ToString()
        {
            return Name;
        }
        
    }
}
================================================================================

File: ./Items/FoodItem.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;

namespace text_survival.Items
{
    public interface IEdible
    {
        int WaterContent { get; }
        int Calories { get; }
    }

    public class FoodItem : Item, IEdible
    {
        public FoodItem(string name, int calories, int waterContent = 0, double weight = .5) : base(name, weight)
        {
            Quality = 100;
            Calories = calories;
            WaterContent = waterContent;
            NumUses = 1;
        }

        public int WaterContent { get; }
        public int Calories { get; }
        public HealingInfo? HealthEffect {get; set;}
        public DamageInfo? DamageEffect {get; set;}
        public void Update()
        {
            Quality -= .1; //TODO: Add spoilage
        }
        public override string ToString() => Name;
    }
}
================================================================================

File: ./Items/IEquippable.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Effects;

namespace text_survival.Items
{
    public interface IEquippable
    {
        // public List<Buff> GetEquipBuffs();
        // public void AddEquipBuff(Buff buff);
        // public void RemoveEquipBuff(Buff buff);
        public List<Effect> EquipEffects { get; }
    }

}================================================================================

File: ./Items/ItemStack.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class ItemStack
{
    public string DisplayName => Items.Count == 1 ? FirstItem.Name : $"{FirstItem.Name} x{Items.Count}";
    public Item FirstItem { get; private set; }
    public Stack<Item> Items { get; private set; }
    public int Count => Items.Count;
    
    public ItemStack(Item item)
    {
        FirstItem = item;
        Items = new Stack<Item>();
        Items.Push(item);
    }
    
    public void Add(Item item)
    {
        if (item.Name != FirstItem.Name)
        {
            throw new ArgumentException($"Cannot add item '{item.Name}' to stack of '{FirstItem.Name}'");
        }
        
        Items.Push(item);
    }
    
    public Item Pop() => Items.Pop();
    public Item Peek() => Items.Peek();
    
    public override string ToString() => DisplayName;
    
    public static List<ItemStack> CreateStacksFromItems(IEnumerable<Item> items)
    {
        var stacksByName = new Dictionary<string, ItemStack>();
        
        foreach (var item in items)
        {
            if (stacksByName.TryGetValue(item.Name, out var stack))
            {
                stack.Add(item);
            }
            else
            {
                stacksByName[item.Name] = new ItemStack(item);
            }
        }
        
        return stacksByName.Values.ToList();
    }
}================================================================================

File: ./Items/Gear.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Gear : Item, IEquippable
    {
        // private List<Buff> EquipBuffs { get; }
        // public List<Buff> GetEquipBuffs() => EquipBuffs;
        // public void AddEquipBuff(Buff buff) => EquipBuffs.Add(buff);
        // public void RemoveEquipBuff(Buff buff) => EquipBuffs.Remove(buff);
        public List<Effect> EquipEffects { get; set; }
        public double Insulation { get; set; }
        public Gear(string name, double weight = 1, int quality = 50) : base(name, weight, quality)
        {
            EquipEffects = [];
        }
    }

}

================================================================================

File: ./Items/ConsumableItem.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.Items;

namespace text_survival.Actors;

class ConsumableItem : Item
{
    public ConsumableItem(string name, int numUses=1) : base(name)
    {
        Effects = [];
        NumUses = numUses;
    }

    public List<Effect> Effects;
}
================================================================================

File: ./Items/ModifierItem.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class WeaponModifierItem : Item
{
    public double Damage { get; set; }
    public WeaponModifierItem(string name) : base(name)
    {
        Damage = 0;
    }

}

public class ArmorModifierItem : Item
{
    public List<EquipSpots> ValidArmorTypes;
    public double Warmth { get; set; }
    public double Rating { get; set; }
    public ArmorModifierItem(string name, List<EquipSpots> validArmorTypes) : base(name)
    {
        ValidArmorTypes = validArmorTypes;
        Warmth = 0;
        Rating = 0;
    }

}================================================================================

File: ./Items/Armor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Armor : Gear
    {
        public EquipSpots EquipSpot { get; set; }
        public double Rating { get; set; }
        public ArmorClass Type { get; set; }

        public Armor(string name, double rating, EquipSpots equipSpot, double warmth = 0, ArmorClass type = ArmorClass.Light) : base(name)
        {
            EquipEffects = [];
            Rating = rating;
            EquipSpot = equipSpot;
            Insulation = warmth;
            Type = type;
        }


    }
}================================================================================

File: ./Items/ItemEnums.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum EquipSpots
    {
        Head,
        Chest,
        Legs,
        Feet,
        Hands,
        Weapon
    }

    public enum ArmorClass
    {
        Light,
        Heavy
    }







}================================================================================

File: ./Items/Weapon.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum WeaponType
    {
        // Crafted weapons
        Spear,          // Long distance hunting/combat
        Club,           // Heavy blunt force
        HandAxe,        // Cutting tool and weapon
        Knife,          // Sharp tool made of flint or similar
        SharpStone,     // Primitive cutting tool

        // Natural weapons
        Unarmed,        // Human fists
        Claws,          // Bear, large feline
        Fangs,          // Wolf, snake
        Horns           // Mammoth tusks, deer antlers
    }

    public enum WeaponClass
    {
        Blade,          // Cutting damage
        Blunt,          // Impact damage
        Pierce,         // Stabbing damage
        Claw,           // Tearing damage
        Unarmed         // Basic damage
    }

    public enum WeaponMaterial
    {
        Wood,           // Sticks, branches
        Stone,          // Basic stone
        Bone,           // Animal bones
        Antler,         // Deer/elk antlers
        Flint,          // Knapped flint
        Obsidian,       // Volcanic glass
        Organic,        // Natural animal weapons
        Other           // Miscellaneous
    }
    public class Weapon : Gear
    {
        public WeaponClass Class { get; set; }
        public WeaponMaterial Material { get; set; }
        public WeaponType Type { get; set; }
        public double Damage { get; set; }
        public double Accuracy { get; set; }
        public double BlockChance { get; set; }
        public double Craftsmanship { get; set; }

        public Weapon(WeaponType type, WeaponMaterial material, string name = "", int craftsmanship = 50)
            : base(name, quality: craftsmanship)
        {
            Craftsmanship = craftsmanship;
            SetBaseStats(type);
            ApplyMaterialModifier(material);
            ApplyCraftsmanshipModifier();
            Class = GetDamageTypeFromWeaponType(type);

            if (string.IsNullOrWhiteSpace(name))
                Name = $"{GetCraftsmanshipDescription(Craftsmanship)} {GetMaterialDescription(material)} {GetWeaponTypeDescription(type)}";

            Type = type;
            Material = material;
            EquipEffects = [];
        }

        private void ApplyCraftsmanshipModifier()
        {
            // The better crafted the weapon, the more effective it is
            Damage *= (Craftsmanship * 1.5) / 100;
            BlockChance *= Craftsmanship / 100;
        }

        private void ApplyMaterialModifier(WeaponMaterial material)
        {
            switch (material)
            {
                case WeaponMaterial.Wood:
                    Damage *= 0.6;
                    BlockChance *= 0.7;
                    Weight *= 0.5;
                    break;
                case WeaponMaterial.Stone:
                    Damage *= 1.0;
                    BlockChance *= 0.6;
                    Weight *= 1.2;
                    break;
                case WeaponMaterial.Bone:
                    Damage *= 0.8;
                    BlockChance *= 0.8;
                    Weight *= 0.7;
                    break;
                case WeaponMaterial.Antler:
                    Damage *= 0.9;
                    BlockChance *= 0.7;
                    Weight *= 0.8;
                    break;
                case WeaponMaterial.Flint:
                    Damage *= 1.2;
                    BlockChance *= 0.5;
                    Weight *= 1.0;
                    break;
                case WeaponMaterial.Obsidian:
                    Damage *= 1.4;
                    BlockChance *= 0.4;
                    Weight *= 0.9;
                    break;
                case WeaponMaterial.Organic:
                case WeaponMaterial.Other:
                default:
                    // No modifiers for natural/organic materials
                    break;
            }
        }

        private void SetBaseStats(WeaponType type)
        {
            switch (type)
            {
                case WeaponType.Spear:
                    Damage = 8;
                    BlockChance = 0.12;
                    Accuracy = 1.2;
                    Weight = 1.5;
                    break;
                case WeaponType.Club:
                    Damage = 10;
                    BlockChance = 0.08;
                    Accuracy = 0.9;
                    Weight = 2.0;
                    break;
                case WeaponType.HandAxe:
                    Damage = 12;
                    BlockChance = 0.05;
                    Accuracy = 0.8;
                    Weight = 1.8;
                    break;
                case WeaponType.Knife:
                    Damage = 6;
                    BlockChance = 0.02;
                    Accuracy = 1.4;
                    Weight = 0.5;
                    break;
                case WeaponType.SharpStone:
                    Damage = 4;
                    BlockChance = 0.01;
                    Accuracy = 1.1;
                    Weight = 0.3;
                    break;
                case WeaponType.Unarmed:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.5;
                    Weight = 0;
                    break;
                default:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.0;
                    Weight = 0.5;
                    break;
            }
        }

        public static Weapon GenerateRandomWeapon()
        {
            // Filter out unarmed and natural weapons when generating random weapons
            var validTypes = Enum.GetValues(typeof(WeaponType))
                .Cast<WeaponType>()
                .Where(t => t != WeaponType.Unarmed &&
                            t != WeaponType.Claws &&
                            t != WeaponType.Fangs &&
                            t != WeaponType.Horns)
                .ToArray();

            // Filter out organic and other from random generation
            var validMaterials = Enum.GetValues(typeof(WeaponMaterial))
                .Cast<WeaponMaterial>()
                .Where(m => m != WeaponMaterial.Organic && m != WeaponMaterial.Other)
                .ToArray();

            WeaponMaterial material = validMaterials[Utils.RandInt(0, validMaterials.Length - 1)];
            WeaponType type = validTypes[Utils.RandInt(0, validTypes.Length - 1)];

            int craftsmanship = Utils.RandInt(30, 80); // Primitive technology has limited upper quality

            return new Weapon(type, material, craftsmanship: craftsmanship);
        }

        private static WeaponClass GetDamageTypeFromWeaponType(WeaponType type)
        {
            return type switch
            {
                WeaponType.Knife => WeaponClass.Blade,
                WeaponType.SharpStone => WeaponClass.Blade,
                WeaponType.HandAxe => WeaponClass.Blade,
                WeaponType.Spear => WeaponClass.Pierce,
                WeaponType.Club => WeaponClass.Blunt,
                WeaponType.Unarmed => WeaponClass.Unarmed,
                WeaponType.Claws => WeaponClass.Claw,
                WeaponType.Fangs => WeaponClass.Pierce,
                WeaponType.Horns => WeaponClass.Pierce,
                _ => WeaponClass.Blunt,
            };
        }

        private string GetCraftsmanshipDescription(double craftsmanship)
        {
            return craftsmanship switch
            {
                0 => "Broken",
                < 20 => "Primitive",
                < 40 => "Rough",
                < 60 => "Simple",
                < 80 => "Sturdy",
                < 95 => "Master Crafted",
                <= 100 => "Flawless",
                _ => "Strange"
            };
        }

        private string GetMaterialDescription(WeaponMaterial material)
        {
            return material switch
            {
                WeaponMaterial.Wood => "Wooden",
                WeaponMaterial.Stone => "Stone",
                WeaponMaterial.Bone => "Bone",
                WeaponMaterial.Antler => "Antler",
                WeaponMaterial.Flint => "Flint",
                WeaponMaterial.Obsidian => "Obsidian",
                WeaponMaterial.Organic => "",
                WeaponMaterial.Other => "",
                _ => ""
            };
        }

        private string GetWeaponTypeDescription(WeaponType type)
        {
            return type switch
            {
                WeaponType.Spear => "Spear",
                WeaponType.Club => "Club",
                WeaponType.HandAxe => "Hand Axe",
                WeaponType.Knife => "Knife",
                WeaponType.SharpStone => "Sharp Stone",
                WeaponType.Unarmed => "Fists",
                WeaponType.Claws => "Claws",
                WeaponType.Fangs => "Fangs",
                WeaponType.Horns => "Horns",
                _ => "Tool"
            };
        }
    }
}================================================================================

File: ./Items/ItemFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Effects;


namespace text_survival.Items
{
    public class ItemFactory
    {
        public static readonly Dictionary<string, Func<Item>> ItemDefinitions = new()
        {
            { "Mushroom", MakeMushroom },
            { "Berries", MakeBerry },
            { "Roots", MakeRoots },
            { "Water", MakeWater },
            { "Stick", MakeStick },
            { "Firewood", MakeFirewood },
            { "Flint", MakeFlint },
            { "Clay", MakeClay },
            { "Stone", MakeStone },
            { "Bone", MakeBone },
            { "Spear", MakeSpear },
            { "Club", MakeClub },
            { "HandAxe", MakeHandAxe },
            { "Knife", MakeKnife },
            { "Hide Shield", MakeHideShield },
            { "Fur Armor", MakeFurArmor },
            { "Healing Herbs", MakeHealingHerbs },
            { "Bandage", MakeBandage },
            { "Torch", MakeTorch },
            { "Fish", MakeFish },
            { "Primitive Weapon", Weapon.GenerateRandomWeapon }
        };

        public static Weapon MakeFists()
        {
            return new Weapon(WeaponType.Unarmed, WeaponMaterial.Organic, "Bare Hands");
        }

        public static FoodItem MakeMushroom()
        {
            var mushroom = new FoodItem("Wild Mushroom", 25, 5)
            {
                Description = "A forest mushroom. Some varieties are nutritious, others are deadly.",
                Weight = 0.1F
            };

            double strength = Utils.RandDouble(1, 15);
            string targetOrgan = Utils.GetRandomFromList(["Stomach", "Liver", "Kidney"]);

            if (Utils.FlipCoin())
            {
                mushroom.HealthEffect = new()
                {
                    Amount = strength,
                    Type = "herbal",
                    TargetOrgan = targetOrgan,
                    Quality = Utils.RandDouble(0, 1.5)
                };
            }
            else
            {
                mushroom.DamageEffect = new()
                {
                    Amount = strength * .66,
                    IsPenetrating = true,
                    Type = "poison",
                    TargetOrgan = targetOrgan,
                    Accuracy = 1,
                };
            }
            return mushroom;
        }

        public static FoodItem MakeBerry()
        {
            var item = new FoodItem("Wild Berries", 120, 100);
            string color = Utils.GetRandomFromList(["red", "blue", "black", "purple"]);
            string season = Utils.GetRandomFromList(["autumn", "summer"]);
            item.Description = $"A handful of {color} {season} berries. Sweet and juicy.";
            item.Weight = 0.1F;
            return item;
        }

        public static FoodItem MakeRoots()
        {
            var item = new FoodItem("Foraged Roots", 100, 20)
            {
                Description = "Starchy roots dug from the ground. Tough but nutritious.",
                Weight = 0.3F
            };
            return item;
        }

        public static FoodItem MakeWater()
        {
            var item = new FoodItem("Fresh Water", 0, 1000)
            {
                Description = "Clear water collected from a stream. Stored in a water skin made from animal bladder.",
                Weight = 1
            };
            return item;
        }

        public static Item MakeStick()
        {
            Item stick = new Item("Sturdy Stick")
            {
                Description = "A strong branch, useful for making tools and weapons.",
                Weight = 0.5
            };
            return stick;
        }

        public static Item MakeFirewood()
        {
            var wood = new Item("Firewood")
            {
                Description = "Dry wood gathered for making fires. Essential for warmth and cooking.",
                Weight = 1.5
            };
            return wood;
        }

        public static Item MakeFlint()
        {
            var flint = new Item("Knapping Flint")
            {
                Description = "Sharp-edged stone perfect for making cutting tools and starting fires.",
                Weight = 0.2
            };
            return flint;
        }

        public static Item MakeClay()
        {
            var clay = new Item("River Clay")
            {
                Description = "Malleable clay gathered from a riverbank. Could be shaped into vessels.",
                Weight = 1.0
            };
            return clay;
        }

        public static Item MakeStone()
        {
            var item = new Item("River Stone")
            {
                Description = "A smooth river stone. Useful for tools or cooking.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeBone()
        {
            var bone = new Item("Animal Bone")
            {
                Description = "A sturdy bone from a large animal. Good material for tools and weapons.",
                Weight = 0.3
            };
            return bone;
        }

        public static Weapon MakeSpear()
        {
            Weapon spear = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Hunting Spear", 65)
            {
                Description = "A long wooden shaft with a sharpened flint point. Good for hunting and defense.",
                Weight = 1.5
            };
            return spear;
        }

        public static Weapon MakeClub()
        {
            Weapon club = new Weapon(WeaponType.Club, WeaponMaterial.Wood, "War Club", 60)
            {
                Description = "A heavy wooden club reinforced with stone. Brutal but effective.",
                Weight = 2.0
            };
            return club;
        }

        public static Weapon MakeHandAxe()
        {
            Weapon axe = new Weapon(WeaponType.HandAxe, WeaponMaterial.Stone, "Stone Hand Axe", 70)
            {
                Description = "A sharp stone blade bound to a wooden handle with animal sinew.",
                Weight = 1.8
            };
            return axe;
        }

        public static Weapon MakeKnife()
        {
            Weapon knife = new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Flint Knife", 75)
            {
                Description = "A razor-sharp flint blade with a bone handle. Essential for skinning and cutting.",
                Weight = 0.4
            };
            return knife;
        }

        public static Armor MakeHideShield()
        {
            Armor shield = new Armor("Hide Shield", .15, EquipSpots.Hands, 1)
            {
                Description = "A wooden frame covered with animal hide. Offers basic protection.",
                Weight = 2.0
            };
            return shield;
        }

        public static Armor MakeFurArmor()
        {
            Armor armor = new Armor("Fur Armor", .25, EquipSpots.Chest, 8)
            {
                Description = "A thick fur pelt worn as protection. Offers warmth and some defense against attacks.",
                Weight = 3.0
            };
            return armor;
        }

        public static FoodItem MakeLargeMeat()
        {
            var item = new FoodItem("Large Game Meat", 600, 0)
            {
                Description = "A substantial cut of meat from a large animal. Will need to be cooked.",
                Weight = 1.5
            };
            return item;
        }

        public static FoodItem MakeSmallMeat()
        {
            var item = new FoodItem("Small Game Meat", 200, 0)
            {
                Description = "A modest portion of meat from a small animal. Best cooked before eating.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeHealingHerbs()
        {
            var herbs = new FoodItem("Healing Herbs", 10, 5)
            {
                Description = "A bundle of medicinal plants known for their healing properties.",
                Weight = 0.2,
                NumUses = 1,
                HealthEffect = new()
                {
                    Amount = 15,
                    Type = "herbal",
                    Quality = 0.7,
                    TargetOrgan = null
                }
            };
            return herbs;
        }

        public static Item MakeBandage()
        {
            var bandage = new ConsumableItem("Bark Bandage")
            {
                Description = "Strips of inner tree bark pounded soft. Can bind wounds and stop bleeding.",
                Weight = 0.1,
                Effects = [
                    new RemoveBleedEffect("bandage", null)
                ]
            };
            return bandage;
        }

        public static Gear MakeTorch()
        {
            Gear torch = new Gear("Pine Torch", 0.8)
            {
                Description = "A branch wrapped with resin-soaked pine needles. Provides light and warmth.",
                Insulation = 5
            };
            return torch;
        }

        public static FoodItem MakeFish()
        {
            var item = new FoodItem("River Fish", 200, 0)
            {
                Description = "A freshly caught fish. Rich in nutrients and relatively easy to obtain near water.",
                Weight = 0.4
            };
            return item;
        }

        public static Item MakeVenomSac()
        {
            Item venom = new WeaponModifierItem("Venom Sac")
            {
                Description = "A fragile sac of venom extracted from a poisonous creature. Could coat a weapon.",
                Weight = 0.1,
                NumUses = 2,
                Damage = 2
            };
            return venom;
        }

        public static Item MakeSpiderSilk()
        {
            Item silk = new ArmorModifierItem("Spider Silk", [EquipSpots.Hands, EquipSpots.Feet, EquipSpots.Head])
            {
                Weight = 0.1,
                Description = "Fine, strong threads collected from giant spider webs. Useful for binding and insulation.",
                Warmth = 0.5
            };
            return silk;
        }

        public static Armor MakeFurHood()
        {
            Armor hood = new Armor("Fur Hood", .05, EquipSpots.Head, 3)
            {
                Description = "A hood made from animal fur. Keeps the head and ears warm in frigid weather.",
                Weight = 0.3
            };
            return hood;
        }

        public static Armor MakeLeatherTunic()
        {
            Armor tunic = new Armor("Leather Tunic", .10, EquipSpots.Chest, 4)
            {
                Description = "A simple tunic made from tanned animal hide. Basic protection from the elements.",
                Weight = 1.5
            };
            return tunic;
        }

        public static Armor MakeLeatherPants()
        {
            Armor leggings = new Armor("Leather Pants", .08, EquipSpots.Legs, 3)
            {
                Description = "Pants made from tanned animal hide. Protects the legs from brush and minor injuries.",
                Weight = 1.0
            };
            return leggings;
        }

        public static Armor MakeMoccasins()
        {
            Armor shoes = new Armor("Hide Moccasins", .03, EquipSpots.Feet, 2)
            {
                Description = "Soft footwear made from animal hide. More durable than bare feet on rough terrain.",
                Weight = 0.4
            };
            return shoes;
        }

        public static Item MakeMammothTusk()
        {
            Item tusk = new WeaponModifierItem("Mammoth Tusk")
            {
                Description = "A massive curved tusk from a woolly mammoth. Extremely valuable and rare.",
                Weight = 10.0,
                NumUses = 1,
                Damage = 5
            };
            return tusk;
        }

        public static Item MakeSaberToothFang()
        {
            Item fang = new WeaponModifierItem("Saber-Tooth Fang")
            {
                Description = "A long, curved fang from a saber-tooth tiger. Could be fashioned into a deadly weapon.",
                Weight = 0.3,
                NumUses = 1,
                Damage = 4
            };
            return fang;
        }

        public static Item MakeAntlerTine()
        {
            Item antler = new Item("Antler Tine")
            {
                Description = "A prong from a deer or elk antler. Useful for punching holes in hide or as a tool.",
                Weight = 0.2
            };
            return antler;
        }

        public static Item MakeSinew()
        {
            Item sinew = new Item("Animal Sinew")
            {
                Description = "Tough fibrous tissue from animal tendons. Essential for binding, sewing and bowstrings.",
                Weight = 0.1
            };
            return sinew;
        }

        public static Armor MakeBoneNecklace()
        {
            Armor necklace = new Armor("Bone Talisman", 0, EquipSpots.Chest, 0.5)
            {
                Description = "A primitive necklace made from small bones and stones. Said to bring good fortune.",
                Weight = 0.1
            };
            return necklace;
        }

        public static Item MakeObsidianShard()
        {
            Item obsidian = new Item("Obsidian Shard")
            {
                Description = "A piece of naturally occurring volcanic glass. Can be knapped into extremely sharp tools.",
                Weight = 0.2
            };
            return obsidian;
        }

        public static Item MakeOchrePigment()
        {
            Item ochre = new Item("Red Ochre")
            {
                Description = "Earthy clay pigment used for body decoration, cave paintings, and hide treatment.",
                Weight = 0.3
            };
            return ochre;
        }
    }
}================================================================================

File: ./obj/Debug/net8.0/text_survival.GlobalUsings.g.cs
--------------------------------------------------------------------------------
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
================================================================================

File: ./obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
--------------------------------------------------------------------------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
================================================================================

File: ./obj/Debug/net8.0/text_survival.AssemblyInfo.cs
--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("text_survival")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+10ff7f06763488668e2b4454b2e307839e34fe92")]
[assembly: System.Reflection.AssemblyProductAttribute("text_survival")]
[assembly: System.Reflection.AssemblyTitleAttribute("text_survival")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

================================================================================

File: ./Events/ThirstEvents.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

namespace text_survival.Events;


public class DehydrationEvent(Actor target, bool isNew) : IGameEvent
{
    public Actor Target = target;
    public bool IsNew = isNew;
}
public class DehydrationEventHandler : IEventHandler<DehydrationEvent>
{
    public void Handle(DehydrationEvent gameEvent)
    {
        if (gameEvent.IsNew)
        {
            Output.WriteDanger($"{gameEvent.Target.Name} is dehydrated!\n");
        }
        else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
        {
            Output.WriteWarning($"{gameEvent.Target.Name} is still dehydrated.\n");

        }
        var effect = EffectBuilderExtensions.CreateEffect("Dehydration")
        .CausesDehydration(1)
        .ReducesCapacity(CapacityNames.Consciousness, .2) // head ache
        .ReducesCapacity(CapacityNames.BloodPumping, .1) // low fluids
        .ReducesCapacity(CapacityNames.Digestion, .4) // low fluids
        .ReducesCapacity(CapacityNames.Moving, .05) // sluggish
        .ReducesCapacity(CapacityNames.Breathing, .1) // dry throat
        .Build();
        gameEvent.Target.ApplyEffect(effect);
    }
}

public class StoppedDehydrationEvent(Actor target) : IGameEvent
{
    public Actor Target = target;
}
public class StoppedDehydrationEventHandler : IEventHandler<StoppedDehydrationEvent>
{
    public void Handle(StoppedDehydrationEvent gameEvent)
    {
        Output.WriteSuccess($"{gameEvent.Target.Name} is no longer dehydrated!\n");
    }
}
================================================================================

File: ./Events/CalorieSurplusEvent.cs
--------------------------------------------------------------------------------

using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Events;

public class CalorieSurplusEvent(Body target, double calories) : IGameEvent
{
    public Body Target = target;
    public double Calories = calories;
}

public class CalorieSurplusEventHandler : IEventHandler<CalorieSurplusEvent>
{
    private const double CALORIES_PER_KG_FAT = 7700.0; // Standard calories stored in 1kg of fat

    public void Handle(CalorieSurplusEvent gameEvent)
    {

        double fatGain = gameEvent.Calories / CALORIES_PER_KG_FAT;

        gameEvent.Target.BodyFat += fatGain;

        int gFatGain = (int)(fatGain * 1000);
        Output.WriteLine($"{gameEvent.Target.OwnerName} gains {gFatGain}g of body fat from excess calories.");

    }

}
================================================================================

File: ./Events/ColdEvents.cs
--------------------------------------------------------------------------------

using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

namespace text_survival.Events;

public class BodyColdEvent(Body target, bool isNew) : IGameEvent
{
    public Body Target = target;
    public bool IsNew = isNew;

}

public class BodyColdEventHandler : IEventHandler<BodyColdEvent>
{
    private const double ShiveringThreshold = 97.0; // °F
    private const double HypothermiaThreshold = 95.0;  // °F
    private const double SevereHypothermiaThreshold = 89.6; // °F
    public void Handle(BodyColdEvent evt)
    {
        var target = evt.Target;
        var bodyTemperature = target.BodyTemperature;


        if (evt.IsNew)
        {
            Output.WriteDanger($"{target.OwnerName} is cold!\n");
        }
        else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
        {
            Output.WriteWarning($"{target.OwnerName} is still cold.\n");
        }

        if (bodyTemperature < ShiveringThreshold)
        {
            ApplyShivering(target);
        }
        else
        {
            // Remove shivering effects when temperature normalizes
            target.EffectRegistry.RemoveEffectsByKind("Shivering");
        }

        if (bodyTemperature < HypothermiaThreshold)
        {
            ApplyHypothermia(target);
        }

        if (bodyTemperature < SevereHypothermiaThreshold)
        {
            ApplyFrostbite(target);
        }
    }


    private void ApplyShivering(Body target)
    {
        // Calculate severity based on temperature
        double intensity = (ShiveringThreshold - target.BodyTemperature) / 5.0;
        intensity = Math.Clamp(intensity, 0.01, 1.0);

        // Apply to whole body (will handle stacking through EffectRegistry)
        var shiveringEffect = new ShiveringEffect(intensity);

        target.EffectRegistry.AddEffect(shiveringEffect);
    }


    private void ApplyHypothermia(Body target)
    {
        // Calculate severity based on temperature
        double severity = Math.Clamp((HypothermiaThreshold - target.BodyTemperature) / 10.0, 0.01, 1.0);

        string applicationMessage;
        string removalMessage;
        if (target.IsPlayer)
        {
            applicationMessage = $"Your core is getting very cold, you feel like you're starting to get hypothermia... Severity = {severity}";
            removalMessage = $"You're warming up enough and starting to feel better, the hypothermia has passed...";
        }
        else
        {
            applicationMessage = $"DEBUG: {target} has hypothermia. Severity = {severity}";
            removalMessage = $"DEBUG: {target} no longer has hypothermia.";
        }
        // Apply to whole body (will handle stacking through EffectRegistry)
        var hypothermia = EffectBuilderExtensions
            .CreateEffect("Hypothermia")
            .Temperature(TemperatureType.Hypothermia)
            .WithApplyMessage(applicationMessage)
            .WithSeverity(severity)
            .AllowMultiple(false)
            .WithRemoveMessage(removalMessage)
            .Build();

        target.EffectRegistry.AddEffect(hypothermia);

    }

    private void ApplyFrostbite(Body target)
    {
        // Get extremities (hands and feet)
        var extremities = target.Parts
            .Where(p => p.Name.Contains("Arm") || p.Name.Contains("Leg"))
            .ToList();

        foreach (var extremity in extremities)
        {
            // Calculate severity based on temperature
            double severity = Math.Clamp((SevereHypothermiaThreshold - target.BodyTemperature) / 5.0, 0.01, 1.0);

            string applicationMessage;
            string removalMessage;

            if (target.IsPlayer)
            {
                applicationMessage = $"Your {extremity.Name.ToLower()} is getting dangerously cold, you're developing frostbite! Severity = {severity}";
                removalMessage = $"The feeling is returning to your {extremity.Name.ToLower()}, the frostbite is healing...";
            }
            else
            {
                applicationMessage = $"DEBUG: {target} has frostbite on {extremity.Name}. Severity = {severity}";
                removalMessage = $"DEBUG: {target} no longer has frostbite on {extremity.Name}.";
            }

            // Apply frostbite to extremity using builder pattern
            var frostbite = EffectBuilderExtensions
                .CreateEffect("Frostbite")
                .Temperature(TemperatureType.Frostbite)
                .WithApplyMessage(applicationMessage)
                .WithSeverity(severity)
                .Targeting(extremity)
                .AllowMultiple(true) // Allow multiple frostbite effects on different extremities
                .WithRemoveMessage(removalMessage)
                .Build();

            target.EffectRegistry.AddEffect(frostbite);
        }
    }
}

================================================================================

File: ./Events/EventBus.cs
--------------------------------------------------------------------------------
namespace text_survival.Events;

public interface IGameEvent { }

public interface IEventHandler<T> where T : IGameEvent
{
    void Handle(T gameEvent);
}

public static class EventBus
{
    private static readonly Dictionary<Type, List<object>> _handlers = new();

    public static void Subscribe<T>(IEventHandler<T> handler) where T : IGameEvent
    {
        var eventType = typeof(T);
        if (!_handlers.TryGetValue(eventType, out List<object>? value))
        {
            value = [];
            _handlers[eventType] = value;
        }

        value.Add(handler);
    }

    public static void Publish<T>(T gameEvent) where T : IGameEvent
    {
        var eventType = typeof(T);
        if (_handlers.TryGetValue(eventType, out List<object>? eventHandlers))
        {
            eventHandlers.Cast<IEventHandler<T>>().ToList().ForEach(h => h.Handle(gameEvent));
        }
    }
}================================================================================

File: ./Events/StarvingEvent.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Events;

public class StarvingEvent(Body target, double calories, bool isNew) : IGameEvent
{
    public Body Target = target;
    public bool IsNew = isNew;
    public double Calories = calories;
}

public class StarvingEventHandler : IEventHandler<StarvingEvent>
{
    private const double CALORIES_PER_KG_MUSCLE = 5500.0; // Calories in 1kg of muscle (less than fat)
    private const double CALORIES_PER_KG_FAT = 7700.0;
    public void Handle(StarvingEvent gameEvent)
    {
        DisplayMessage(gameEvent);


        HandleBodyStarvation(gameEvent.Target, gameEvent.Calories);
        if (!ShouldApplyDamage(gameEvent.Target)) return; // has enough fat/muscle


        ApplyDamage(gameEvent.Target);
        // todo add more effects
    }

    // private methods //
    private static void DisplayMessage(StarvingEvent gameEvent)
    {
        if (gameEvent.IsNew)
        {
            Output.WriteDanger($"{gameEvent.Target.OwnerName} is starving!\n");
        }
        else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
        {
            Output.WriteWarning($"{gameEvent.Target.OwnerName} is still starving.\n");
        }
    }

    private static void HandleBodyStarvation(Body body, double calories)
    {
        if (body.BodyFat > 0)
        {
            // Convert fat to energy
            double fatBurnRate = calories / CALORIES_PER_KG_FAT;
            body.BodyFat -= fatBurnRate;
        }
        else if (body.Muscle > 0)
        {
            // Convert muscle to energy
            double muscleBurnRate = calories / CALORIES_PER_KG_MUSCLE * 1.2; // Muscle burns less efficiently
            body.Muscle -= muscleBurnRate;
        }
    }

    private static bool ShouldApplyDamage(Body body)
    {
        // apply damage if fat and muscle are dangerously low
        return body.BodyFatPercentage <= 0.05 && body.MusclePercentage <= 0.05;
    }

    private static void ApplyDamage(Body target)
    {
        var damage = new DamageInfo()
        {
            Amount = 1,
            Type = "starvation",
            IsPenetrating = true
        };
        target.Damage(damage);
    }
}

public class StoppedStarvingEvent(Body target) : IGameEvent
{
    public Body Target = target;
}
public class StoppedStarvingEventHandler : IEventHandler<StoppedStarvingEvent>
{
    public void Handle(StoppedStarvingEvent gameEvent)
    {
        Output.WriteSuccess($"{gameEvent.Target.OwnerName} is no longer starving!\n");
    }
}================================================================================

File: ./Events/HeatEvents.cs
--------------------------------------------------------------------------------
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

namespace text_survival.Events;

public class BodyHotEvent(Body target, bool isNew) : IGameEvent
{
    public Body Target = target;
    public bool IsNew = isNew;
}


public class BodyHotEventHandler : IEventHandler<BodyHotEvent>
{
    private const double SweatingThreshold = 100.0; // °F
    private const double HyperthermiaThreshold = 99.5; // °F  
    public void Handle(BodyHotEvent evt)
    {
        var target = evt.Target;
        var bodyTemperature = target.BodyTemperature;


        if (evt.IsNew)
        {
            Output.WriteDanger($"{target.OwnerName} is hot!\n");
        }
        else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
        {
            Output.WriteWarning($"{target.OwnerName} is still hot.\n");
        }

        if (bodyTemperature > SweatingThreshold)
        {
            ApplySweating(target); // naturally resolves if not refreshed in 30 min
        }

        if (bodyTemperature > HyperthermiaThreshold)
        {
            ApplyHyperthermia(target);
        }
    }

    private void ApplyHyperthermia(Body target)
    {
        // Calculate severity based on temperature
        double severity = Math.Clamp((target.BodyTemperature - HyperthermiaThreshold) / 10.0, 0.01, 1.00);

        // Apply to whole body (will handle stacking through EffectRegistry)
        var hyperthermia = new TemperatureInjury(
            TemperatureInjury.TemperatureInjuryType.Hyperthermia,
            "Heat exposure",
            null,
            severity);

        target.EffectRegistry.AddEffect(hyperthermia);
    }

    private void ApplySweating(Body target)
    {
        // Calculate severity based on temperature
        double severity = Math.Clamp((target.BodyTemperature - SweatingThreshold) / 4.0, 0.10, 1.00);

        // Apply to whole body (will handle stacking through EffectRegistry)
        var sweatingEffect = new SweatingEffect(severity);

        target.EffectRegistry.AddEffect(sweatingEffect);
    }

}================================================================================

File: ./Events/ExhaustionEvents.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Events;
public class ExhaustionEvent(Actor target, bool isNew) : IGameEvent
{
    public Actor Target = target;
    public bool IsNew = isNew;
}
public class ExhaustionEventHandler : IEventHandler<ExhaustionEvent>
{
    public void Handle(ExhaustionEvent gameEvent)
    {
        if (gameEvent.IsNew)
        {
            Output.WriteDanger($"{gameEvent.Target.Name} is exhausted!\n");
        }
        else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
        {
            Output.WriteWarning($"{gameEvent.Target.Name} is still exhausted.\n");
        }
        var target = gameEvent.Target;
        var damage = new DamageInfo()
        {
            Amount = 1,
            Type = "exhaustion",
            IsPenetrating = true
        };
        target.Damage(damage);
    }
}

public class StoppedExhaustionEvent(Actor target) : IGameEvent
{
    public Actor Target = target;
}
public class StoppedExhaustionEventHandler : IEventHandler<StoppedExhaustionEvent>
{
    public void Handle(StoppedExhaustionEvent gameEvent)
    {
        Output.WriteSuccess($"{gameEvent.Target.Name} is no longer exhausted!\n");
    }
}================================================================================

File: ./Level/Skill.cs
--------------------------------------------------------------------------------
﻿

using text_survival.IO;

namespace text_survival.Level
{
    public class Skill
    {
        public int Xp;
        public int Level { get; private set; }
        public string Name { get; set; }
        public int LevelUpThreshold => (Level) * 10;

        public Skill(string name)
        {
            Name = name;
            Xp = 0;
            Level = 0;
        }
        public void GainExperience(int xp)
        {
            Xp += xp;

            if (Xp < LevelUpThreshold) return;
            // else level up
            Xp -= LevelUpThreshold;
            LevelUp();
        }

        public void LevelUp()
        {
            Level++;
            Output.WriteLine("You leveled up ", this, " to level ", Level, "!");
        }

        public override string ToString() => Name;

        public void Describe()
        {
            Output.Write(this, ": ", Level, " (", Xp, "/", LevelUpThreshold, ")");
        }

    }
}
================================================================================

File: ./Level/SkillRegistry.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Level
{
    public class SkillRegistry
    {
        public Skill Fighting { get; private set; }
        public Skill Endurance { get; private set; }
        public Skill Reflexes { get; private set; }
        public Skill Defense { get; private set; }
        public Skill Hunting { get; private set; }
        public Skill Toolmaking { get; private set; }
        public Skill Foraging { get; private set; }
        public Skill Firecraft { get; private set; }
        public Skill Mending { get; private set; }
        public Skill Healing { get; private set; }
        public Skill Magic { get; private set; }

        public SkillRegistry()
        {
            Fighting = new Skill("Fighting");
            Endurance = new Skill("Endurance");
            Reflexes = new Skill("Reflexes");
            Defense = new Skill("Defense");
            Hunting = new Skill("Hunting");
            Toolmaking = new Skill("Toolmaking");
            Foraging = new Skill("Foraging");
            Firecraft = new Skill("Firecraft");
            Mending = new Skill("Mending");
            Healing = new Skill("Healing");
            Magic = new Skill("Shamanism");
        }

        public void Describe()
        {
            Output.WriteLine("\nSkills:");

            var allSkills = new[] { Fighting, Endurance, Reflexes, Defense, Hunting, Toolmaking, Foraging, Firecraft, Mending, Healing, Magic };

            foreach (var skill in allSkills)
            {
                if (skill.Level > 0)
                {
                    Output.WriteLine($"{skill.Name}: {skill.Level} ({skill.Xp}/{skill.LevelUpThreshold})");
                }
            }
        }

        public Skill GetSkill(string skillName)
        {
            return skillName switch
            {
                "Fighting" => Fighting,
                "Endurance" => Endurance,
                "Reflexes" => Reflexes,
                "Defense" => Defense,
                "Hunting" => Hunting,
                "Toolmaking" => Toolmaking,
                "Foraging" => Foraging,
                "Firecraft" => Firecraft,
                "Mending" => Mending,
                "Healing" => Healing,
                "Magic" => Magic,
                _ => throw new ArgumentException($"Skill {skillName} does not exist.")
            };
        }
    }
}================================================================================

File: ./Actions/ActionFactory.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Magic;

namespace text_survival.Actions;

public static class ActionFactory
{
    private static ActionBuilder CreateAction(string name) => ActionBuilderExtensions.CreateAction(name);
    public static class Common
    {
        public static IGameAction Return(string name = "Back")
        {
            return CreateAction(name).ThenReturn().Build();
        }
        public static IGameAction BackTo(string description, Func<IGameAction> actionFactory)
        {

            return CreateAction($"Back to {description}")
                    .ThenShow(ctx => [actionFactory()])
                    .Build();
        }

        public static IGameAction MainMenu()
        {
            return CreateAction("Main Menu")
                   .Do(ctx => ctx.player.DescribeSurvivalStats())
                   .ThenShow(ctx => [
                        Describe.LookAround(ctx.currentLocation),
                        Survival.Forage(),
                        Inventory.OpenInventory(),
                        Describe.CheckStats(),
                        Survival.Sleep(),
                        Movement.Move(),
                   ])
                   .Build();
        }
    }

    public static class Survival
    {
        public static IGameAction Forage(string name = "Forage")
        {
            return CreateAction("Forage")
                .When(ctx => ctx.currentLocation.GetFeature<ForageFeature>() != null)
                .ShowMessage("You forage for 1 hour")
                .Do(ctx =>
                {
                    var forageFeature = ctx.currentLocation.GetFeature<ForageFeature>()!;
                    forageFeature.Forage(1);
                })
                .AndGainExperience("Foraging")
                .ThenShow(_ => [Forage("Keep foraging"), Common.Return("Finish foraging")])
                .Build();
        }

        public static IGameAction Sleep()
        {
            return CreateAction("Sleep")
            .When(ctx => ctx.player.Body.IsTired)
            .Do(ctx =>
            {
                Output.WriteLine("How many hours would you like to sleep?");
                ctx.player.Sleep(Input.ReadInt() * 60);
            })
            .ThenReturn()
            .Build();
        }
    }

    public static class Movement
    {
        public static IGameAction GoToLocation(Location location)
        {
            return CreateAction($"Go to {location.Name}{(location.Visited ? " (Visited)" : "")}")
            .When(_ => location.IsFound)
            .Do(ctx => location.Interact(ctx.player))
            .ThenReturn()
            .Build();
        }

        public static IGameAction Travel()
        {
            return CreateAction("Travel to a different area")
            .When(ctx => ctx.currentLocation.GetFeature<ShelterFeature>() == null) // when not inside a shelter
            .Do(ctx => ctx.player.Travel()) // todo move out of player class
            .ThenReturn()
            .Build();
        }

        public static IGameAction Move()
        {
            return CreateAction("Go somewhere else")
            .When(ctx => ctx.player.Body.CalculateVitality() > .2)
            .Do(ctx => // just determine what text to display
            {
                var locations = ctx.currentLocation.GetNearbyLocations().Where(l => l.IsFound).ToList();
                bool inside = ctx.player.CurrentLocation.GetFeature<ShelterFeature>() != null;
                if (inside)
                {
                    Output.WriteLine($"You can leave the shelter and go outside.");
                }
                if (locations.Count == 0)
                {
                    Output.WriteLine("You don't see anywhere noteworthy nearby; you can stay here or travel to a new area.");
                    return;
                }
                else if (locations.Count == 1)
                {
                    Output.WriteLine($"You can go to the {locations[0].Name} or pack up and leave the region.");
                }
                else
                {
                    Output.WriteLine("You see several places that you can go to from here, or you can pack up and leave the region.");
                }
            })
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>();
                foreach (var location in ctx.currentLocation.GetNearbyLocations())
                {
                    options.Add(GoToLocation(location));
                }
                options.Add(Travel());
                options.Add(Common.Return("Stay Here..."));
                return options;
            })
            .Build();
        }
    }

    public static class Inventory
    {
        public static IGameAction DescribeItem(Item item)
        {
            return CreateAction($"Inspect {item}")
            .Do(_ => item.Describe())
            .ThenShow(_ => [OpenInventory()])
            .Build();
        }

        public static IGameAction DropItem(Item item)
        {
            return CreateAction($"Inspect {item}")
            .ShowMessage($"You drop the {item}")
            .Do(ctx => ctx.player.DropItem(item))
            .ThenShow(_ => [OpenInventory()])
            .Build();
        }

        public static IGameAction UseItem(Item item)
        {
            return CreateAction($"Use {item}")
            .Do(ctx => ctx.player.UseItem(item))
            .ThenShow(_ => [OpenInventory()])
            .Build();
        }

        public static IGameAction OpenInventory()
        {
            return CreateAction($"Open inventory")
            .OnlyIfHasItems()
            .Do(ctx => ctx.player.inventoryManager.Describe())
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>();
                foreach (ItemStack stack in ctx.player.inventoryManager.Items)
                {
                    options.Add(DecideInventoryAction(stack));
                }
                options.Add(Common.Return("Close Inventory"));
                return options;
            })
            .WithPrompt("Select an item:")
            .Build();
        }

        public static IGameAction OpenContainer(Container container)
        {
            return CreateAction($"Look in {container}{(container.IsEmpty ? " (Empty)" : "")}")
            .When(ctx => container.IsFound && !container.IsEmpty)
            .OnlyIfCanBypassHostiles()
            .ShowMessage($"You open the {container}")
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>();
                var itemStacks = ItemStack.CreateStacksFromItems(container.Items);
                foreach (var stack in itemStacks)
                {
                    options.Add(TakeStackFromContainer(container, stack));
                }
                options.Add(TakeAllFromContainer(container));
                options.Add(Common.Return($"Close {container.Name}"));
                return options;
            })
            .WithPrompt("Select an item:")
            .Build();
        }

        public static IGameAction TryToReachContainer(Container container)
        {
            return CreateAction($"Try to reach {container.Name}")
                 .When(ctx => container.IsFound &&
                            !container.IsEmpty)
                 .OnlyIfBlockedByHostiles()
                 .Do(ctx => Output.WriteLine("You couldn't get past the ", CombatUtils.GetFastestHostileNpc(ctx.currentLocation)!, "!"))
                 .ThenShow(ctx => [Combat.StartCombat(CombatUtils.GetFastestHostileNpc(ctx.currentLocation)!)])
                 .Build();
        }

        public static IGameAction DecideInventoryAction(ItemStack stack)
        {
            Item item = stack.Peek();
            return CreateAction(stack.DisplayName)
            .ThenShow(_ => [UseItem(item),
                            DescribeItem(item),
                            DropItem(item),
                            Common.BackTo("inventory", OpenInventory)]
                            )
            .WithPrompt($"What would you like to do with the {item.Name}")
            .Build();
        }

        public static IGameAction TakeAllFromContainer(Container container)
        {
            return CreateAction("Take all")
            .When(_ => container.Count() > 1)
            .Do(ctx =>
            {
                while (!container.IsEmpty)
                {
                    var item = container.Items.First();
                    container.Remove(item);
                    ctx.player.TakeItem(item);
                }
            })
            .ThenReturn()
            .Build();
        }


        public static IGameAction TakeStackFromContainer(Container container, ItemStack stack)
        {
            return CreateAction($"Take {stack.DisplayName}")
            .Do(ctx =>
            {
                while (stack.Count > 0)
                {
                    var item = stack.Pop();
                    container.Remove(item);
                    ctx.player.TakeItem(item);
                }
            })
            .ThenShow(_ => [OpenContainer(container)]) // will be auto selected until the container is empty then it will auto return
            .Build();
        }

        public static IGameAction PickUpItem(Item item)
        {
            return CreateAction($"Pick up {item.Name}")
            .When(_ => item.IsFound)
            .OnlyIfCanBypassHostiles()
            .ShowMessage($"You take the {item}")
            .Do(ctx => ctx.player.TakeItem(item))
            .ThenLookAround()
            .Build();
        }

        public static IGameAction LootNpc(Npc npc)
        {
            return CreateAction($"Loot {npc.Name}")
            .When(_ => npc.IsFound)
            .When(_ => !npc.IsAlive)
            .When(_ => !npc.Loot.IsEmpty)
            .OnlyIfCanBypassHostiles()
            .ThenShow(_ => [OpenContainer(npc.Loot)])
            .Build();
        }

    }

    public static class Combat
    {

        public static IGameAction StartCombat(Npc enemy)
        {
            return CreateAction($"Fight {enemy.Name}")
            .When(ctx => enemy.IsAlive && enemy.IsFound)
            .Do(ctx =>
            {
                Output.WriteLine("!");
                Thread.Sleep(500);
                Output.WriteLine(CombatNarrator.DescribeCombatStart(ctx.player, enemy));

                ctx.player.IsEngaged = true;
                enemy.IsEngaged = true;
                ctx.EngagedEnemy = enemy;

                // First strike determination
                bool enemyFirstStrike = enemy.Body.CalculateSpeed() > ctx.player.Body.CalculateSpeed();

                if (enemyFirstStrike)
                {
                    Output.WriteLine($"The {enemy.Name} moves with surprising speed!");
                    Thread.Sleep(500);
                    ctx.NextActionOverride = EnemyCombatTurn(enemy);
                    return;
                }
                else
                {
                    Output.WriteLine("You're quick to react, giving you the initiative!");
                    Thread.Sleep(500);
                }
            })
            .ThenShow(_ => [PlayerCombatTurn(enemy)])
            .Build();
        }

        public static IGameAction AttackEnemy(Npc enemy)
        {
            return CreateAction($"Attack {enemy.Name}")
            .Do(ctx => ctx.player.Attack(enemy))
            .ThenShow(ctx => [EnemyCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }


        public static IGameAction TargetedAttackEnemy(Npc enemy)
        {
            return CreateAction($"Targeted Attack {enemy.Name}")
            .When(ctx => ctx.player.Skills.Fighting.Level > 1)
            .Do(ctx =>
            {
                int fightingSkill = ctx.player.Skills.Fighting.Level;
                var targetPart = SelectTargetPart(enemy, fightingSkill);
                if (targetPart != null)
                {
                    ctx.player.Attack(enemy, targetPart);
                }
                else
                {
                    ctx.NextActionOverride = PlayerCombatTurn(enemy);
                }
            })
            .ThenShow(ctx => [EnemyCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }
        private static IBodyPart? SelectTargetPart(Actor enemy, int depth)
        {
            if (depth <= 0)
            {
                Output.WriteWarning("You don't have enough skill to target an attack");
                return null;
            }
            Output.WriteLine($"Where do you want to target your attack on the {enemy.Name}?");

            List<IBodyPart> allParts = [];

            foreach (var part in enemy.Body.Parts)
            {
                if (depth > 0)
                    allParts.Add(part);
                if (depth > 1)
                    allParts.Add(part.Skin);
                if (depth > 2)
                    allParts.Add(part.Muscle);
                if (depth > 3)
                    allParts.Add(part.Bone);
                if (depth > 4)
                    allParts.AddRange(part.Organs);
            }

            IBodyPart? choice = Input.GetSelectionFromList(allParts, true);
            if (choice == null)
                return null;

            // todo return part itself
            return choice;
        }

        public static IGameAction EndCombat(Npc enemy)
        {
            return CreateAction("End Combat")
            .When(ctx => !enemy.IsEngaged || !ctx.player.IsEngaged || !ctx.player.IsAlive || !enemy.IsAlive)
            .Do(ctx =>
            {
                ctx.player.IsEngaged = false;
                enemy.IsEngaged = false;

                // Combat end
                if (!ctx.player.IsAlive)
                {
                    Output.WriteDanger("Your vision fades to black as you collapse... You have died!");
                    Environment.Exit(0);
                }
                else if (!enemy.IsAlive)
                {
                    string[] victoryMessages = [
                    $"The {enemy.Name} collapses, defeated!",
                    $"You stand victorious over the fallen {enemy.Name}!",
                    $"With a final blow, you bring down the {enemy.Name}!"
                ];
                    Output.WriteLine(victoryMessages[Utils.RandInt(0, victoryMessages.Length - 1)]);

                    // Calculate experience based on enemy difficulty
                    int xpGain = CalculateExperienceGain(enemy);
                    Output.WriteLine($"You've gained {xpGain} fighting experience!");
                    ctx.player.Skills.Fighting.GainExperience(xpGain);
                }
            })
            .ThenReturn()
            .Build();
        }
        private static int CalculateExperienceGain(Npc enemy)
        {
            int baseXP = 5;

            // Adjust based on enemy weight/size
            double sizeMultiplier = Math.Clamp(enemy.Body.Weight / 50, 0.5, 3.0);

            // Adjust based on enemy weapon damage
            double weaponMultiplier = Math.Clamp(enemy.ActiveWeapon.Damage / 8, 0.5, 2.0);

            return (int)(baseXP * sizeMultiplier * weaponMultiplier);
        }

        public static IGameAction Flee(Npc enemy)
        {
            return CreateAction("Flee")
            .When(ctx => ctx.player.Body.CalculateSpeed() > .25)
            .Do(ctx =>
            {
                if (CombatUtils.SpeedCheck(ctx.player, enemy))
                {
                    Output.WriteLine("You got away!");
                    enemy.IsEngaged = false;
                    ctx.player.IsEngaged = false;
                    ctx.player.Skills.Reflexes.GainExperience(2);
                }
                else
                {
                    Output.WriteLine("You weren't fast enough to get away from ", enemy, "!");
                    ctx.player.Skills.Reflexes.GainExperience(1);
                }
            })
            .ThenShow(_ => [EnemyCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }
        public static IGameAction EnemyCombatTurn(Npc enemy)
        {
            return CreateAction("Enemy Turn")
            .When(ctx => ctx.player.IsAlive && enemy.IsAlive && enemy.IsEngaged)
            .Do(ctx =>
            {
                Thread.Sleep(500); // Pause before enemy attack
                enemy.Attack(ctx.player);
            })
            .ThenShow(ctx => [PlayerCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }

        public static IGameAction PlayerCombatTurn(Npc enemy)
        {
            return CreateAction("Player Turn")
            .When(ctx => ctx.player.IsAlive && enemy.IsAlive && ctx.player.IsEngaged)
            .Do(ctx =>
            {
                Output.WriteLine("─────────────────────────────────────");
                DisplayCombatStatus(ctx.player, enemy);
            })
            .ThenShow(ctx => [AttackEnemy(enemy), TargetedAttackEnemy(enemy), Magic.SelectSpell(enemy), Flee(enemy)])
            .Build();
        }

        private static void DisplayCombatStatus(Player player, Actor enemy)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            // Player status
            Console.ForegroundColor = GetHealthColor(player.Body.Health / player.Body.MaxHealth);
            Output.WriteLine($"You: {Math.Round(player.Body.Health, 0)}/{Math.Round(player.Body.MaxHealth, 0)} HP");
            // Enemy status
            Console.ForegroundColor = GetHealthColor(enemy.Body.Health / enemy.Body.MaxHealth);
            Output.WriteLine($"{enemy.Name}: {Math.Round(enemy.Body.Health, 0)}/{Math.Round(enemy.Body.MaxHealth, 0)} HP");
            Console.ForegroundColor = oldColor;
        }

        private static ConsoleColor GetHealthColor(double healthPercentage)
        {
            if (healthPercentage < 0.2) return ConsoleColor.Red;
            if (healthPercentage < 0.5) return ConsoleColor.Yellow;
            return ConsoleColor.Green;
        }
    }


    public static class Magic
    {
        public static IGameAction SelectSpell(Npc enemy)
        {
            return CreateAction("Cast Spell")
            .When(ctx => ctx.player._spells.Count > 0)
            .ThenShow(ctx =>
            {
                List<IGameAction> options = [];
                foreach (Spell spell in ctx.player._spells)
                {
                    options.Add(SelectSpellTarget(spell, enemy));
                }
                var back = Combat.PlayerCombatTurn(enemy);
                back.Name = "Choose a different action.";
                options.Add(back);
                return options;
            })
            .WithPrompt("Which spell would you like to cast?")
            .Build();
        }

        public static IGameAction SelectSpellTarget(Spell spell, Npc enemy)
        {
            return CreateAction($"Cast {spell}")
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>
                {
                CastSpellAtTarget(spell, enemy, ctx.player),
                CastSpellAtTarget(spell, enemy, enemy)
                };

                if (ctx.player.Skills.Magic?.Level > 1)
                {
                    options.Add(TargetedCastSpellAtTarget(spell, enemy, ctx.player));
                    options.Add(TargetedCastSpellAtTarget(spell, enemy, enemy));
                }

                return options;
            })
            .WithPrompt($"Which target would you like to cast {spell} on?")
            .Build();
        }

        public static IGameAction CastSpellAtTarget(Spell spell, Npc enemy, Actor target)
        {
            return CreateAction($"Cast {spell} on {target}")
            .Do(ctx => spell.Cast(target))
            .ThenShow(ctx => [Combat.EnemyCombatTurn(enemy), Combat.EndCombat(enemy)])
            .Build();
        }

        public static IGameAction TargetedCastSpellAtTarget(Spell spell, Npc enemy, Actor target)
        {
            return CreateAction($"Targeted Cast {spell} on {target}")
            .When(ctx => ctx.player.Skills.Magic.Level > 1)
            .Do(ctx =>
            {
                int magicSkill = ctx.player.Skills.Magic.Level;
                MajorBodyPart? targetPart = SelectSpellTargetPart(target, magicSkill);
                if (targetPart != null)
                {
                    spell.Cast(target, targetPart);
                }
                else
                {
                    ctx.NextActionOverride = Combat.PlayerCombatTurn(enemy);
                }
            })
            .ThenShow(ctx => [Combat.EnemyCombatTurn(enemy), Combat.EndCombat(enemy)])
            .Build();
        }

        // private static MajorBodyPart? SelectSpellTargetPart(Actor target, int depth)
        // {
        //     if (depth <= 0)
        //     {
        //         Output.WriteWarning("You don't have enough magical skill to target a specific body part");
        //         return null;
        //     }

        //     Output.WriteLine($"Select a part to target on the {target.Name}:");
        //     var parts = target.Body.GetPartsToNDepth(depth);
        //     return Input.GetSelectionFromList(parts, true);
        // }
    }


    public class Describe
    {
        public static IGameAction LookAround(Location location)
        {
            return CreateAction($"Look around {location.Name}")
            .Do(ctx =>
            {
                Output.WriteLine("You look around the ", location);
                Output.WriteLine("You are in a ", location, " in a ", location.Parent);
                Output.WriteLine("Its ", World.GetTimeOfDay(), " and ", location.GetTemperature(), " degrees.");
                Output.WriteLine("You see:");
                foreach (var thing in location.Items)
                {
                    Output.WriteLine(thing);
                    thing.IsFound = true;
                }
                foreach (var thing in location.Containers)
                {
                    Output.WriteLine(thing);
                    thing.IsFound = true;
                }
                foreach (var thing in location.Npcs)
                {
                    Output.WriteLine(thing);
                    thing.IsFound = true;
                }

                var nearbyLocations = location.GetNearbyLocations();
                if (nearbyLocations.Count == 0)
                    return;
                Output.WriteLine("Nearby, you see some other places: ");
                foreach (var location in nearbyLocations)
                {
                    Output.WriteLine(location);
                    location.IsFound = true;
                }
            })
            .ThenShow(ctx =>
            {
                var actions = new List<IGameAction>();
                foreach (Npc npc in location.Npcs)
                {
                    actions.Add(Combat.StartCombat(npc));
                    actions.Add(Inventory.LootNpc(npc));
                }
                foreach (Item item in location.Items)
                {
                    actions.Add(Inventory.PickUpItem(item));
                }
                foreach (var container in location.Containers)
                {
                    actions.Add(Inventory.OpenContainer(container));
                    actions.Add(Inventory.TryToReachContainer(container));
                }
                actions.Add(Common.Return());
                return actions;
            })
            .WaitForUserInputToContinue()
            .Build();
        }

        public static IGameAction CheckStats()
        {
            return CreateAction("Check Stats")
            .Do(ctx =>
            {
                ctx.player.Body.Describe();
                ctx.player.Skills.Describe();
            })
            .WaitForUserInputToContinue()
            .Build();
        }
    }


}================================================================================

File: ./Actions/DynamicAction.cs
--------------------------------------------------------------------------------
namespace text_survival.Actions;

public class DynamicAction(
    string name,
    Func<GameContext, bool>? isAvailable,
    Action<GameContext>? onExecute,
    Func<GameContext, List<IGameAction>>? getNextActions,
    string? userPrompt
) : GameActionBase(name)
{
    private readonly Func<GameContext, bool>? _isAvailable = isAvailable;
    private readonly Action<GameContext>? _onExecute = onExecute;
    private readonly Func<GameContext, List<IGameAction>>? _getNextActions = getNextActions;
    private readonly string? _userPrompt = userPrompt;

    public override bool IsAvailable(GameContext ctx)
    {
        return _isAvailable?.Invoke(ctx) ?? true;
    }

    protected override void OnExecute(GameContext ctx)
    {
        _onExecute?.Invoke(ctx);
    }

    protected override List<IGameAction> GetNextActions(GameContext ctx)
    {
        return _getNextActions?.Invoke(ctx) ?? [];
    }
    protected override string userPrompt => _userPrompt ?? base.userPrompt;
}================================================================================

File: ./Actions/ActionBuilder.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Actions;

public class ActionBuilder
{
    private string _name = "";
    private readonly List<Func<GameContext, bool>> _isAvailableRequirements = [];
    private readonly List<Action<GameContext>> _onExecuteActions = [];
    private Func<GameContext, List<IGameAction>>? _getNextActions;
    private string? _userPrompt;

    public ActionBuilder Named(string name)
    {
        _name = name;
        return this;
    }

    public ActionBuilder When(Func<GameContext, bool> condition)
    {
        _isAvailableRequirements.Add(condition);
        return this;
    }

    public ActionBuilder Do(Action<GameContext> action)
    {
        _onExecuteActions.Add(action);
        return this;
    }

    public ActionBuilder ThenShow(Func<GameContext, List<IGameAction>> nextActions)
    {
        _getNextActions = nextActions;
        return this;
    }

    public ActionBuilder ThenReturn()
    {
        _getNextActions = _ => [];
        return this;
    }

    public ActionBuilder WithPrompt(string prompt)
    {
        _userPrompt = prompt;
        return this;
    }

    public IGameAction Build()
    {
        if (string.IsNullOrWhiteSpace(_name))
        {
            throw new InvalidOperationException("Action name is required");
        }

        Action<GameContext>? combinedAction = null;
        if (_onExecuteActions.Count > 0)
        {
            combinedAction = ctx => _onExecuteActions.ForEach(x => x(ctx));
        }

        // combines all conditional requirements with AND. i.e returns true iff all are true
        Func<GameContext, bool>? combinedRequirements = null;
        if (_isAvailableRequirements.Count > 0)
        {
            combinedRequirements = ctx => _isAvailableRequirements.All(x => x(ctx));
        }

        return new DynamicAction(
            name: _name,
            isAvailable: combinedRequirements,
            onExecute: combinedAction,
            getNextActions: _getNextActions,
            userPrompt: _userPrompt
        );
    }
}

public static class ActionBuilderExtensions
{
    public static ActionBuilder CreateAction(string name) => new ActionBuilder().Named(name);

    public static ActionBuilder OnlyIfHasItems(this ActionBuilder b)
    {
        return b.When(ctx => ctx.player.inventoryManager.Items.Count > 0);
    }

    public static ActionBuilder ShowMessage(this ActionBuilder b, string message)
    {
        return b.Do(_ => Output.WriteLine(message));
    }

    public static ActionBuilder ThenOpenInventory(this ActionBuilder b)
    {
        return b.ThenShow(ctx => [ActionFactory.Inventory.OpenInventory()]);
    }

    public static ActionBuilder ThenLookAround(this ActionBuilder b)
    {
        return b.ThenShow(ctx => [ActionFactory.Describe.LookAround(ctx.currentLocation)]);
    }

    public static ActionBuilder AndGainExperience(this ActionBuilder b, string skillName, int xp = 1)
    {
        return b.Do(ctx => ctx.player.Skills.GetSkill(skillName).GainExperience(xp));
    }

    public static ActionBuilder TakesMinutes(this ActionBuilder b, int minutes)
    {
        return b.Do(ctx => World.Update(minutes));
    }

    public static ActionBuilder OnlyIfCanBypassHostiles(this ActionBuilder b)
    {
        return b.When(ctx =>
        {
            Npc? npc = CombatUtils.GetFastestHostileNpc(ctx.currentLocation);
            return npc == null || CombatUtils.SpeedCheck(ctx.player, npc);
        });
    }
    public static ActionBuilder OnlyIfBlockedByHostiles(this ActionBuilder b)
    {
        return b.When(ctx =>
        {
            Npc? npc = CombatUtils.GetFastestHostileNpc(ctx.currentLocation);
            return npc != null && !CombatUtils.SpeedCheck(ctx.player, npc);
        });
    }

    public static ActionBuilder WaitForUserInputToContinue(this ActionBuilder b)
    {
        return b.Do(_ =>
        {
            Output.WriteLine("Press any key to continue...");
            Console.ReadKey(true);
        });
    }
}================================================================================

File: ./Actions/Action.cs
--------------------------------------------------------------------------------
using text_survival.IO;
namespace text_survival.Actions;

public interface IGameAction
{
    public string Name { get; set; }
    public void Execute(GameContext ctx);
    public bool IsAvailable(GameContext ctx);
}

public abstract class GameActionBase(string name) : IGameAction
{
    public virtual string Name { get; set; } = name;
    public virtual bool IsAvailable(GameContext ctx) => true;
    public void Execute(GameContext ctx)
    {
        OnExecute(ctx);
        World.Update(1);
        SelectNextAction(ctx);
    }

    protected abstract void OnExecute(GameContext ctx);
    protected abstract List<IGameAction> GetNextActions(GameContext ctx);

    private void SelectNextAction(GameContext ctx)
    {
        if (ctx.NextActionOverride != null)
        {
            ctx.NextActionOverride.Execute(ctx);
            ctx.NextActionOverride = null;
            return;
        }

        var actions = GetNextActions(ctx).Where(a => a.IsAvailable(ctx)).ToList();
        if (actions.Count == 0)
        {
            return; // back to main game loop   
        }
        else if (actions.Count == 1)
        {
            actions[0].Execute(ctx);
            return;
        }
        Output.WriteLine("\n" + userPrompt);
        IGameAction action = Input.GetSelectionFromList(actions)!;
        action.Execute(ctx);
    }
    protected virtual string userPrompt => "What would you like to do?";
    public override string ToString() => Name;
}

================================================================================

File: ./Actions/GameContext.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Environments;

namespace text_survival.Actions;

public class GameContext(Player player)
{
    public Player player = player;
    public Location currentLocation => player.CurrentLocation;
    public IGameAction? NextActionOverride { get; set; }
    public Npc? EngagedEnemy;
}
================================================================================

File: ./PlayerComponents/LocationManger.cs
--------------------------------------------------------------------------------
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

class LocationManager
{
    public LocationManager(Location startingLocation)
    {
        Map = new WorldMap(startingLocation.Parent);
        _currentLocation = startingLocation;
    }
    private WorldMap Map { get; }
    public Location CurrentLocation
    {
        get
        {
            return _currentLocation;
        }
        set
        {
            Output.WriteLine("You go to the ", value);
            int minutes = Utils.RandInt(1, 10);
            World.Update(minutes);
            Output.WriteLine("You arrive at the ", value, " after walking ", minutes, " minutes.");
            _currentLocation = value;
            _currentLocation.Visited = true;
            Output.WriteLine("You should probably look around.");
        }
    }
    private Location _currentLocation;

    public Zone CurrentZone
    {
        get
        {
            return Map.CurrentZone;
        }
        set
        {
            if (Map.North == value)
            {
                Output.WriteLine("You go north.");
                Map.MoveNorth();
            }
            else if (Map.East == value)
            {
                Output.WriteLine("You go east.");
                Map.MoveEast();
            }
            else if (Map.South == value)
            {
                Output.WriteLine("You go south.");
                Map.MoveSouth();
            }
            else if (Map.West == value)
            {
                Output.WriteLine("You go west.");
                Map.MoveWest();
            }
            else
                throw new Exception("Invalid zone!");
            Location? newLocation = Utils.GetRandomFromList(value.Locations);

            CurrentLocation = newLocation ?? throw new Exception("No Locations In Zone");
            Output.WriteLine("You enter ", value);
            Output.WriteLine(value.Description);
        }
    }

    public bool RemoveItemFromLocation(Item item)
    {
        if (_currentLocation.Items.Contains(item))
        {
            _currentLocation.Items.Remove(item);
            return true;
        }
        else
        {
            Container? container = _currentLocation.Containers.FirstOrDefault(x => x.Items.Contains(item));
            if (container != null)
            {
                container.Remove(item);
                return true;
            }
        }
        return false;
    }

    public void AddItemToLocation(Item item)
    {
        _currentLocation.Items.Add(item);
    }

    public void TravelToAdjacentZone()
    {
        Output.WriteLine("Where would you like to go?");

        Output.WriteLine(1, ". North: ", (Map.North.Visited ? Map.North.Name : " Unknown"));
        Output.WriteLine(2, ". East: ", (Map.East.Visited ? Map.East.Name : " Unknown"));
        Output.WriteLine(3, ". South: ", (Map.South.Visited ? Map.South.Name : " Unknown"));
        Output.WriteLine(4, ". West: ", (Map.West.Visited ? Map.West.Name : " Unknown"));

        Output.WriteLine("0. Cancel");
        int input = Input.ReadInt(0, 4);

        if (input == 0) return;

        int minutes = Utils.RandInt(30, 60);
        Output.WriteLine("You travel for ", minutes, " minutes...");

        switch (input)
        {
            case 1:
                CurrentZone = Map.North;
                break;
            case 2:
                CurrentZone = Map.East;
                break;
            case 3:
                CurrentZone = Map.South;
                break;
            case 4:
                CurrentZone = Map.West;
                break;
        }

        World.Update(minutes);
    }

}================================================================================

File: ./PlayerComponents/CombatManager.cs
--------------------------------------------------------------------------------
using System.Runtime;
using Microsoft.VisualBasic;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

public class CombatManager
{
    public CombatManager(Actor owner)
    {
        Owner = owner;
    }

    public double DetermineDamage()
    {
        // base weapon and skill
        double baseDamage = Owner.ActiveWeapon.Damage;

        double skillBonus = 0;
        if (Owner is Player player)
        {
            skillBonus = player.Skills.Fighting.Level;
        }

        // modifiers
        double strengthModifier = (Owner.Body.CalculateStrength() / 2) + .5; // str determines up to 50%
        // A smaller health modifier up to 30%
        double healthModifier = 0.7 + (0.3 * (Owner.Body.Health / Owner.Body.MaxHealth));
        // todo factor in any effects like adrenaline, etc.
        // This could be expanded based on your EffectRegistry
        double effectsModifier = 1.0;
        double randomModifier = Utils.RandDouble(.5, 1.5);
        double totalModifier = strengthModifier * healthModifier * effectsModifier * randomModifier;

        double damage = (baseDamage + skillBonus) * totalModifier;
        return damage >= 0 ? damage : 0;
    }

    public double DetermineDodgeChance(Actor target)
    {

        double dodgeLevel = 0;
        if (target is Player player)
            dodgeLevel = player.Skills.Reflexes.Level;

        double baseDodge = dodgeLevel / 100;
        double speedDiff = target.Body.CalculateSpeed() - Owner.Body.CalculateSpeed();
        double chance = baseDodge + speedDiff;
        // Output.WriteLine("Debug: Dodge Chance = ", chance);
        chance = Math.Clamp(chance, 0, .95);
        return chance;
    }

    public bool DetermineDodge(Actor target)
    {
        double dodgeChance = DetermineDodgeChance(target);
        if (Utils.DetermineSuccess(dodgeChance))
        {
            Output.WriteLine($"{Owner} dodged the attack!");
            return true;
        }
        return false;
    }

    public bool DetermineHit()
    {
        // Output.WriteLine("Debug: hit Chance: ", Owner.ActiveWeapon.Accuracy);
        double hitChance = Math.Clamp(Owner.ActiveWeapon.Accuracy, .01, .95);
        if (!Utils.DetermineSuccess(hitChance))
        {
            Output.WriteLine($"{Owner} missed!");
            return false;
        }
        return true;
    }

    public bool DetermineBlock(Actor target)
    {
        double blockLevel = 0;
        if (target is Player player)
            blockLevel = player.Skills.Defense.Level;
        double skillBonus = blockLevel / 100;
        double attributeAvg = target.Body.CalculateStrength(); // todo 
        double blockAtbAvg = target.ActiveWeapon.BlockChance + attributeAvg / 2;
        double blockChance = blockAtbAvg + skillBonus;
        if (Utils.DetermineSuccess(blockChance))
        {
            Output.WriteLine($"{target} blocked the attack!");
            return true;
        }
        return false;
    }

    public void Attack(Actor target, IBodyPart? targetedPart = null)
    {
        bool isDodged = DetermineDodge(target);
        string partName = targetedPart?.Name ?? "body";
        if (isDodged)
        {
            // Use our narrator for rich descriptions
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, partName, false, true, false);
            Output.WriteLine(description);
            return;
        }

        bool isHit = DetermineHit();
        if (!isHit)
        {
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, partName, false, false, false);
            Output.WriteLine(description);
            return;
        }

        // Check for block
        bool isBlocked = DetermineBlock(target);
        if (isBlocked)
        {
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, partName, true, false, true);
            Output.WriteLine(description);
            return;
        }

        double damage = DetermineDamage();

        if (targetedPart != null)
        {
            AdjustAccuracyForTargeting(targetedPart);
        }

        DamageType type = DamageType.Blunt;
        if (Owner.ActiveWeapon.Class == WeaponClass.Blade || Owner.ActiveWeapon.Class == WeaponClass.Claw)
        {
            type = DamageType.Sharp;
        }
        else if (Owner.ActiveWeapon.Class == WeaponClass.Pierce)
        {
            type = DamageType.Pierce;
        }

        DamageInfo damageInfo = new(
            amount: damage,
            source: Owner.Name,
            type: type,
            accuracy: Owner.ActiveWeapon.Accuracy,
            targetPart: targetedPart
        );

        target.Damage(damageInfo);

        double partHealthPercent = 0;
    
        if (targetedPart != null)
        {
            partHealthPercent = targetedPart.Condition;
        }
        string attackDescription = CombatNarrator.DescribeAttack(Owner, target, damage, partName, true, false, false);
        Output.WriteLine(attackDescription);

        // Add part status if it's significantly damaged
        if (partHealthPercent < 0.9)
        {
            string statusDesc = CombatNarrator.DescribeTargetStatus(partName, partHealthPercent);
            if (!string.IsNullOrEmpty(statusDesc))
            {
                Output.WriteLine(statusDesc);
            }
        }

        // Add weapon-specific effect descriptions
        if (Owner.ActiveWeapon.Class == WeaponClass.Blade && damage > 10)
        {
            Output.WriteDanger("Blood sprays from the wound!");
        }
        else if (Owner.ActiveWeapon.Class == WeaponClass.Blunt && damage > 12)
        {
            Output.WriteDanger("You hear a sickening crack!");
        }
        else if (Owner.ActiveWeapon.Class == WeaponClass.Pierce && damage > 15)
        {
            Output.WriteDanger("The attack pierces deep into the flesh!");
        }

        if (target is Player player)
        {
            player.Skills.Fighting.GainExperience(1);
        }
        Thread.Sleep(1000);
    }

    private double AdjustAccuracyForTargeting(IBodyPart targetedPart)
    {
        return .8; // todo, for now slight penalty for targeting vs random swing
    }

    public Actor Owner { get; }
}
================================================================================

File: ./PlayerComponents/InventoryManager.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

public class InventoryManager
{
    public InventoryManager(EffectRegistry effectRegistry)
    {
        Armor = [];
        _unarmed = ItemFactory.MakeFists();
        Inventory = new Container("Bag", 10);
        _effectRegistry = effectRegistry;
    }
    private Container Inventory { get; }
    public List<ItemStack> Items => ItemStack.CreateStacksFromItems(Inventory.Items);
    public List<Armor> Armor { get; }
    public Gear? HeldItem { get; private set; }
    private EffectRegistry _effectRegistry { get; }
    // weapon
    private Weapon? _weapon;
    private readonly Weapon _unarmed;
    public bool IsArmed => Weapon != _unarmed;
    public bool IsArmored => Armor.Count != 0;

    public Armor? GetArmorInSpot(EquipSpots spot) => Armor.FirstOrDefault(i => i.EquipSpot == spot);
    public Weapon Weapon
    {
        get => _weapon ?? _unarmed;
        set => _weapon = value;
    }

    public void AddToInventory(Item item)
    {
        Output.WriteLine("You put the ", item, " in your ", Inventory);
        Inventory.Add(item);
    }

    public void RemoveFromInventory(Item item)
    {
        Output.WriteLine("You take the ", item, " from your ", Inventory);
        Inventory.Remove(item);
    }

    public double ArmorRating
    {
        get
        {
            double rating = 0;
            foreach (Armor armor in Armor)
            {
                rating += armor.Rating;
            }
            return rating;
        }
    }

    public double ClothingInsulation => Armor.Sum(a => a.Insulation);

    public void Equip(IEquippable item)
    {
        switch (item)
        {
            case Weapon weapon:
                Unequip(Weapon);
                Weapon = weapon;
                break;
            case Armor armor:
                var oldItem = Armor.FirstOrDefault(i => i.EquipSpot == armor.EquipSpot);
                if (oldItem != null) Unequip(oldItem);
                Armor.Add(armor);
                break;
            case Gear gear:
                if (HeldItem != null) Unequip(HeldItem);
                HeldItem = gear;
                break;
            default:
                Output.WriteLine("You can't equip that.");
                return;
        }
        Inventory.Remove((Item)item);
        item.EquipEffects.ForEach(_effectRegistry.AddEffect);
    }
    public void Unequip(IEquippable item)
    {
        if (item is not Gear gear) return;
        if (item == _unarmed) return;

        switch (gear)
        {
            case Weapon weapon:
                Weapon = _unarmed;
                break;
            case Armor armor:
                Armor.Remove(armor);
                break;
            case Gear g:
                HeldItem = null;
                break;
            default:
                Output.WriteLine("You can't unequip that.");
                return;
        }
        Output.WriteLine("You unequip ", gear);
        Inventory.Add(gear);
        gear.EquipEffects.ForEach(_effectRegistry.RemoveEffect);
    }
    public void CheckGear()
    {
        DescribeGear(this);
        Output.WriteLine("Would you like to unequip an item?");
        if (Input.ReadYesNo()) return;

        Output.WriteLine("Which item would you like to unequip?");
        // get list of all equipment
        var equipment = new List<IEquippable>();
        equipment.AddRange(Armor);
        if (IsArmed) equipment.Add(Weapon);
        if (HeldItem != null) equipment.Add(HeldItem);

        var choice = Input.GetSelectionFromList(equipment, true);
        if (choice == null) return;
        Unequip(choice);
    }

    public static void DescribeGear(InventoryManager inv)
    {
        if (inv.IsArmed)
        {
            Output.Write("Weapon => ");
            inv.Weapon.Describe();
        }
        foreach (Armor armor in inv.Armor)
        {
            Output.Write(armor.EquipSpot, " => ");
            armor.Describe();
        }
        if (inv.HeldItem is not null)
        {
            Output.Write("Held Item => ");
            inv.HeldItem.Describe();
        }
    }
    public void Describe()
    {
        Output.WriteLine(Inventory, " (", Inventory.Weight(), "/", Inventory.MaxWeight, "):");
    }
}
================================================================================

File: ./Effects/SweatEffect.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Effects;

public class SweatingEffect : Effect
{
    private double _waterLossRate; // Liters per hour

    public SweatingEffect(double severity)
        : base("Sweating", "Heat exposure", null, severity, -2) // Naturally decreases when not refreshed
    {
        // Water loss rate based on severity
        _waterLossRate = 0.05 * severity; // Liters per hour
        CanHaveMultiple = false; // Use EffectRegistry's stacking mechanism
    }

    protected override void OnApply(Actor target)
    {
        if (Severity > 0.7)
        {
            Output.WriteLine($"{target} is sweating profusely.");
        }
        else if (Severity > 0.3)
        {
            Output.WriteLine($"{target} is sweating.");
        }
        else
        {
            Output.WriteLine($"{target} is  beginning to sweat.");
        }
    }

    protected override void OnRemove(Actor target)
    {
        Output.WriteLine($"{target} stopped sweating.");
    }

    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update water loss rate when severity changes
        _waterLossRate = 0.05 * updatedSeverity;

        // Only notify player of significant changes
        if (Math.Abs(oldSeverity - updatedSeverity) > 0.3)
        {
            if (updatedSeverity > oldSeverity)
            {
                if (updatedSeverity > 0.7)
                {
                    Output.WriteLine($"{target} is  now sweating profusely.");
                }
                else
                {
                    Output.WriteLine($"{target} is  sweating more.");
                }
            }
            else if (updatedSeverity < 0.3)
            {
                Output.WriteLine($"{target} is sweating less.");
            }
        }
    }

    protected override void OnUpdate(Actor target)
    {
        if (target is Player player)
        {
            double waterLoss = _waterLossRate * 1000 / 60; // convert to ml per minute
            var stats = new SurvivalStatsUpdate();
            stats.Hydration = -waterLoss;
            player.Body.UpdateSurvivalStats(stats);
            Output.WriteLine($"You lose {waterLoss:F2} ml of water due to sweating.");
        }
    }
    public override string Describe()
    {
        string intensityDesc;
        if (Severity > 0.7)
            intensityDesc = "Profuse";
        else if (Severity > 0.3)
            intensityDesc = "Moderate";
        else
            intensityDesc = "Mild";

        return $"{intensityDesc} sweating";
    }
}
================================================================================

File: ./Effects/ShiveringEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects;

public class ShiveringEffect : Effect
{
    private double _tempBoost;

    public ShiveringEffect(double severity)
        : base("Shivering", "Cold exposure", null, severity, -0.1) // Naturally decreases when not refreshed
    {
        // Calculate metabolism boost based on severity
        _tempBoost = severity * 0.2; // Up to 20% metabolism increase

        // Setup capacity modifiers - shivering affects fine motor control
        CapacityModifiers["Manipulation"] = -0.2 * severity;

        CanHaveMultiple = false; // Use EffectRegistry's stacking mechanism
    }

    protected override void OnUpdate(Actor target)
    {
        target.Body.BodyTemperature += _tempBoost; // Increase body temperature
    }

    protected override void OnApply(Actor target)
    {
        if (Severity > 0.7)
        {
            Output.WriteDanger("You are shivering violently.");
        }
        else if (Severity > 0.3)
        {
            Output.WriteWarning("You are shivering.");
        }
        else
        {
            Output.WriteWarning("You are beginning to shiver.");
        }
    }

    protected override void OnRemove(Actor target)
    {
        Output.WriteLine("You stop shivering.");
    }

    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        // Update metabolism boost when severity changes
        _tempBoost = updatedSeverity * 0.2;

        // Update capacity modifiers when severity changes
        CapacityModifiers["Manipulation"] = -0.2 * updatedSeverity;

        // Only notify player of significant changes
        if (Math.Abs(oldSeverity - updatedSeverity) > 0.3)
        {
            if (updatedSeverity > oldSeverity)
            {
                if (updatedSeverity > 0.7)
                {
                    Output.WriteDanger($"{target} is now shivering violently.");
                }
                else
                {
                    Output.WriteWarning($"{target} is shivering more intensely.");
                }
            }
            else if (updatedSeverity < 0.3)
            {
                Output.WriteLine($"{target}'s shivering is subsiding.");
            }
        }
    }

    public override string Describe()
    {
        string intensityDesc;
        if (Severity > 0.7)
            intensityDesc = "Violent";
        else if (Severity > 0.3)
            intensityDesc = "Moderate";
        else
            intensityDesc = "Mild";

        return $"{intensityDesc} shivering";
    }
}================================================================================

File: ./Effects/BleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects;

public class BleedEffect : Effect
{
    private float _damagePerHour;

    public BleedEffect(string source, MajorBodyPart? targetPart, float severity, float damagePerHour, int durationMin = -1)
        : base("Bleeding", source, targetPart, severity)
    {
        _damagePerHour = damagePerHour;

        // Configure effect properties
        SeverityChangeRate = -0.05f; // Natural clotting
        CanHaveMultiple = true; // Multiple cuts can stack

        // Configure capacity modifiers
        CapacityModifiers["BloodPumping"] = 0.2f; // Reduces blood pumping capacity by 20%
        CapacityModifiers["Consciousness"] = 0.1f; // Minor consciousness impact
    }

    protected override void OnApply(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"{target}'s {location} is bleeding!");
    }

    protected override void OnUpdate(Actor target)
    {
        // Calculate damage for one minute based on severity
        double damage = _damagePerHour / 60.0 * Severity;

        // Apply damage to the specific body part
        var damageInfo = new DamageInfo
        {
            Amount = damage,
            Type = DamageType.Bleed,
            Source = Source,
            TargetPart = TargetBodyPart
        };

        target.Damage(damageInfo);

        // Occasionally remind player of bleeding
        if (Utils.DetermineSuccess(0.05f) && Severity > 0.3f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"Blood continues to flow from {target}'s {location}...");
        }
    }

    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
    {
        if (updatedSeverity < 0.2f && oldSeverity >= 0.2f)
        {
            string location = TargetBodyPart?.Name ?? "body";
            Output.WriteLine($"The bleeding on {target}'s {location} is slowing.");
        }
    }

    protected override void OnRemove(Actor target)
    {
        string location = TargetBodyPart?.Name ?? "body";
        Output.WriteLine($"The bleeding on {target}'s {location} has stopped.");
    }
}================================================================================

File: ./Effects/RemoveBleedEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;

namespace text_survival.Effects
{
    public class RemoveBleedEffect : Effect
    {
        public RemoveBleedEffect(string source, MajorBodyPart? targetBodyPart) : base("RemoveBleed", source, targetBodyPart, severity: 1.0f)
        {
        }

        protected override void OnApply(Actor target)
        {
            var effects = target.GetEffectsByKind("bleed");
            if (effects.Count == 0)
            {
                effects = target.GetEffectsByKind("bleeding");
                if (effects.Count == 0)
                {
                    Output.WriteWarning("There was no bleeding to stop");
                    this.Remove(target);
                    return;
                }
            }
            var bleed = effects[0];
            bleed.Remove(target);
            Output.WriteLine(target, " stopped bleeding.");
            this.Remove(target);
        }
    }
}================================================================================

File: ./Effects/HealEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;
public class HealEffect : Effect
{
    private float _healAmountPerHour;
    private string _targetPartName;

    public HealEffect(string source, MajorBodyPart? targetPart, float healAmount, int durationMin = 60)
        : base("Healing", source, targetPart, 1.0f)
    {
        _healAmountPerHour = healAmount;
        _targetPartName = targetPart?.Name ?? "body";

        // Configure effect properties
        CanHaveMultiple = false; // Healing doesn't stack
        SeverityChangeRate = -1.0f / durationMin; // Decreases to 0 over duration
    }

    protected override void OnApply(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"{Source} begins healing {target}'s {location}.");
    }

    protected override void OnUpdate(Actor target)
    {
        // Calculate healing for one minute
        float healAmount = _healAmountPerHour / 60.0f;

        // Apply healing
        var healInfo = new HealingInfo
        {
            Amount = healAmount,
            Quality = 1.0,
            Source = Source,
            TargetOrgan = _targetPartName
        };

        target.Heal(healInfo);

        // Visual effect based on severity (how much healing is left)
        if (Utils.DetermineSuccess(0.05f))
        {
            string location = _targetPartName;
            if (Severity > 0.7f)
            {
                Output.WriteLine($"Fresh healing is occurring in {target}'s {location}.");
            }
            else if (Severity > 0.3f)
            {
                Output.WriteLine($"The healing in {target}'s {location} continues steadily.");
            }
            else
            {
                Output.WriteLine($"The healing in {target}'s {location} is nearly complete.");
            }
        }
    }

    protected override void OnRemove(Actor target)
    {
        string location = _targetPartName;
        Output.WriteLine($"The healing process on {target}'s {location} is complete.");
    }
}================================================================================

File: ./Effects/EffectRegistry.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;

public class EffectRegistry(Actor owner)
{
    public void AddEffect(Effect effect)
    {
        if (_effects.Contains(effect)) return;

        MajorBodyPart? part = effect.TargetBodyPart;

        if (!effect.CanHaveMultiple)
        {
            var existingEffect = _effects.FirstOrDefault(e => e.TargetBodyPart == part && e.EffectKind == effect.EffectKind);
            if (existingEffect != null)
            {
                double newSeverity = Math.Max(existingEffect.Severity, effect.Severity);
                existingEffect.UpdateSeverity(_owner, newSeverity);
                return;
            }
        }

        _effects.Add(effect);
        effect.Apply(_owner);
    }

    public void RemoveEffect(Effect effect)
    {
        if (_effects.Remove(effect))
        {
            effect.Remove(_owner);
        }
        else
        {
            Output.WriteWarning("ERROR: couldn't find effect to remove.");
        }
    }
    public void Update()
    {
        _effects.ForEach(e => e.Update(_owner));
        // Clean up inactive effects
        _effects.RemoveAll(e => !e.IsActive);
    }


    public CapacityModifierContainer CapacityModifiers(IBodyPart part)
    {
        var modifiers = GetEffectsOnBodyPart(part).Select(e => e.CapacityModifiers).ToList();
        CapacityModifierContainer total = new();
        foreach (var mod in modifiers) {
            total += mod;
        }

        return total;
    }

    public List<Effect> GetEffectsOnBodyPart(IBodyPart part) => [.. _effects.Where(e => e.TargetBodyPart == part)];
    public List<Effect> GetEffectsByKind(string kind) => [.. _effects.Where(e => e.EffectKind.Equals(kind, StringComparison.CurrentCultureIgnoreCase))];
    public void RemoveEffectsByKind(string kind)
    {
        var effectsToRemove = _effects.Where(e => e.EffectKind.Equals(kind, StringComparison.CurrentCultureIgnoreCase)).ToList();
        foreach (var effect in effectsToRemove)
        {
            RemoveEffect(effect);
        }
    }


    private readonly Actor _owner = owner;
    private List<Effect> _effects = [];
}================================================================================

File: ./Effects/EffectBuilder.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects;

public class EffectBuilder
{
    private string _effectKind = "";
    private string _source = "";
    private MajorBodyPart? _targetBodyPart = null;
    private double _severity = 1.0;
    private double _severityChangeRate = 0;
    private bool _canHaveMultiple = false;
    private bool _requiresTreatment = false;
    private readonly Dictionary<string, double> _capacityModifiers = new();

    // Hook actions - using lists to allow multiple actions
    private readonly List<Action<Actor>> _onApplyActions = [];
    private readonly List<Action<Actor>> _onUpdateActions = [];
    private readonly List<Action<Actor, double, double>> _onSeverityChangeActions = [];
    private readonly List<Action<Actor>> _onRemoveActions = [];

    public EffectBuilder Named(string effectKind)
    {
        _effectKind = effectKind;
        return this;
    }

    public EffectBuilder From(string source)
    {
        _source = source;
        return this;
    }

    public EffectBuilder Targeting(MajorBodyPart? bodyPart)
    {
        _targetBodyPart = bodyPart;
        return this;
    }

    public EffectBuilder WithSeverity(double severity)
    {
        _severity = Math.Clamp(severity, 0, 1);
        return this;
    }

    public EffectBuilder WithSeverityChangeRate(double rate)
    {
        _severityChangeRate = rate;
        return this;
    }

    public EffectBuilder AllowMultiple(bool allow = true)
    {
        _canHaveMultiple = allow;
        return this;
    }

    public EffectBuilder RequiresTreatment(bool requires = true)
    {
        _requiresTreatment = requires;
        return this;
    }

    public EffectBuilder ReducesCapacity(string capacity, double reduction)
    {
        _capacityModifiers[capacity] = -reduction;
        return this;
    }

    public EffectBuilder ModifiesCapacity(string capacity, double multiplier)
    {
        _capacityModifiers[capacity] = multiplier;
        return this;
    }

    public EffectBuilder OnApply(Action<Actor> action)
    {
        _onApplyActions.Add(action);
        return this;
    }

    public EffectBuilder OnUpdate(Action<Actor> action)
    {
        _onUpdateActions.Add(action);
        return this;
    }

    public EffectBuilder OnSeverityChange(Action<Actor, double, double> action)
    {
        _onSeverityChangeActions.Add(action);
        return this;
    }

    public EffectBuilder OnRemove(Action<Actor> action)
    {
        _onRemoveActions.Add(action);
        return this;
    }

    public DynamicEffect Build()
    {
        if (string.IsNullOrWhiteSpace(_effectKind))
        {
            throw new InvalidOperationException("Effect kind is required");
        }

        // Combine multiple actions like ActionBuilder does
        Action<Actor>? combinedOnApply = null;
        if (_onApplyActions.Count > 0)
        {
            combinedOnApply = target => _onApplyActions.ForEach(action => action(target));
        }

        Action<Actor>? combinedOnUpdate = null;
        if (_onUpdateActions.Count > 0)
        {
            combinedOnUpdate = target => _onUpdateActions.ForEach(action => action(target));
        }

        Action<Actor, double, double>? combinedOnSeverityChange = null;
        if (_onSeverityChangeActions.Count > 0)
        {
            combinedOnSeverityChange = (target, oldSeverity, newSeverity) =>
                _onSeverityChangeActions.ForEach(action => action(target, oldSeverity, newSeverity));
        }

        Action<Actor>? combinedOnRemove = null;
        if (_onRemoveActions.Count > 0)
        {
            combinedOnRemove = target => _onRemoveActions.ForEach(action => action(target));
        }

        return new DynamicEffect(
            effectKind: _effectKind,
            source: _source,
            targetBodyPart: _targetBodyPart,
            severity: _severity,
            severityChangeRate: _severityChangeRate,
            canHaveMultiple: _canHaveMultiple,
            requiresTreatment: _requiresTreatment,
            capacityModifiers: new Dictionary<string, double>(_capacityModifiers),
            onApply: combinedOnApply,
            onUpdate: combinedOnUpdate,
            onSeverityChange: combinedOnSeverityChange,
            onRemove: combinedOnRemove
        );
    }
}

public static class EffectBuilderExtensions
{
    public static EffectBuilder CreateEffect(string effectKind) => new EffectBuilder().Named(effectKind);

    // Common effect patterns
    public static EffectBuilder Bleeding(this EffectBuilder builder, double damagePerHour)
    {
        return builder
            .Named("Bleeding")
            .WithSeverityChangeRate(-0.05) // Natural clotting
            .AllowMultiple(true)
            .ReducesCapacity(CapacityNames.BloodPumping, 0.2)
            .ReducesCapacity(CapacityNames.Consciousness, 0.1)
            .WithApplyMessage("{target} is bleeding!")
            .WithPeriodicMessage("Blood continues to flow from {target}'s wound...")
            .WhenSeverityDropsBelowWithMessage(0.2, "{target}'s bleeding is slowing")
            .OnUpdate(target =>
            {
                double damage = (damagePerHour / 60.0) * builder.Build().Severity;
                var damageInfo = new DamageInfo
                {
                    Amount = damage,
                    Type = DamageType.Bleed,
                    Source = builder.Build().Source,
                    TargetPart = builder.Build().TargetBodyPart
                };
                target.Damage(damageInfo);
            });
    }

    public static EffectBuilder Poisoned(this EffectBuilder builder, double damagePerHour)
    {
        return builder
            .Named("Poison")
            .WithSeverityChangeRate(-0.02) // Slow detox
            .AllowMultiple(true)
            .ReducesCapacity(CapacityNames.Consciousness, 0.3)
            .ReducesCapacity(CapacityNames.Manipulation, 0.2)
            .ReducesCapacity(CapacityNames.Moving, 0.2)
            .ReducesCapacity(CapacityNames.BloodPumping, .1)
            .OnUpdate(target =>
            {
                double damage = (damagePerHour / 60.0) * builder.Build().Severity;
                var damageInfo = new DamageInfo
                {
                    Amount = damage,
                    Type = DamageType.Poison,
                    Source = builder.Build().Source
                };
                target.Damage(damageInfo);
            });
    }

    public static EffectBuilder Healing(this EffectBuilder builder, double healPerHour)
    {
        return builder
            .Named("Healing")
            .WithSeverityChangeRate(-1.0 / 60) // Expires in 1 hour by default
            .OnUpdate(target =>
            {
                double heal = (healPerHour / 60.0) * builder.Build().Severity;
                var healInfo = new HealingInfo
                {
                    Amount = heal,
                    Quality = 1.0,
                    Source = builder.Build().Source,
                    TargetPart = builder.Build().TargetBodyPart?.Name
                };
                target.Heal(healInfo);
            });
    }

    public static EffectBuilder Temperature(this EffectBuilder builder, TemperatureType type)
    {
        return type switch
        {
            TemperatureType.Hypothermia => builder
                .Named("Hypothermia")
                .RequiresTreatment(true)
                .WithSeverityChangeRate(-.02)
                .ReducesCapacity(CapacityNames.Moving, 0.3)
                .ReducesCapacity(CapacityNames.Manipulation, 0.3)
                .ReducesCapacity(CapacityNames.Consciousness, 0.5)
                .ReducesCapacity(CapacityNames.BloodPumping, 0.2),

            TemperatureType.Hyperthermia => builder
                .Named("Hyperthermia")
                .RequiresTreatment(true)
                .WithSeverityChangeRate(-.01)
                .ReducesCapacity(CapacityNames.Consciousness, 0.5)
                .ReducesCapacity(CapacityNames.Moving, 0.3)
                .ReducesCapacity(CapacityNames.BloodPumping, 0.2),

            TemperatureType.Frostbite => builder
                .Named("Frostbite")
                .WithSeverityChangeRate(-0.02)
                .ReducesCapacity(CapacityNames.Manipulation, 0.5)
                .ReducesCapacity(CapacityNames.Moving, 0.5)
                .ReducesCapacity(CapacityNames.BloodPumping, 0.2),

            _ => builder
        };
    }

    public static EffectBuilder WithDuration(this EffectBuilder builder, int minutes)
    {
        return builder.WithSeverityChangeRate(-1.0 / minutes);
    }

    public static EffectBuilder Permanent(this EffectBuilder builder)
    {
        return builder.WithSeverityChangeRate(0);
    }

    public static EffectBuilder NaturalHealing(this EffectBuilder builder, double rate = -0.05)
    {
        return builder.WithSeverityChangeRate(rate);
    }

    // Message helpers
    public static EffectBuilder WithApplyMessage(this EffectBuilder builder, string message)
    {
        return builder.OnApply(target => IO.Output.WriteLine(message.Replace("{target}", target.Name)));
    }

    public static EffectBuilder WithRemoveMessage(this EffectBuilder builder, string message)
    {
        return builder.OnRemove(target => IO.Output.WriteLine(message.Replace("{target}", target.Name)));
    }

    public static EffectBuilder WithPeriodicMessage(this EffectBuilder builder, string message, double chance = 0.05)
    {
        return builder.OnUpdate(target =>
        {
            if (Utils.DetermineSuccess(chance))
            {
                IO.Output.WriteLine(message.Replace("{target}", target.Name));
            }
        });
    }

    public static EffectBuilder CausesDehydration(this EffectBuilder builder, double hydrationLossPerMinute)
    {
        return builder.OnUpdate(target =>
        {
            target.Body.UpdateSurvivalStats(new SurvivalStatsUpdate { Hydration = -hydrationLossPerMinute });
        });
    }

    public static EffectBuilder CausesExhaustion(this EffectBuilder builder, double exhaustionPerMinute)
    {
        return builder.OnUpdate(target =>
        {
            target.Body.UpdateSurvivalStats(new SurvivalStatsUpdate { Exhaustion = exhaustionPerMinute });
        });
    }

    public static EffectBuilder AffectsTemperature(this EffectBuilder builder, double hourlyTemperatureChange)
    {
        return builder.OnUpdate(target =>
        {
            target.Body.BodyTemperature += hourlyTemperatureChange / 60.0; // per minute
        });
    }

    public static EffectBuilder GrantsExperience(this EffectBuilder builder, string skillName, int xpPerMinute)
    {
        return builder.OnUpdate(target =>
        {
            if (target is Player player)
            {
                player.Skills.GetSkill(skillName).GainExperience(xpPerMinute);
            }
        });
    }

    public static EffectBuilder AppliesOnRemoval(this EffectBuilder builder, Effect effectToApply)
    {
        return builder.OnRemove(target =>
        {
            target.EffectRegistry.AddEffect(effectToApply);
        });
    }
    public static EffectBuilder WhenSeverityDropsBelow(this EffectBuilder builder, double threshold, Action<Actor> action)
    {
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity < threshold && oldSeverity >= threshold)
            {
                action(target);
            }
        });
    }

    public static EffectBuilder WhenSeverityRisesAbove(this EffectBuilder builder, double threshold, Action<Actor> action)
    {
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity > threshold && oldSeverity <= threshold)
            {
                action(target);
            }
        });
    }

    public static EffectBuilder WhenSeverityDropsBelowWithMessage(this EffectBuilder builder, double threshold, string message)
    {
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity < threshold && oldSeverity >= threshold)
            {
                IO.Output.WriteLine(message.Replace("{target}", target.Name));
            }
        });
    }

    public static EffectBuilder WhenSeverityRisesAboveWithMessage(this EffectBuilder builder, double threshold, string message)
    {
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity > threshold && oldSeverity <= threshold)
            {
                IO.Output.WriteLine(message.Replace("{target}", target.Name));
            }
        });
    }
    public static EffectBuilder ClearsEffectType(this EffectBuilder builder, string effectKindToClear)
    {
        return builder.OnApply(target =>
        {
            var effectsToClear = target.EffectRegistry.GetEffectsByKind(effectKindToClear);
            foreach (var effect in effectsToClear)
            {
                effect.Remove(target);
            }
        });
    }
}

public enum TemperatureType
{
    Hypothermia,
    Hyperthermia,
    Frostbite,
    Burn
}

// Dynamic effect class to support the builder
public class DynamicEffect : Effect
{
    private readonly Action<Actor>? _onApply;
    private readonly Action<Actor>? _onUpdate;
    private readonly Action<Actor, double, double>? _onSeverityChange;
    private readonly Action<Actor>? _onRemove;

    public DynamicEffect(
        string effectKind,
        string source,
        MajorBodyPart? targetBodyPart,
        double severity,
        double severityChangeRate,
        bool canHaveMultiple,
        bool requiresTreatment,
        Dictionary<string, double> capacityModifiers,
        Action<Actor>? onApply = null,
        Action<Actor>? onUpdate = null,
        Action<Actor, double, double>? onSeverityChange = null,
        Action<Actor>? onRemove = null)
        : base(effectKind, source, targetBodyPart, severity, severityChangeRate)
    {
        CanHaveMultiple = canHaveMultiple;
        RequiresTreatment = requiresTreatment;

        // Apply capacity modifiers
        foreach (var modifier in capacityModifiers)
        {
            CapacityModifiers.GetType()
                .GetProperty(modifier.Key)?
                .SetValue(CapacityModifiers, modifier.Value);
        }

        _onApply = onApply;
        _onUpdate = onUpdate;
        _onSeverityChange = onSeverityChange;
        _onRemove = onRemove;
    }

    protected override void OnApply(Actor target) => _onApply?.Invoke(target);
    protected override void OnUpdate(Actor target) => _onUpdate?.Invoke(target);
    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
        => _onSeverityChange?.Invoke(target, oldSeverity, updatedSeverity);
    protected override void OnRemove(Actor target) => _onRemove?.Invoke(target);
}================================================================================

File: ./Effects/Effect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects
{
    public abstract class Effect(string effectKind, string source, MajorBodyPart? targetBodyPart = null, double severity = 1, double severityChangeRate = 0)
    {
        #region Properties
        public string EffectKind { get; protected set; } = effectKind;
        public string Source { get; } = source;
        public MajorBodyPart? TargetBodyPart { get; set; } = targetBodyPart;
        public bool CanHaveMultiple { get; protected set; } = false;
        public bool IsActive { get; protected set; } = true;
        public double Severity { get; protected set; } = severity;
        public double SeverityChangeRate { get; protected set; } = severityChangeRate;
        public bool RequiresTreatment { get; protected set; } = false;
        public CapacityModifierContainer CapacityModifiers { get; } = new();
        // public List<TreatmentOption> TreatmentOptions {get;}
        #endregion

        #region  core algorithm methods - typically don't override
        /// <summary>
        /// Gets called once by the effect registry, you probably shouldn't be calling this directly.
        /// </summary>
        public void Apply(Actor target)
        {
            IsActive = true;
            OnApply(target);
        }

        /// <summary>
        /// Gets called every minute. The main algorithm which calls the hook methods.
        /// If IsActive is false do nothing, otherwise call each hook in this order
        /// 1. OnUpdate
        /// 2. OnUpdateSeverity if SeverityChangeRate <> 0
        /// 3. OnRemove if severity <= 0
        /// </summary>
        public void Update(Actor target)
        {
            if (!IsActive) return;

            OnUpdate(target);

            if (!RequiresTreatment && SeverityChangeRate > 0)
            {
                double minuteChange = SeverityChangeRate / 60;
                UpdateSeverity(target, minuteChange);
            }

            if (Severity <= 0)
            {
                Remove(target);
                return;
            }
        }

        /// <summary>
        /// Gets called when the severity reaches zero and automatically removes the effect from the target
        /// </summary>
        public void Remove(Actor target)
        {
            if (!IsActive) return;
            OnRemove(target);
            IsActive = false;
        }

        /// <summary>
        /// Gets called every minute if the severity change rate is not 0
        /// </summary>
        public virtual void UpdateSeverity(Actor target, double severityChange)
        {
            if (!IsActive) return;

            double oldSeverity = Severity;

            Severity = Math.Clamp(Severity + severityChange, 0, 1);

            if (Math.Abs(oldSeverity - Severity) > 0.01)
            {
                OnSeverityChange(target, oldSeverity, Severity);
            }
        }
        #endregion


        #region Hook Methods
        // hook methods that can be implemented by sub classes

        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called once when the effect is applied to the target
        /// </summary>
        protected virtual void OnApply(Actor target) { }
        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called every minute when the effect is active
        /// </summary>
        protected virtual void OnUpdate(Actor target) { }
        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called whenever the severity changes
        /// </summary>
        protected virtual void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity) { }
        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called once when the effect is removed from the target
        /// </summary>
        protected virtual void OnRemove(Actor target) { }

        #endregion

        #region UI methods
        public string GetSeverityDescription()
        {
            if (Severity < 0.3f) return "Minor";
            if (Severity < 0.7f) return "Moderate";
            if (Severity < 0.9f) return "Severe";
            return "Critical";
        }
        public virtual string Describe()
        {
            string severityDesc = GetSeverityDescription();
            string locationDesc = TargetBodyPart != null ? $" on {TargetBodyPart.Name}" : "";
            return $"{severityDesc} {EffectKind}{locationDesc}";
        }
        #endregion
    }
}================================================================================

File: ./Command.cs
--------------------------------------------------------------------------------
﻿// namespace text_survival
// {
//     public interface ICommand
//     {
//         public string Name { get; set; }
//         public void Execute();
//     }


//     public class Command<TPlayer> : ICommand
//     {
//         public string Name { get; set; }
//         public Action<TPlayer> Act { get; set; }
//         public TPlayer? Player { get; set; }

//         public Command(string name, Action<TPlayer> act)
//         {
//             Name = name;
//             Act = act;
//         }

//         public void Execute()
//         {
//             if (Player == null)
//             {
//                 throw new Exception("Player is null");
//             }
//             Act.Invoke(Player);
//         }

//         public override string ToString() => Name;
//     }
// }
================================================================================

File: ./Bodies/BodyPart.cs
--------------------------------------------------------------------------------
﻿using System.ComponentModel.DataAnnotations;
using text_survival.IO;

namespace text_survival.Bodies;


public static class BodyPartNames
{
    public const string Head = "Head";
    public const string Chest = "Chest";
    public const string Abdomen = "Abdomen";
    public const string LeftArm = "Left Arm";
    public const string RightArm = "Right Arm";
    public const string LeftLeg = "Left Leg";
    public const string RightLeg = "Right Leg";
}


public class MajorBodyPart(string name, double coverage) : IBodyPart
{
    // Core properties
    public string Name { get; } = name;
    public double Coverage { get; set; } = coverage;

    // part makeup
    public Tissue Skin { get; set; } = new Tissue("Skin");
    public Tissue Muscle { get; set; } = new Muscle();
    public Tissue Bone { get; set; } = new Bone();
    public List<Organ> Organs { get; set; } = [];

    public double Toughness { get; }
    public double Condition { get; set; }
    public bool IsDestroyed => Condition <= 0;

    public void Heal(HealingInfo healingInfo)
    {
        if (IsDestroyed) return;

        // Handle targeted healing
        if (healingInfo.TargetOrgan != null)
        {
            // Try to find the targeted part
            var organ = Organs.FirstOrDefault(o => o.Name == healingInfo.TargetOrgan);

            if (organ != null)
            {
                organ.Heal(healingInfo);
                return;
            }
        }
        // todo heal skin, bone, muscle
        // Apply healing to this part
        double adjustedAmount = healingInfo.Amount * healingInfo.Quality;
        double newCondition = Math.Min(1, Condition + adjustedAmount);
        Condition = newCondition;
    }

    public void TakeDamage(DamageInfo damageInfo)
    {
        if (IsDestroyed) return;

        var targetPart = damageInfo.TargetPart;
        if (targetPart != null && targetPart != this)
        {
            DamageSubPart(targetPart, damageInfo);
            return;
        }

        double damage = PenetrateLayers(damageInfo);
        if (damage <= 0) return;

        damageInfo.Amount = damage;
        var hitOrgan = SelectRandomOrganToHit(damageInfo);
        if (hitOrgan == null) return;

        DamageSubPart(hitOrgan, damageInfo);
    }

    private Organ? SelectRandomOrganToHit(DamageInfo damageInfo)
    {
        double damage = damageInfo.Amount;
        // External organs can be hit even with light damage
        var externalOrgans = Organs.Where(o => o.IsExternal).ToList();
        if (externalOrgans.Count > 0 && damage > 0)
        {
            return externalOrgans[Random.Shared.Next(externalOrgans.Count)];
        }

        // Internal organs need significant penetrating damage
        var internalOrgans = Organs.Where(o => !o.IsExternal).ToList();
        if (internalOrgans.Count > 0 && damage > 5) // Threshold for internal damage
        {
            return internalOrgans[Random.Shared.Next(internalOrgans.Count)];
        }

        return null; // No organ hit
    }

    private double PenetrateLayers(DamageInfo damageInfo)
    {
        DamageType damageType = damageInfo.Type;
        double damage = damageInfo.Amount;
        var layers = new[] { Skin, Muscle, Bone }.Where(l => l != null);

        foreach (var layer in layers)
        {
            double protection = layer!.GetProtection(damageType);
            double absorbed = Math.Min(damage * 0.7, protection); // Layer absorbs up to 70% of damage

            damageInfo.Amount -= absorbed;

            layer.TakeDamage(damageInfo); // Layer takes damage from absorbing

            if (damage <= 0) break;
        }

        return Math.Max(0, damage);
    }

    private IBodyPart? DamageSubPart(IBodyPart part, DamageInfo damageInfo)
    {
        part.TakeDamage(damageInfo);
        return part;
    }

    public CapacityContainer GetTotalCapacities()
    {
        // Step 1: Sum all base capacities from organs
        var baseCapacities = new CapacityContainer();
        foreach (var organ in Organs)
        {
            baseCapacities += organ.GetBaseCapacities();
        }

        // Step 2: Calculate combined material multipliers
        var baseMultipliers = new CapacityContainer
        {
            Moving = 1.0,
            Manipulation = 1.0,
            Breathing = 1.0,
            BloodPumping = 1.0,
            Consciousness = 1.0,
            Sight = 1.0,
            Hearing = 1.0,
            Digestion = 1.0,
        };

        foreach (var material in new List<ICapacityContributor> { Skin, Muscle, Bone })
        {
            var multipliers = material.GetConditionMultipliers();
            baseMultipliers = baseMultipliers.ApplyMultipliers(multipliers);
        }

        // Step 3: Apply multipliers to base capacities
        return baseCapacities.ApplyMultipliers(baseMultipliers);
    }

    public void Describe()
    {
        // Calculate health percentage
        int healthPercent = (int)(Condition * 100);

        // Determine damage severity description
        string damageDescription;
        if (healthPercent <= 0)
        {
            damageDescription = "destroyed";
        }
        else if (healthPercent < 20)
        {
            damageDescription = "critically damaged";
        }
        else if (healthPercent < 40)
        {
            damageDescription = "severely damaged";
        }
        else if (healthPercent < 60)
        {
            damageDescription = "moderately damaged";
        }
        else if (healthPercent < 80)
        {
            damageDescription = "lightly damaged";
        }
        else if (healthPercent < 100)
        {
            damageDescription = "slightly damaged";
        }
        else
        {
            damageDescription = "in perfect condition";
        }

        // Output description line
        Output.WriteLine($"- {Name} is {damageDescription} ({healthPercent}%)");
    }
    public override string ToString() => Name;
}================================================================================

File: ./Bodies/DeathSystem.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;
public enum BodyState
{
    Healthy,
    Injured,
    Critical,
    Dying,
    Dead
}

/// <summary>
/// prototype - not sure if this is how I want to do things
/// </summary>
public class DeathSystem
{
    public BodyState CheckBodyState(Body body)
    {
        var capacities = body.GetCapacities();

        // Instant death conditions
        if (HasVitalOrganDestroyed(body)) return BodyState.Dead;

        // System failure death
        if (IsInSystemFailure(capacities)) return BodyState.Dead;

        // Dying state (death inevitable without intervention)
        if (IsInDyingState(capacities, body)) return BodyState.Dying;

        // // Critical state (one system failure away from death)
        // if (IsInCriticalState(capacities)) return BodyState.Critical;

        // // Injured but stable
        // if (HasSignificantInjuries(capacities)) return BodyState.Injured;

        return BodyState.Healthy;
    }

    private bool HasVitalOrganDestroyed(Body body)
    {
        // Instant death: brain destroyed
        if (GetOrganCondition(body, "Brain") <= 0) return true;

        // Very rapid death: heart destroyed (maybe give a few minutes?)
        if (GetOrganCondition(body, "Heart") <= 0) return true;

        // Suffocation: both lungs destroyed
        var leftLung = GetOrganCondition(body, "Left Lung");
        var rightLung = GetOrganCondition(body, "Right Lung");
        if (leftLung <= 0 && rightLung <= 0) return true;

        return false;
    }

    private bool IsInSystemFailure(CapacityContainer capacities)
    {
        // Death from system collapse
        if (capacities.BloodPumping <= 0.05) return true;  // Heart barely functioning
        if (capacities.Breathing <= 0.05) return true;    // Can't breathe
        if (capacities.Consciousness <= 0) return true;   // Brain dead

        return false;
    }

    private bool IsInDyingState(CapacityContainer capacities, Body body)
    {
        // Multiple critical systems failing
        int criticalSystems = 0;
        if (capacities.BloodPumping <= 0.15) criticalSystems++;
        if (capacities.Breathing <= 0.15) criticalSystems++;
        if (capacities.Consciousness <= 0.15) criticalSystems++;

        if (criticalSystems >= 2) return true;

        // Severe blood loss (modeled as very low blood pumping)
        if (capacities.BloodPumping <= 0.1) return true;

        // Extreme pain/shock could also be dying
        if (body.GetPainLevel() > 0.8 && capacities.BloodPumping <= 0.3) return true;

        return false;
    }
}================================================================================

File: ./Bodies/Organ.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;

public static class OrganNames
{
    public const string Brain = "Brain";
    public const string LeftEye = "Left Eye";
    public const string RightEye = "Right Eye";
    public const string LeftEar = "Left Ear";
    public const string RightEar = "Right Ear";
    public const string Heart = "Heart";
    public const string LeftLung = "Left Lung";
    public const string RightLung = "Right Lung";
    public const string Liver = "Liver";
    public const string Stomach = "Stomach";
}


public class Organ(string name, double toughness, CapacityContainer capacities, bool isExternal = false) : Tissue (name, toughness)
{
    public bool IsExternal { get; set; } = isExternal;
    public CapacityContainer _baseCapacities { get; set; } = capacities;

    public void Heal(HealingInfo healingInfo)
    {
        // Apply healing to this part
        double adjustedAmount = healingInfo.Amount * healingInfo.Quality;
        Condition = Math.Min(1, Condition += adjustedAmount);
    }

    public override CapacityContainer GetBaseCapacities()
    {
        return _baseCapacities;
    }
}
================================================================================

File: ./Bodies/Capacities.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;


// for type hints if needed
public static class CapacityNames
{
    public const string Moving = "Moving";
    public const string Manipulation = "Manipulation";
    public const string Breathing = "Breathing";
    public const string BloodPumping = "BloodPumping";
    public const string Consciousness = "Consciousness";
    public const string Sight = "Sight";
    public const string Hearing = "Hearing";
    public const string Digestion = "Digestion";
}

/// <summary>
/// Acts as a double that is clamped between 0 and 1
/// </summary>
/// <param name="value">A value between 0 and 1 representing a percent capacity value.</param>
public readonly struct CapacityValue(double value)
{
    public double Value { get; } = Math.Clamp(value, 0, 1);

    public static implicit operator double(CapacityValue capacity) => capacity.Value;
    public static implicit operator CapacityValue(double value) => new(value);
}

/// <summary>
/// A container class to hold all capacity values and provide strong typing for body part capacity operations. Implements operators like addition and multiplication.
/// </summary>
public class CapacityContainer
{
    public CapacityValue Moving { get; set; }
    public CapacityValue Manipulation { get; set; }
    public CapacityValue Breathing { get; set; }
    public CapacityValue BloodPumping { get; set; }
    public CapacityValue Consciousness { get; set; }
    public CapacityValue Sight { get; set; }
    public CapacityValue Hearing { get; set; }
    public CapacityValue Digestion { get; set; }

    public List<CapacityValue> AllCapacities => [Moving, Manipulation, Breathing, BloodPumping, Consciousness, Sight, Hearing, Digestion];

    public static CapacityContainer operator +(CapacityContainer a, CapacityContainer b)
    {
        return new CapacityContainer
        {
            Moving = a.Moving + b.Moving,
            Manipulation = a.Manipulation + b.Manipulation,
            Breathing = a.Breathing + b.Breathing,
            BloodPumping = a.BloodPumping + b.BloodPumping,
            Consciousness = a.Consciousness + b.Consciousness,
            Sight = a.Sight + b.Sight,
            Hearing = a.Hearing + b.Hearing,
            Digestion = a.Digestion + b.Digestion
        };
    }
    public CapacityContainer ApplyMultipliers(CapacityContainer multipliers)
    {
        return new CapacityContainer
        {
            Moving = Moving * multipliers.Moving,
            Manipulation = Manipulation * multipliers.Manipulation,
            Breathing = Breathing * multipliers.Breathing,
            BloodPumping = BloodPumping * multipliers.BloodPumping,
            Consciousness = Consciousness * multipliers.Consciousness,
            Sight = Sight * multipliers.Sight,
            Hearing = Hearing * multipliers.Hearing,
            Digestion = Digestion * multipliers.Digestion
        };
    }

    public CapacityContainer ApplyMultiplier(double multiplier)
    {
        return new CapacityContainer
        {
            Moving = Moving * multiplier,
            Manipulation = Manipulation * multiplier,
            Breathing = Breathing * multiplier,
            BloodPumping = BloodPumping * multiplier,
            Consciousness = Consciousness * multiplier,
            Sight = Sight * multiplier,
            Hearing = Hearing * multiplier,
            Digestion = Digestion * multiplier
        };
    }


    public CapacityModifierContainer ApplyModifier(CapacityModifierContainer modifiers)
    {
        return new CapacityModifierContainer
        {
            Moving = Moving + modifiers.Moving,
            Manipulation = Manipulation + modifiers.Manipulation,
            Breathing = Breathing + modifiers.Breathing,
            BloodPumping = BloodPumping +  modifiers.BloodPumping,
            Consciousness = Consciousness + modifiers.Consciousness,
            Sight = Sight + modifiers.Sight,
            Hearing = Hearing + modifiers.Hearing,
            Digestion = Digestion + modifiers.Digestion
        };
    }


    /// <summary>
    /// Helper for generating a base CapacityContainer with all values set to one - intended for capacity multipliers.
    /// </summary>
    /// <returns>A new CapacityContainer that has all values set to 1</returns>
    public static CapacityContainer GetBaseCapacityMultiplier()
    {
        return new CapacityContainer
        {
            Moving = 1,
            Manipulation = 1,
            Breathing = 1,
            BloodPumping = 1,
            Consciousness = 1,
            Sight = 1,
            Hearing = 1,
            Digestion = 1,
        };
    }
}

/// <summary>
/// For use with additive capacity modifiers
/// </summary>
/// <param name="value">a value between -1 and 1</param>
public readonly struct CapacityModifierValue(double value)
{
    public double Value { get; } = Math.Clamp(value, -1, 1);

    public static implicit operator double(CapacityModifierValue capacity) => capacity.Value;
    public static implicit operator CapacityModifierValue(double value) => new(value);
}


public class CapacityModifierContainer
{
    public CapacityModifierValue Moving { get; set; } = 0;
    public CapacityModifierValue Manipulation { get; set; } = 0;
    public CapacityModifierValue Breathing { get; set; } = 0;
    public CapacityModifierValue BloodPumping { get; set; } = 0;
    public CapacityModifierValue Consciousness { get; set; } = 0;
    public CapacityModifierValue Sight { get; set; } = 0;
    public CapacityModifierValue Hearing { get; set; } = 0;
    public CapacityModifierValue Digestion { get; set; } = 0;

    // public List<CapacityModifierValue> AllCapacities => [Moving, Manipulation, Breathing, BloodPumping, Consciousness, Sight, Hearing, Digestion];

    public static CapacityModifierContainer operator +(CapacityModifierContainer a, CapacityModifierContainer b)
    {
        return new CapacityModifierContainer
        {
            Moving = a.Moving + b.Moving,
            Manipulation = a.Manipulation + b.Manipulation,
            Breathing = a.Breathing + b.Breathing,
            BloodPumping = a.BloodPumping + b.BloodPumping,
            Consciousness = a.Consciousness + b.Consciousness,
            Sight = a.Sight + b.Sight,
            Hearing = a.Hearing + b.Hearing,
            Digestion = a.Digestion + b.Digestion
        };
    }

}================================================================================

File: ./Bodies/Body.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;
using text_survival.Survival;

namespace text_survival.Bodies;

public class BodyStats
{
    public BodyPartFactory.BodyTypes type;
    public double overallWeight;
    public double fatPercent;
    public double musclePercent;
    public bool IsPlayer;
}

public class SurvivalContext
{
    public double LocationTemperature;
    public double ClothingInsulation;
    public double ActivityLevel;
}

public class Body
{
    // Root part and core properties
    public readonly bool IsPlayer = false;
    public readonly List<MajorBodyPart> Parts;
    public double Health => CalculateOverallHealth();

    private double CalculateOverallHealth()
    {
        // simple avg for now
        double health = Parts.Sum(p => CalculatePartHealth(p)) / Parts.Count;
        return health;
    }

    private double CalculatePartHealth(MajorBodyPart part)
    {
        // Average health of materials and organs
        var materialHealth = new List<double>
        {
            part.Skin.Condition,
            part.Muscle.Condition,
            part.Bone.Condition
        };

        var organHealth = part.Organs.Select(o => o.Condition);

        var allHealth = materialHealth.Concat(organHealth);
        return allHealth.Any() ? allHealth.Average() : 1.0;
    }

    public double MaxHealth => 1;
    public bool IsDestroyed => new DeathSystem().CheckBodyState(this).Equals(BodyState.Dead);

    public bool IsTired => _exhaustionModule.ExhaustionPercent > 25;

    public readonly EffectRegistry EffectRegistry;
    private readonly HungerModule _hungerModule;
    private readonly ThirstModule _thirstModule;
    private readonly ExhaustionModule _exhaustionModule;
    private readonly TemperatureModule _temperatureModule;

    // Physical composition
    private double _bodyFat;
    private double _muscle;
    private readonly double _baseWeight;

    public Body(string ownerName, BodyStats stats, EffectRegistry effectRegistry)
    {
        OwnerName = ownerName;
        IsPlayer = stats.IsPlayer;
        EffectRegistry = effectRegistry;
        Parts = BodyPartFactory.CreateBody(stats.type);
        _hungerModule = new HungerModule(this);
        _thirstModule = new ThirstModule();
        _exhaustionModule = new ExhaustionModule();
        _temperatureModule = new TemperatureModule(this);

        // Initialize physical composition
        _bodyFat = stats.overallWeight * stats.fatPercent;
        _muscle = stats.overallWeight * stats.musclePercent;
        _baseWeight = stats.overallWeight - _bodyFat - _muscle;

        BodyTemperature = 98.6;
    }


    // Physical composition properties
    public double BodyFat
    {
        get => _bodyFat;
        set
        {
            _bodyFat = Math.Max(value, 0);
        }
    }

    public double Muscle
    {
        get => _muscle;
        set
        {
            _muscle = Math.Max(value, 0);
        }
    }

    public readonly string OwnerName;
    public double BodyFatPercentage => _bodyFat / Weight;
    public double MusclePercentage => _muscle / Weight;
    public double Weight => _baseWeight + _bodyFat + _muscle;

    public double BodyTemperature { get; set; }

    // Forwarding methods to root part
    public void Damage(DamageInfo damageInfo)
    {
        // If targeting specific part, find it
        if (damageInfo.TargetPart != null)
        {
            var targetPart = Parts.FirstOrDefault(p => p == damageInfo.TargetPart);
            if (targetPart != null)
            {
                targetPart.TakeDamage(damageInfo);
                return;
            }
        }

        // Otherwise, distribute based on coverage
        var partChances = Parts.ToDictionary(p => p, p => p.Coverage);
        var hitPart = Utils.GetRandomWeighted(partChances);

        hitPart.TakeDamage(damageInfo);
        return;
    }
    public void Heal(HealingInfo healingInfo)
    {
        // Distribute healing across damaged parts
        if (healingInfo.TargetPart != null)
        {
            var targetPart = Parts.FirstOrDefault(p => p.Name == healingInfo.TargetPart);
            if (targetPart != null)
            {
                HealBodyPart(targetPart, healingInfo);
                return;
            }
        }

        // Heal most damaged parts first
        var damagedParts = Parts
            .Where(p => CalculatePartHealth(p) < 1.0)
            .OrderBy(p => CalculatePartHealth(p))
            .ToList();

        if (damagedParts.Count > 0)
        {
            HealBodyPart(damagedParts[0], healingInfo);
        }
    }

    private void HealBodyPart(MajorBodyPart part, HealingInfo healingInfo)
    {
        double healingAmount = healingInfo.Amount * healingInfo.Quality;

        // Heal materials first, then organs
        var materials = new[] { part.Skin, part.Muscle, part.Bone }.Where(m => m != null);
        foreach (var material in materials)
        {
            if (material!.Condition < 1.0 && healingAmount > 0)
            {
                double heal = Math.Min(healingAmount, (1.0 - material.Condition) * material.Toughness);
                material.Condition = Math.Min(1.0, material.Condition + heal / material.Toughness);
                healingAmount -= heal;
            }
        }

        // Heal organs
        foreach (var organ in part.Organs.Where(o => o.Condition < 1.0))
        {
            if (healingAmount > 0)
            {
                double heal = Math.Min(healingAmount, (1.0 - organ.Condition) * organ.Toughness);
                organ.Condition = Math.Min(1.0, organ.Condition + heal / organ.Toughness);
                healingAmount -= heal;
            }
        }
    }

    private double GetCurrentMetabolism(double activityLevel)
    {
        // Base BMR uses the Harris-Benedict equation (simplified)
        double bmr = 370 + (21.6 * Muscle) + (6.17 * BodyFat);

        // Adjust for injuries and conditions
        double healthFactor = Health / MaxHealth;
        bmr *= 0.7 + (0.3 * healthFactor); // Injured bodies need more energy to heal

        double currentMetabolism = bmr * activityLevel;
        return currentMetabolism;
    }


    public void Update(TimeSpan timePassed, SurvivalContext context)
    {
        // Handle metabolism and energy expenditure
        double currentMetabolism = GetCurrentMetabolism(context.ActivityLevel);
        double calories = currentMetabolism / 24 * timePassed.TotalHours;

        BodyTemperature += calories / 24000;

        _hungerModule.Update(currentMetabolism);
        _thirstModule.Update();
        _temperatureModule.Update(context.LocationTemperature, context.ClothingInsulation);
        _exhaustionModule.Update();
    }

    // todo - move this to the survival manager or something

    // Calculate derived attributes
    public double CalculateStrength()
    {
        var capacities = GetCapacities();
        double manipulationCapacity = capacities.Manipulation;
        double bloodPumping = capacities.BloodPumping; // Energy delivery

        // Base strength that everyone has
        double baseStrength = 0.30; // 30% strength from structural aspects

        // Muscle contribution with diminishing returns
        double muscleContribution;
        if (MusclePercentage < 0.2) // Below normal
            muscleContribution = MusclePercentage * 2.5; // Rapid gains when building from low muscle
        else if (MusclePercentage < 0.4) // Normal to athletic
            muscleContribution = 0.5 + (MusclePercentage - 0.2) * 1.0; // Moderate gains
        else // Athletic+
            muscleContribution = 0.7 + (MusclePercentage - 0.4) * 0.5; // Diminishing returns

        // Energy state affects strength expression
        double energyFactor = Math.Min(bloodPumping, 1.0);

        // Very low body fat impairs strength
        double fatPenalty = (BodyFatPercentage < 0.05) ? (0.05 - BodyFatPercentage) * 3.0 : 0;

        return manipulationCapacity * (baseStrength + muscleContribution * energyFactor - fatPenalty);
    }

    public double CalculateSpeed()
    {
        double movingCapacity = GetCapacities().Moving;
        double structuralWeightRatio = (_baseWeight / Weight) + (1 - 0.45); // avg 45% structure weight
        double sizeRatio = Weight / BaselineHumanStats.overallWeight;

        double muscleBonus = Math.Min(MusclePercentage * 0.20, 0); // Up to 20% bonus from muscle

        double fatPenalty;
        // Minimal fat has no penalty, excess has increasing penalties
        if (BodyFatPercentage < 0.10)
        {
            // 10% is minimal necessary fat
            fatPenalty = -.01; // negative penalty if under 10% bf
        }
        else if (BodyFatPercentage <= BaselineHumanStats.fatPercent)
        {
            fatPenalty = ((BodyFatPercentage - .10) * .20) - .01; // at baseline a 0% penalty
        }
        else
        {
            // Steeper penalty for excess, 1.5% reduction per 1% of fat 
            // 1.5(fat% - baselineFat%)
            // fat% => speed penalty (abs)
            // 20%  =>  8.5%, 
            // 30%  => 23.5%
            // 40%  => 38.5%
            // 50%  => 53.5%
            fatPenalty = (BodyFatPercentage - BaselineHumanStats.fatPercent) * 1.5;
        }

        // Penalty for excess weight relative to frame
        // -(ratio^.7 - 1)
        // ratio => penalty (abs)
        // 0.1   => +0.80
        // 0.5   => +0.38
        // 0.9   => +0.07
        // 1.5   => -0.33
        // 3.0   => -1.16
        double weightEffect = -(Math.Pow(structuralWeightRatio, 0.7) - 1.0);

        // smaller creatures are faster and larger ones are slower
        // 1 - .1(Log2(sizeRatio))
        // ratio => speed (multiplier)
        // 0.1   => 1.33  
        // 0.5   => 1.10   - 1/2 size means 10% faster
        // 2.0   => 0.90  - 10% slower
        // 10.   => 0.66  - 1/3 slower
        // 50    => 0.44
        double speedSizeModifier = 1 - 0.1 * Math.Log(sizeRatio, 2);

        return movingCapacity * (1 + muscleBonus - fatPenalty + weightEffect) * speedSizeModifier;
    }
    public double CalculateVitality()
    {
        var capacities = GetCapacities();
        double breathing = capacities.Breathing;
        double bloodPumping = capacities.BloodPumping;
        double digestion = capacities.Digestion;

        double organFunction = (2 * (breathing + bloodPumping) + digestion) / 5;

        // Base vitality that scales more gently with body composition
        double baseMultiplier = 0.7;  // Everyone gets 70% baseline
        double muscleContribution = MusclePercentage * 0.25;  // Up to 25% from muscle
        double fatContribution;

        // Essential fat is beneficial, excess isn't
        if (BodyFatPercentage < .10)
            fatContribution = BodyFatPercentage * 0.5;  // Fat is very important when low
        else if (BodyFatPercentage < .25)
            fatContribution = 0.05;  // Optimal fat gives 5%
        else
            fatContribution = 0.05 - (BodyFatPercentage - .25) * 0.1;  // Excess fat penalizes slightly

        double bodyComposition = baseMultiplier + muscleContribution + fatContribution;
        return organFunction * bodyComposition;
    }

    public double CalculatePerception()
    {
        double sight = GetCapacities().Sight;
        double hearing = GetCapacities().Hearing;

        return (sight + hearing) / 2;
    }

    public double CalculateColdResistance()
    {
        // Base cold resistance that everyone has
        double baseColdResistance = 0.5;
        double fatInsulation;

        if (BodyFatPercentage < 0.05)
            fatInsulation = (BodyFatPercentage / 0.05) * 0.1;  // Linear up to 5%
        else if (BodyFatPercentage < 0.15)
            fatInsulation = 0.1 + ((BodyFatPercentage - 0.05) / 0.1) * 0.15;  // From 0.1 to 0.25
        else
            fatInsulation = 0.25 + ((BodyFatPercentage - 0.15)) * 0.15;  // Diminishing returns after 15%

        return baseColdResistance + fatInsulation;
    }

    public CapacityContainer GetCapacities()
    {
        var baseCapacities = AggregatePartCapacities();

        // Apply cascading effects
        return ApplyCascadingEffects(baseCapacities);
    }

    private CapacityContainer AggregatePartCapacities()
    {
        CapacityContainer total = new();
        foreach (var part in Parts)
        {
            total += part.GetTotalCapacities();
        }
        // // Apply body-wide effect modifiers
        // double bodyModifier = EffectRegistry.GetBodyCapacityModifier(capacityName);
        // total *= (1 + bodyModifier);

        return total;
    }

    private CapacityContainer ApplyCascadingEffects(CapacityContainer baseCapacities)
    {
        var result = baseCapacities;

        // Poor blood circulation affects everything
        if (result.BloodPumping < 0.5)
        {
            double circulationPenalty = 1.0 - (0.5 - result.BloodPumping);
            result.Consciousness *= circulationPenalty;
            result.Moving *= circulationPenalty;
            result.Manipulation *= circulationPenalty;
        }

        // Can't breathe? Consciousness drops rapidly
        if (result.Breathing < 0.3)
        {
            double oxygenPenalty = result.Breathing / 0.3; // 0.0 to 1.0
            result.Consciousness *= oxygenPenalty;
        }

        // Unconscious? Can't do physical actions
        if (result.Consciousness < 0.1)
        {
            result.Moving *= 0.1;
            result.Manipulation *= 0.1;
        }

        return result;
    }

    // helper for baseline male human stats
    public static BodyStats BaselineHumanStats => new BodyStats
    {
        type = BodyPartFactory.BodyTypes.Human,
        overallWeight = 75, // KG ~165 lbs
        fatPercent = .15, // pretty lean
        musclePercent = .40 // low end of athletic
    };
    public static BodyStats BaselinePlayerStats
    {
        get
        {
            var stats = BaselineHumanStats;
            stats.IsPlayer = true;
            return stats;
        }
    }

    public void Describe()
    {
        Output.WriteLine("Body Health: " + (int)(Health * 100) + "%");
        Output.WriteLine("Weight: " + Math.Round(Weight * 2.2, 1) + " lbs");
        Output.WriteLine("Body Composition: " + (int)(BodyFatPercentage * 100) + "% fat, " + (int)(MusclePercentage * 100) + "% muscle");

        Output.WriteLine("\nPhysical Capabilities:");
        Output.WriteLine("- Strength: " + Math.Round(CalculateStrength() * 100) + "%");
        Output.WriteLine("- Speed: " + Math.Round(CalculateSpeed() * 100) + "%");
        Output.WriteLine("- Vitality: " + Math.Round(CalculateVitality() * 100) + "%");
        Output.WriteLine("- Perception: " + Math.Round(CalculatePerception() * 100) + "%");
        Output.WriteLine("- Cold Resistance: " + Math.Round(CalculateColdResistance() * 100) + "%");

        // Show damaged parts and materials
        var damagedParts = Parts.Where(p => CalculatePartHealth(p) < 1.0).ToList();

        if (damagedParts.Count > 0)
        {
            Output.WriteLine("\nInjuries:");
            foreach (var part in damagedParts)
            {
                DescribePartCondition(part);
            }
        }
        else
        {
            Output.WriteLine("\nNo injuries detected.");
        }

        // Show capacity impairments
        var capacities = GetCapacities();
        Dictionary<string, double> systemCapacities = new Dictionary<string, double>
        {
            { "Moving", capacities.Moving },
            { "Manipulation", capacities.Manipulation },
            { "Breathing", capacities.Breathing},
            { "BloodPumping", capacities.BloodPumping },
            { "Consciousness", capacities.BloodPumping },
            { "Sight", capacities.Sight},
            { "Hearing", capacities.Hearing },
            { "Digestion", capacities.Digestion }
        };

        var impairedSystems = systemCapacities.Where(kv => kv.Value < 0.9).ToList();

        if (impairedSystems.Count > 0)
        {
            Output.WriteLine("\nSystem Impairments:");
            foreach (var system in impairedSystems)
            {
                string severity = GetImpairmentSeverity(system.Value);
                Output.WriteLine($"- {system.Key}: {severity} ({(int)(system.Value * 100)}% efficiency)");
            }
        }
    }

    private void DescribePartCondition(MajorBodyPart part)
    {
        Output.WriteLine($"\n{part.Name}:");

        // Describe material damage
        if (part.Skin?.Condition < 1.0)
            Output.WriteLine($"  - Skin: {GetDamageDescription(part.Skin.Condition)}");
        if (part.Muscle?.Condition < 1.0)
            Output.WriteLine($"  - Muscle: {GetDamageDescription(part.Muscle.Condition)}");
        if (part.Bone?.Condition < 1.0)
            Output.WriteLine($"  - Bone: {GetDamageDescription(part.Bone.Condition)}");

        // Describe organ damage
        foreach (var organ in part.Organs.Where(o => o.Condition < 1.0))
        {
            Output.WriteLine($"  - {organ.Name}: {GetDamageDescription(organ.Condition)}");
        }
    }

    private string GetDamageDescription(double condition)
    {
        return condition switch
        {
            <= 0 => "destroyed",
            < 0.2 => "critically damaged",
            < 0.4 => "severely damaged",
            < 0.6 => "moderately damaged",
            < 0.8 => "lightly damaged",
            _ => "slightly damaged"
        };
    }

    private string GetImpairmentSeverity(double capacity)
    {
        return capacity switch
        {
            < 0.25 => "Critical impairment",
            < 0.5 => "Severe impairment",
            < 0.75 => "Moderate impairment",
            < 0.9 => "Minor impairment",
            _ => "Normal"
        };
    }

    public void DescribeSurvivalStats()
    {
        Output.WriteLine("\n----------------------------------------------------\n| Survival Stats:");
        _hungerModule.Describe();
        _thirstModule.Describe();
        _exhaustionModule.Describe();
        _temperatureModule.Describe();
        Output.WriteLine("----------------------------------------------------");
    }

    public bool Rest(int minutes)
    {
        int minutesSlept = 0;
        while (minutesSlept < minutes)
        {
            _exhaustionModule.Rest(1);
            World.Update(1);
            minutesSlept++;
            if (_exhaustionModule.IsFullyRested)
            {
                break;
            }
        }
        HealingInfo healing = new HealingInfo()
        {
            Amount = minutesSlept / 10,
            Type = "natural",
            TargetOrgan = "Body",
            Quality = _exhaustionModule.IsFullyRested ? 1 : .7, // healing quality is better after a full night's sleep
        };

        Heal(healing);
        return _exhaustionModule.IsFullyRested;
    }
    public void Consume(FoodItem food)
    {
        _hungerModule.AddCalories(food.Calories);
        _thirstModule.AddHydration(food.WaterContent);

        if (food.HealthEffect != null)
        {
            Heal(food.HealthEffect);
        }
        if (food.DamageEffect != null)
        {
            Damage(food.DamageEffect);
        }
    }

    public void UpdateSurvivalStats(SurvivalStatsUpdate stats)
    {
        if (stats.Temperature != 0)
        {
            BodyTemperature += stats.Temperature;
        }
        if (stats.Calories != 0)
        {
            _hungerModule.AddCalories(stats.Calories);
        }
        if (stats.Hydration != 0)
        {
            _thirstModule.AddHydration(stats.Hydration);
        }
        if (stats.Exhaustion != 0)
        {
            _exhaustionModule.ModifyExhaustion(stats.Exhaustion);
        }
    }
}================================================================================

File: ./Bodies/BodyInterfaces.cs
--------------------------------------------------------------------------------

namespace text_survival.Bodies;


// Comprehensive damage information

public enum DamageType
{
    Blunt,
    Sharp,
    Pierce,
    Poison,
    Bleed,
    
}
public class DamageInfo
{
    public DamageInfo() { }
    public DamageInfo(double amount,
                      DamageType type = DamageType.Blunt,
                      string? source = null,
                      IBodyPart? targetPart = null,
                      double accuracy = .9)
    {
        Amount = amount;
        Type = type;
        Source = source;
        TargetPart = targetPart;
        Accuracy = accuracy;
    }

    public double Amount { get; set; }
    public DamageType Type { get; set; } = DamageType.Blunt;
    public string? Source { get; set; }
    public IBodyPart? TargetPart { get; set; }
    public double Accuracy { get; set; } = .9;
}

// Comprehensive healing information
public class HealingInfo
{
    public double Amount { get; set; }
    public string Type { get; set; } = "natural"; // natural, medical, magical
    public string? TargetPart { get; set; }
    public string? TargetOrgan { get; set; }
    public double Quality { get; set; } = 1.0; // Effectiveness multiplier
    public string? Source { get; set; }
}

================================================================================

File: ./Bodies/Tissue.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;

interface ICapacityContributor
{
    CapacityContainer GetBaseCapacities();
    CapacityContainer GetConditionMultipliers();
}

public interface IBodyPart
{
    string Name { get; }
    double Condition { get; } // 0-1 health
    double Toughness { get; } // divisor of damage applied
    void TakeDamage(DamageInfo damageInfo);
}

public class Tissue(string name, double toughness = 1) : ICapacityContributor, IBodyPart
{
    public string Name { get; } = name;
    public double Condition { get; set; } = 1.0;
    public double Toughness { get; set; } = toughness;

    public virtual CapacityContainer GetBaseCapacities() => new(); // Most tissues don't provide base capacities    
    public virtual CapacityContainer GetConditionMultipliers()
    {
        {
            // Default: condition affects everything equally
            return new CapacityContainer
            {
                Moving = Condition,
                Manipulation = Condition,
                Breathing = Condition,
                BloodPumping = Condition,
                Consciousness = Condition,
                Sight = Condition,
                Hearing = Condition,
                Digestion = Condition
            };
        }
    }

    // Protection multipliers for different damage types
    public double BluntMultiplier { get; set; } = 1.0;
    public double SharpMultiplier { get; set; } = 1.0;
    public double PierceMultiplier { get; set; } = 1.0;

    public double GetProtection(DamageType damageType)
    {
        // protection provided to sub layers
        double baseProtection = Toughness * Condition;

        return damageType switch
        {
            DamageType.Blunt => baseProtection * BluntMultiplier,
            DamageType.Sharp => baseProtection * SharpMultiplier,
            DamageType.Pierce => baseProtection * PierceMultiplier,
            _ => baseProtection
        };
    }

    public void TakeDamage(DamageInfo damageInfo)
    {
        double damage = damageInfo.Amount;
        var damageType = damageInfo.Type;

        double threshold = GetNaturalAbsorption(damageType);
        if (damage < threshold)
        {
            return; // Natural squishiness absorbed it
        }

        damage -= threshold;
        damageInfo.Amount = damage;

        double healthLoss = damageInfo.Amount / GetProtection(damageInfo.Type);
        Condition = Math.Max(0, Condition - healthLoss);
    }

    private double GetNaturalAbsorption(DamageType damageType)
    {
        double baseThreshold = Name switch
        {
            OrganNames.Heart => 8,
            OrganNames.Brain => 6,
            OrganNames.LeftLung or OrganNames.RightLung => 10,
            OrganNames.Liver => 5,
            _ => 1
        };

        return damageType switch
        {
            DamageType.Blunt => baseThreshold,
            DamageType.Sharp => baseThreshold * 0.4,
            DamageType.Pierce => baseThreshold * 0.2,
            _ => baseThreshold * 0.6
        };
    }
}

class Muscle() : Tissue("Muscle", 1)
{
    public override CapacityContainer GetConditionMultipliers()
    {
        // Muscle primarily affects movement and manipulation
        return new CapacityContainer
        {
            Moving = Condition,
            Manipulation = Condition,
            // Other capacities get minimal impact
            Breathing = 0.8 + (Condition * 0.2),
            BloodPumping = 0.9 + (Condition * 0.1),
            Consciousness = 1.0,
            Sight = 1.0,
            Hearing = 1.0,
            Digestion = 1.0
        };
    }
}

class Bone() : Tissue("Bone", 10)
{
    public override CapacityContainer GetConditionMultipliers()
    {
        return new CapacityContainer
        {
            Moving = Condition * Condition, // squared, small impact near 1, exponential debuff approaching 0
            Manipulation = Condition,
            BloodPumping = 0.8 * (0.2 * Condition),
            // Other capacities get minimal impact
            Breathing = 1.0,
            Consciousness = 1.0,
            Sight = 1.0,
            Hearing = 1.0,
            Digestion = 1.0
        };
    }
}
================================================================================

File: ./Bodies/BodyPartFactory.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Bodies;

public static class BodyPartFactory
{
    public enum BodyTypes
    {
        Human,
        Quadruped,
        Serpentine,
        Arachnid,
        Flying
    }

    public static List<MajorBodyPart> CreateBody(BodyTypes type)
    {
        return type switch
        {
            BodyTypes.Human => CreateHumanBody(),
            BodyTypes.Quadruped => CreateQuadrupedBody(),
            BodyTypes.Serpentine => CreateSerpentineBody(),
            BodyTypes.Arachnid => CreateArachnidBody(),
            BodyTypes.Flying => CreateFlyingBody(),
            _ => throw new NotImplementedException("Invalid body type")
        };
    }

    public static List<MajorBodyPart> CreateHumanBody()
    {
        var parts = new List<MajorBodyPart>();

        // HEAD - 10% coverage
        var head = new MajorBodyPart(BodyPartNames.Head, 10.0);
        // Skull is very tough (20), but head overall is average
        head.Bone.Toughness = 20;
        
        // Brain - controls consciousness, very fragile
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes - each provides half sight, fragile, external
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));

        // Ears - each provides half hearing, moderately fragile, external
        head.Organs.Add(new Organ(OrganNames.LeftEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.5 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.5 
        }, isExternal: true));

        parts.Add(head);

        // CHEST - 25% coverage
        var chest = new MajorBodyPart(BodyPartNames.Chest, 25.0);
        // Ribcage protection
        chest.Bone.Toughness = 12;

        // Heart - critical for blood pumping, moderately tough
        chest.Organs.Add(new Organ(OrganNames.Heart, 5.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Lungs - each provides half breathing capacity, somewhat fragile
        chest.Organs.Add(new Organ(OrganNames.LeftLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));
        
        chest.Organs.Add(new Organ(OrganNames.RightLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));

        parts.Add(chest);

        // ABDOMEN - 20% coverage
        var abdomen = new MajorBodyPart(BodyPartNames.Abdomen, 20.0);
        
        // Liver - major digestive organ, moderately tough
        abdomen.Organs.Add(new Organ(OrganNames.Liver, 4.0, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        // Stomach - digestive organ, somewhat fragile
        abdomen.Organs.Add(new Organ(OrganNames.Stomach, 3.0, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        // Kidneys - redundant organs, each can handle most of the load
        abdomen.Organs.Add(new Organ("Left Kidney", 4.0, new CapacityContainer 
        { 
            // BloodFiltration = 0.75 - would need to add this capacity
        }, isExternal: false));
        
        abdomen.Organs.Add(new Organ("Right Kidney", 4.0, new CapacityContainer 
        { 
            // BloodFiltration = 0.75 - would need to add this capacity
        }, isExternal: false));

        parts.Add(abdomen);

        // LEFT ARM - 10% coverage
        var leftArm = new MajorBodyPart(BodyPartNames.LeftArm, 10.0);
        // No specific organs, but contributes to manipulation through muscle/bone
        // The base capacities could be set on the part itself or through muscle
        parts.Add(leftArm);

        // RIGHT ARM - 10% coverage  
        var rightArm = new MajorBodyPart(BodyPartNames.RightArm, 10.0);
        parts.Add(rightArm);

        // LEFT LEG - 12.5% coverage
        var leftLeg = new MajorBodyPart(BodyPartNames.LeftLeg, 12.5);
        parts.Add(leftLeg);

        // RIGHT LEG - 12.5% coverage
        var rightLeg = new MajorBodyPart(BodyPartNames.RightLeg, 12.5);
        parts.Add(rightLeg);

        return parts;
    }

    public static List<MajorBodyPart> CreateQuadrupedBody()
    {
        var parts = new List<MajorBodyPart>();

        // HEAD - 15% coverage (proportionally larger for quadrupeds)
        var head = new MajorBodyPart("Head", 15.0);
        head.Bone.Toughness = 15; // Slightly less protected than human skull
        
        // Brain
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes - better sight for predators/prey
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.6 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.6 
        }, isExternal: true));

        // Ears - better hearing
        head.Organs.Add(new Organ(OrganNames.LeftEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.6 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.6 
        }, isExternal: true));

        parts.Add(head);

        // TORSO - 35% coverage (larger torso for quadrupeds)
        var torso = new MajorBodyPart("Torso", 35.0);
        
        // Heart
        torso.Organs.Add(new Organ(OrganNames.Heart, 5.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Lungs
        torso.Organs.Add(new Organ(OrganNames.LeftLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));
        
        torso.Organs.Add(new Organ(OrganNames.RightLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));

        // Digestive organs
        torso.Organs.Add(new Organ(OrganNames.Liver, 4.0, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        torso.Organs.Add(new Organ(OrganNames.Stomach, 3.0, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        parts.Add(torso);

        // LEGS - 12.5% each for four legs
        var frontLeftLeg = new MajorBodyPart("Front Left Leg", 12.5);
        var frontRightLeg = new MajorBodyPart("Front Right Leg", 12.5);
        var rearLeftLeg = new MajorBodyPart("Rear Left Leg", 12.5);
        var rearRightLeg = new MajorBodyPart("Rear Right Leg", 12.5);

        parts.AddRange([frontLeftLeg, frontRightLeg, rearLeftLeg, rearRightLeg]);

        return parts;
    }

    public static List<MajorBodyPart> CreateSerpentineBody()
    {
        var parts = new List<MajorBodyPart>();

        // HEAD - 20% coverage
        var head = new MajorBodyPart("Head", 20.0);
        head.Bone.Toughness = 8; // Less protected than mammalian skulls
        
        // Brain
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));

        parts.Add(head);

        // BODY - 80% coverage (long serpentine body)
        var body = new MajorBodyPart("Body", 80.0);
        
        // Heart
        body.Organs.Add(new Organ(OrganNames.Heart, 4.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Single lung (snakes typically have one functional lung)
        body.Organs.Add(new Organ("Lung", 3.0, new CapacityContainer 
        { 
            Breathing = 1.0 
        }, isExternal: false));

        // Digestive organs
        body.Organs.Add(new Organ(OrganNames.Liver, 4.0, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        body.Organs.Add(new Organ(OrganNames.Stomach, 3.0, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        parts.Add(body);

        return parts;
    }

    public static List<MajorBodyPart> CreateArachnidBody()
    {
        var parts = new List<MajorBodyPart>();

        // CEPHALOTHORAX - 40% coverage (head and thorax combined)
        var cephalothorax = new MajorBodyPart("Cephalothorax", 40.0);
        cephalothorax.Bone.Toughness = 12; // Chitin is quite tough
        
        // Brain
        cephalothorax.Organs.Add(new Organ(OrganNames.Brain, 0.3, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Multiple eyes - spiders typically have 8 eyes
        for (int i = 1; i <= 8; i++)
        {
            cephalothorax.Organs.Add(new Organ($"Eye {i}", 0.2, new CapacityContainer 
            { 
                Sight = 0.125 // Each contributes 1/8th of total sight
            }, isExternal: true));
        }

        // Heart
        cephalothorax.Organs.Add(new Organ(OrganNames.Heart, 3.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        parts.Add(cephalothorax);

        // ABDOMEN - 20% coverage
        var abdomen = new MajorBodyPart("Abdomen", 20.0);
        
        // Book lungs (spiders have book lungs instead of regular lungs)
        abdomen.Organs.Add(new Organ("Book Lungs", 2.0, new CapacityContainer 
        { 
            Breathing = 1.0 
        }, isExternal: false));

        // Digestive organs
        abdomen.Organs.Add(new Organ("Digestive System", 3.0, new CapacityContainer 
        { 
            Digestion = 1.0 
        }, isExternal: false));

        parts.Add(abdomen);

        // LEGS - 8 legs, 5% coverage each
        for (int i = 1; i <= 8; i++)
        {
            var leg = new MajorBodyPart($"Leg {i}", 5.0);
            parts.Add(leg);
        }

        return parts;
    }

    public static List<MajorBodyPart> CreateFlyingBody()
    {
        var parts = new List<MajorBodyPart>();

        // HEAD - 12% coverage
        var head = new MajorBodyPart("Head", 12.0);
        head.Bone.Toughness = 8; // Lighter bones for flight
        
        // Brain
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes - excellent vision for flying
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.7 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.7 
        }, isExternal: true));

        // Ears - excellent hearing
        head.Organs.Add(new Organ(OrganNames.LeftEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.7 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.7 
        }, isExternal: true));

        parts.Add(head);

        // TORSO - 30% coverage
        var torso = new MajorBodyPart("Torso", 30.0);
        torso.Bone.Toughness = 8; // Hollow bones
        
        // Heart - larger for flight demands
        torso.Organs.Add(new Organ(OrganNames.Heart, 6.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Lungs - highly efficient
        torso.Organs.Add(new Organ(OrganNames.LeftLung, 4.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));
        
        torso.Organs.Add(new Organ(OrganNames.RightLung, 4.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));

        // Digestive organs
        torso.Organs.Add(new Organ(OrganNames.Liver, 3.5, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        torso.Organs.Add(new Organ(OrganNames.Stomach, 2.5, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        parts.Add(torso);

        // WINGS - 15% each
        var leftWing = new MajorBodyPart("Left Wing", 15.0);
        var rightWing = new MajorBodyPart("Right Wing", 15.0);
        // Wings are primarily for movement
        
        parts.AddRange([leftWing, rightWing]);

        // LEGS - 6.5% each  
        var leftLeg = new MajorBodyPart("Left Leg", 6.5);
        var rightLeg = new MajorBodyPart("Right Leg", 6.5);

        parts.AddRange([leftLeg, rightLeg]);

        return parts;
    }
}================================================================================

File: ./Bodies/BodyPartTargeter.cs
--------------------------------------------------------------------------------
using System.Net.WebSockets;
using System.Security;
using text_survival.Bodies;

public static class BodyPartTargetingHelper
{
    public static List<MajorBodyPart> GetAllMajorParts(Body body)
    {
        return body.Parts;
    }

    public static List<Organ> GetAllOrgans(Body body)
    {
        return GetAllMajorParts(body).SelectMany(p => p.Organs).ToList();
    }

    public static List<Tissue> GetAllTissues(Body body)
    {
        List<Tissue> tissues = [];
        GetAllMajorParts(body).ForEach(p => tissues.AddRange(GetTissues(p)));
        return tissues;
    }

    public static List<Tissue> GetTissues(MajorBodyPart part)
    {
        return [part.Skin, part.Bone, part.Muscle];
    }

    public static List<Organ> GetOrgans(MajorBodyPart part)
    {
        return part.Organs;
    }
}================================================================================

File: ./IO/Input.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.IO
{
    public static class Input
    {
        private static ManualResetEvent manualResetEvent = new ManualResetEvent(false);
        // private static string userInput;
        // public static void OnUserInputReceived(string input)
        // {
        //     userInput = input;
        //     manualResetEvent.Set();
        // }
        public static string Read()
        {
            string? input = "";
            if (Config.io == Config.IOType.Console)
            {
                input = Console.ReadLine();
            }
            else if (Config.io == Config.IOType.Web)
            {
                // await user input from web
                //input = AwaitInput();
                throw new NotImplementedException();
            }

            return input ?? "";
        }

        // public static string AwaitInput()
        // {
        //     manualResetEvent.WaitOne();
        //     manualResetEvent.Reset();
        //     return userInput;
        // }

        public static int ReadInt()
        {
            while (true)
            {
                string? input = Read();
                if (int.TryParse(input, out int result))
                {
                    return result;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number.\n");
                }
            }
        }

        public static int ReadInt(int low, int high)
        {
            while (true)
            {
                int input = ReadInt();
                if (input >= low && input <= high)
                {
                    Output.WriteLine();
                    return input;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number between ", low, " and ", high, ".\n");
                }
            }
        }

        public static bool ReadYesNo()
        {
            while (true)
            {
                string? input = Read().Trim().ToLower();
                if (input == "y" || input == "yes")
                {
                    return true;
                }
                else if (input == "n" || input == "no")
                {
                    return false;
                }
                else
                {
                    Output.Write("Invalid input. Please enter 'y' or 'n'.\n");
                }
            }
        }

        public static T? GetSelectionFromList<T>(List<T> list, bool cancelOption = false, string cancelMessage = "Cancel")
        {
            list.ForEach(i =>
            {
                if (i != null) Output.WriteLine(list.IndexOf(i) + 1, ". ", i);
            });

            int input;
            if (cancelOption)
            {
                Output.WriteLine(0, ". ", cancelMessage);
                input = ReadInt(0, list.Count);
                if (input == 0)
                {
                    return default;
                }
            }
            else
            {
                input = ReadInt(1, list.Count);
            }

            return list[input - 1];
        }
    }
}
================================================================================

File: ./IO/Output.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actions;
using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival.IO
{
    public static class Output
    {
        public static int SleepTime = 200;
        public static ConsoleColor DetermineTextColor(object x)
        {
            return x switch
            {
                string => ConsoleColor.White,
                int or float or double => ConsoleColor.Green,
                Npc => ConsoleColor.Red,
                Item => ConsoleColor.Cyan,
                Container => ConsoleColor.Yellow,
                Player => ConsoleColor.Green,
                Zone => ConsoleColor.Blue,
                Location => ConsoleColor.DarkBlue,
                Enum => ConsoleColor.Gray,
                IGameAction => ConsoleColor.White,
                null => ConsoleColor.Red,
                _ => ConsoleColor.Red,
            };
        }

        public static void Write(params object[] args)
        {
            foreach (var arg in args)
            {
                string text = GetFormattedText(arg);
                if (Console.ForegroundColor == ConsoleColor.White)
                {
                    Console.ForegroundColor = DetermineTextColor(arg);
                }
                Console.Write(text);
                Console.ForegroundColor = ConsoleColor.White;
                Thread.Sleep(SleepTime);
            }
        }

        private static string GetFormattedText(params object[] args)
        {
            string result = string.Empty;

            foreach (var arg in args)
            {
                switch (arg)
                {
                    case float f:
                        result += $"{f:F1}";
                        break;
                    case double d:
                        result += $"{d:F1}";
                        break;
                    case null:
                        result += "[NULL]";
                        break;
                    default:
                        result += arg.ToString();
                        break;
                }
            }
            return result;

        }

        public static void WriteLine(params object[] args)
        {
            Write(args);
            Write("\n");
        }


        public static void WriteWarning(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Yellow;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        public static void WriteDanger(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Red;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        internal static void WriteSuccess(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Green;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }
    }
}
================================================================================

File: ./Program.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;
using text_survival.Events;
using text_survival.IO;
using text_survival.Items;
using text_survival.Actions;

namespace text_survival
{
    public class Program
    {
        static void Main()
        {
            Output.SleepTime = 500;
            Output.WriteLine("You wake up in the forest, with no memory of how you got there.");
            Output.WriteLine("Light snow is falling, and you feel the air getting colder.");
            Output.WriteLine("You need to find shelter, food, and water to survive.");
            Output.SleepTime = 10;
            Zone zone = ZoneFactory.MakeForestZone();
            Container oldBag = new Container("Old bag", 10);
            Location startingArea = new Location("Clearing", zone);
            oldBag.Add(ItemFactory.MakeKnife());
            oldBag.Add(ItemFactory.MakeMoccasins());
            oldBag.Add(ItemFactory.MakeLeatherTunic());
            oldBag.Add(ItemFactory.MakeLeatherPants());
            startingArea.Containers.Add(oldBag);
            zone.Locations.Add(startingArea);
            Player player = new Player(startingArea);
            World.Player = player;

            EventBus.Subscribe(new StarvingEventHandler());
            EventBus.Subscribe(new DehydrationEventHandler());
            EventBus.Subscribe(new ExhaustionEventHandler());
            EventBus.Subscribe(new StoppedStarvingEventHandler());
            EventBus.Subscribe(new StoppedDehydrationEventHandler());
            EventBus.Subscribe(new StoppedExhaustionEventHandler());
            EventBus.Subscribe(new BodyHotEventHandler());
            EventBus.Subscribe(new BodyColdEventHandler());


            var defaultAction = ActionFactory.Common.MainMenu();
            while (true)
            {
                var context = new GameContext(player); // todo need to update the location context
                defaultAction.Execute(context);
            }
        }
    }
}================================================================================

File: ./Survival/ThirstModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.Events;
using text_survival.IO;

namespace text_survival.Survival
{
    public class ThirstModule
    {
        public bool IsParched => Amount >= Max;
        private double Rate = 4000F / (24F * 60F); // mL per minute
        private double Max = 3000.0F; // mL
        private double Amount { get; set; }
        public ThirstModule()
        {
            Amount = Max / 2; 
        }
        public void AddHydration(double mL)
        {
            Amount += mL;
            if (Amount >= Max)
            {
                Amount = Max;
            }
        }
        public void Update()
        {
            Amount -= Rate;
            if (Amount <= 0)
                Amount = 0;
        }
        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("| Hydration: ", percent, "%");
        }
    }
}================================================================================

File: ./Survival/TemperatureModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Events;
using text_survival.IO;

namespace text_survival.Survival;

public class TemperatureModule(Body owner)
{
    private readonly Body owner = owner;
    private double BodyTemperature => owner.BodyTemperature;
    private bool IsWarming;
    private TemperatureEnum TemperatureEffect = TemperatureEnum.Warm;

    private const double BaseBodyTemperature = 98.6F;
    private const double SevereHypothermiaThreshold = 89.6; // °F
    private const double HypothermiaThreshold = 95.0;  // °F
    private const double HyperthermiaThreshold = 99.5; // °F  

    private enum TemperatureEnum
    {
        Warm,
        Cool,
        Cold,
        Freezing,
        Hot,
    }

    public void Update(double environmentalTemp, double equipmentInsulation)
    {
        double naturalInsulation = Math.Clamp(owner.CalculateColdResistance(), 0, 1); // 0-1
        double totalInsulation = Math.Clamp(naturalInsulation + equipmentInsulation, 0, 0.95);

        double skinTemp = BodyTemperature - 8.4;
        double tempDifferential = environmentalTemp - skinTemp;
        double insulatedDiff = tempDifferential * (1 - totalInsulation);
        double tempDiffMagnitude = Math.Abs(insulatedDiff);
        double baseRate = 1.0 / 120.0;
        double exponentialFactor = 1.0 + (tempDiffMagnitude / 40.0);
        double rate = baseRate * exponentialFactor;

        // double surfaceAreaFactor = Math.Pow(body.Weight / 70.0, -0.2);

        double tempChange = insulatedDiff * rate;
        owner.BodyTemperature += tempChange;

        IsWarming = tempChange > 0;

        UpdateTemperatureEffect();
    }


    private void UpdateTemperatureEffect()
    {
        TemperatureEnum oldTemperature = TemperatureEffect;

        // Normal body temperature, no effects
        if (BodyTemperature >= BaseBodyTemperature && BodyTemperature <= HyperthermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Warm;
        }
        else if (BodyTemperature >= HypothermiaThreshold && BodyTemperature < BaseBodyTemperature)
        {
            TemperatureEffect = TemperatureEnum.Cool;
        }

        else if (BodyTemperature > SevereHypothermiaThreshold && BodyTemperature <= HypothermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Cold;
            EventBus.Publish(new BodyColdEvent(owner, oldTemperature != TemperatureEffect));
        }
        else if (BodyTemperature < SevereHypothermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Freezing;
            EventBus.Publish(new BodyColdEvent(owner, oldTemperature != TemperatureEffect));
        }
        else if (BodyTemperature > HyperthermiaThreshold)
        {
            TemperatureEffect = TemperatureEnum.Hot;
            EventBus.Publish(new BodyHotEvent(owner, oldTemperature != TemperatureEffect));
        }
    }


    public void Describe()
    {
        string tempChange = IsWarming ? "Warming up" : "Getting colder";
        Output.WriteLine("| Body Temperature: ", BodyTemperature, "°F (", TemperatureEffect, "), ", tempChange);
    }
}
================================================================================

File: ./Survival/HungerModule.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Bodies;
using text_survival.Events;
using text_survival.IO;

namespace text_survival.Survival;


public class HungerModule(Body owner)
{
	private const double MAX_CALORIES = 2000.0; // Maximum calories stored before fat conversion
	private bool IsStarving => CurrentCalories <= 0;
	private bool wasStarving;
	private double CurrentCalories { get; set; } = MAX_CALORIES / 2;
	private readonly Body owner = owner;

	public void Update(double metabolicRate)
	{
		// todo, actually update with activity level
		// todo have this account for temp too

		double calories = metabolicRate / 24 / 60;  //* timePassed.TotalHours;

		CurrentCalories -= calories;

		if (IsStarving)
		{
			double excessCalories = -CurrentCalories;
			CurrentCalories = 0;
			EventBus.Publish(new StarvingEvent(owner, excessCalories, isNew: !wasStarving));
		}
		else if (wasStarving)
		{
			EventBus.Publish(new StoppedStarvingEvent(owner));
		}
		wasStarving = IsStarving;
	}

	public void AddCalories(double calories)
	{
		CurrentCalories += calories;

		if (CurrentCalories > MAX_CALORIES)
		{
			double excessCalories = CurrentCalories - MAX_CALORIES;
			EventBus.Publish(new CalorieSurplusEvent(owner, excessCalories));
			CurrentCalories = MAX_CALORIES;
		}
	}

	public void Describe()
	{
		double percent = (int)(CurrentCalories / MAX_CALORIES * 100);
		Output.WriteLine("| Calorie Store: ", percent, "%");
	}
}
================================================================================

File: ./Survival/ExhaustionModule.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Survival
{
    public class ExhaustionModule
    {
        public bool IsExhausted => Amount >= Max;
        public bool IsFullyRested => Amount <= 0;
        public double ExhaustionPercent => (Amount / Max) * 100;
        private double Rate = 1;
        private double Max = 480.0F; // minutes (8 hours)
        public double Amount { get; private set; }

        public ExhaustionModule()
        {
            Amount = 0;
        }

        public void Rest(int minutes)
        {
            Amount -= minutes * Rate;
            if (Amount < 0)
            {
                Amount = 0;
            }
        }

        public void ModifyExhaustion(double minutes)
        {
            Amount += minutes;
            if (Amount > Max)
            {
                Amount = Max;
            }
        }

        public void Update()
        {
            Amount += Rate;
            if (Amount >= Max)
            {
                Amount = Max;
            }
        }

        public void Describe()
        {
            double percent = (int)((Amount / Max) * 100);
            Output.WriteLine("| Exhaustion: ", percent, "%");
        }
    }
}================================================================================

File: ./World.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;

namespace text_survival
{
    public static class World
    {
        public static TimeOnly Time { get; set; } = new TimeOnly(hour: 9, minute: 0);

        public static Player? Player { get; set; }
        public static void Update(int minutes)
        {
            for (int i = 0; i < minutes; i++)
            {
                Player?.Update();
                Player?.CurrentZone.Update();
                Time = Time.AddMinutes(1);
            }
        }

        public enum TimeOfDay
        {
            Night,
            Dawn,
            Morning,
            Afternoon,
            Noon,
            Evening,
            Dusk
        }

        public static TimeOfDay GetTimeOfDay()
        {
            return Time.Hour switch
            {
                < 5 => TimeOfDay.Night,
                < 6 => TimeOfDay.Dawn,
                < 11 => TimeOfDay.Morning,
                < 13 => TimeOfDay.Noon,
                < 17 => TimeOfDay.Afternoon,
                < 20 => TimeOfDay.Evening,
                < 21 => TimeOfDay.Dusk,
                _ => TimeOfDay.Night
            };
        }

    }
}
================================================================================

File: ./Utils/Utils.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Utils
    {
        private static readonly Random random = new Random(DateTime.Now.Millisecond);

        static Utils()
        {
            random = new Random(DateTime.Now.Millisecond);
        }

        public static int Roll(int sides)
        {
            return random.Next(1, sides + 1);
        }

        public static bool DetermineSuccess(double chance)
        {
            return (random.NextDouble() < chance);
        }

        public static int RandInt(int low, int high)
        {
            return random.Next(low, high + 1);
        }

        public static float RandFloat(float low, float high)
        {
            return (float)random.NextDouble() * (high - low) + low;
        }

        public static double RandDouble(double low, double high)
        {
            return random.NextDouble() * (high - low) + low;
        }

        public static bool FlipCoin()
        {
            return random.Next(2) == 0;
        }

        public static T? GetRandomEnum<T>() where T : Enum
        {
            Array values = Enum.GetValues(typeof(T));
            return (T?)values.GetValue(Roll(values.Length) - 1);
        }

        public static T GetRandomFromList<T>(List<T> list)
        {
            if (list.Count == 0)
            {
                throw new Exception("List is empty.");
            }
            return list[Roll(list.Count) - 1];
        }
        
    public static T GetRandomWeighted<T>(IDictionary<T, double> choices)
    {
        if (choices == null || choices.Count == 0)
            throw new ArgumentException("Cannot select from an empty collection", nameof(choices));
            
        double totalWeight = choices.Sum(pair => pair.Value);
        if (totalWeight <= 0)
            throw new ArgumentException("Total weight must be positive", nameof(choices));
            
        double roll = random.NextDouble() * totalWeight;
        
        double cumulativeWeight = 0;
        foreach (var pair in choices)
        {
            cumulativeWeight += pair.Value;
            if (roll <= cumulativeWeight)
                return pair.Key;
        }
        
        // This should never happen if weights are positive
        return choices.Keys.Last();
    }
    }
}
================================================================================

File: ./Utils/WeightedTable.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival;

public class GenericWeightedTable<T> where T : class
{
    protected Dictionary<Func<T>, double> weightedFactories = [];

    public GenericWeightedTable() { }
    public void AddFactory(Func<T> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual T GenerateRandom()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)();
    }
}

public class LootTable : GenericWeightedTable<Item>
{
    public void AddItem(Func<Item> itemFactory, double weight = 1)
    {
        AddFactory(itemFactory, weight);
    }

    public Item GenerateRandomItem()
    {
        return base.GenerateRandom();
    }
}

public class LocationTable
{
    protected Dictionary<Func<Zone, Location>, double> weightedFactories = [];

    public void AddFactory(Func<Zone, Location> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual Location GenerateRandom(Zone parent)
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)(parent);
    }
}


public class NpcTable : GenericWeightedTable<Npc>
{
    public void AddActor(Func<Npc> actorFactory, double weight = 1)
    {
        AddFactory(actorFactory, weight);
    }
}================================================================================

File: ./Magic/SpellFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;

namespace text_survival.Magic
{
  public static class SpellFactory
  {
    public static Spell MinorHeal => new Spell("Minor Heal",
                                                  EffectBuilderExtensions
                                                    .CreateEffect("bleed spell")
                                                    .Healing(10)
                                                    .Build(),
                                                  true);
    public static Spell Bleeding => new Spell("Bleeding",
                                              EffectBuilderExtensions
                                                .CreateEffect("bleed spell")
                                                .Bleeding(10)
                                                .WithDuration(60)
                                                .Build(),
                                              false);
    public static Spell Poison => new Spell("Poison",
                                              EffectBuilderExtensions
                                                .CreateEffect("poison spell")
                                                .Poisoned(5)
                                                .WithDuration(180)
                                                .Build(),
                                              false);
  }
}
================================================================================

File: ./Magic/Spell.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;

namespace text_survival.Magic;

public class Spell
{
    public string Name { get; private set; }
    public bool NeedsTargetPart { get; private set; }
    private Effect Effect { get; }


    public Spell(string name, Effect effect, bool needsTargetPart)
    {
        Name = name;
        Effect = effect;
        NeedsTargetPart = needsTargetPart;
    }

    public void Cast(Actor target)
    {
        target.ApplyEffect(Effect);
    }
    public void Cast(Actor target, MajorBodyPart part)
    {
        Effect.TargetBodyPart = part;
        target.ApplyEffect(Effect);
    }

    public override string ToString()
    {
        return Name;
    }


}
================================================================================

File: ./Config.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival
{
    public static class Config
    {
        public enum IOType
        {
            Console,
            Web
        }
        public static IOType io = IOType.Console;

        public static double NOTIFY_EXISTING_STATUS_CHANCE = .05;
    }
}
================================================================================

File: ./Environments/Location.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.Environments;

public class Location
{
    public string Name;
    public bool Visited = false;
    public bool IsFound { get; set; } = false;
    public IReadOnlyList<Npc> Npcs =>_npcs.AsReadOnly();
    private List<Npc> _npcs = [];
    public List<Item> Items = [];
    public List<Container> Containers = [];
    virtual public Zone Parent { get; }
    public List<LocationFeature> Features = [];

    #region Initialization

    public Location(string name, Zone parent)
    {
        Name = name;
        Parent = parent;
        NpcSpawner = new();
    }

    public T? GetFeature<T>() where T : LocationFeature => Features.OfType<T>().FirstOrDefault();

    public void SpawnNpcs(int numNpcs)
    {
        for (int i = 0; i < numNpcs; i++)
        {
            var npc = NpcSpawner.GenerateRandom();
            if (npc is not null)
            {
                _npcs.Add(npc);
                npc.CurrentLocation = this;
            }
        }
    }
    public virtual NpcTable NpcSpawner { get; set; }


    #endregion Initialization
    public void Interact(Player player)
    {
        Output.WriteLine("You consider heading to the " + Name + "...");
        Output.WriteLine("Do you want to go there? (y/n)");
        if (Input.ReadYesNo())
        {
            player.CurrentLocation = this;
        }
        else
        {
            Output.WriteLine("You decide to stay.");
        }
    }
    
    public double GetTemperature()
    {
        // Get zone's weather temperature (in Fahrenheit)
        double zoneTemp = Parent.Weather.TemperatureInFahrenheit;

        // Start with this base temperature
        double locationTemp = zoneTemp;

        // ------ STEP 1: Apply inherent location modifiers ------
        double overheadCoverage = 0;
        double windProtection = 0;
        var locationType = GetFeature<EnvironmentFeature>();
        if (locationType != null)
        {
            locationTemp += locationType.TemperatureModifier;
            overheadCoverage = locationType.NaturalOverheadCoverage;
            windProtection = locationType.NaturalWindProtection;
        }

        // ------ STEP 2: Apply weather exposure effects ------
        // Wind chill when windy
        double effectiveWindSpeed = 0;
        if (Parent.Weather.WindSpeed > 0.1) // Only significant wind
        {
            effectiveWindSpeed = Parent.Weather.WindSpeed * (1 - windProtection);
            double windSpeedMph = effectiveWindSpeed * 30; // Scale 0-1 to approx mph
            locationTemp = CalculateWindChillNWS(locationTemp, windSpeedMph);
        }

        // Sun warming effects during daytime with clear skies
        double sunIntensity = Parent.Weather.SunlightIntensity;
        double sunExposure = 1 - overheadCoverage;
        // Sun can add up to 10°F on a cold day
        double sunWarming = sunIntensity * sunExposure * 10;

        // Sun effect is more noticeable when cold
        double temperatureAdjustment = sunWarming * Math.Max(0.5, Math.Min(1, (50 - locationTemp) / 30));
        locationTemp += temperatureAdjustment;

        // Precipitation effects
        double precipitation = Parent.Weather.Precipitation;
        precipitation *= 1 - overheadCoverage;
        // todo, determine if this effects temp directly or if we use this elsewhere 
        double precipitationCooling = precipitation * 5; //  simple up to 5°F cooling for now
        locationTemp -= precipitationCooling * (1 - overheadCoverage);

        // ------ STEP 3: Apply shelter effects if present ------
        double insulation = 0;
        var shelter = GetFeature<ShelterFeature>();
        if (shelter != null)
        {
            // Start with minimum temperature a shelter can maintain (in °F)
            double minShelterTemp = 40; // About 4.4°C, what a good shelter can maintain from body heat
            // Calculate warming effect based on insulation quality
            double tempDifference = minShelterTemp - locationTemp;
            insulation = Math.Clamp(shelter.TemperatureInsulation, 0, .9); // cap at 90%
            insulation *= 1 - (precipitation * .3); // precipitation can reduce insulation up to 30%
            insulation *= 1 - (effectiveWindSpeed * .3); // and wind another 30 on top of that

            locationTemp += tempDifference * insulation;
        }

        // If there's a heat source, add its effect
        var heatSource = GetFeature<HeatSourceFeature>();
        if (heatSource != null && heatSource.IsActive)
        {
            // Insulation increases effectiveness of heat sources
            double heatEffect = heatSource.HeatOutput * Math.Max(insulation, .40); // heat sources are less effective outside
            locationTemp += heatEffect;
        }

        return locationTemp;
    }

    public double CalculateWindChillNWS(double temperatureF, double windSpeedMph)
    {
        // NWS formula is only valid for temperatures <= 50°F and wind speeds >= 3 mph
        if (temperatureF > 50 || windSpeedMph < 3)
        {
            return temperatureF;
        }
        // Calculate using the NWS Wind Chill Temperature (WCT) formula
        // https://www.weather.gov/media/epz/wxcalc/windChill.pdf
        // WCT = 35.74 + 0.6215T - 35.75(V^0.16) + 0.4275T(V^0.16)
        // Where T = Air Temperature (°F), V = Wind Speed (mph)
        double windPowFactor = Math.Pow(windSpeedMph, 0.16);
        return 35.74 + (0.6215 * temperatureF) - (35.75 * windPowFactor) + (0.4275 * temperatureF * windPowFactor);
    }

    public void Update()
    {
        // Locations.ForEach(i => i.Update());
        _npcs.ForEach(n => n.Update());
    }

    public List<Location> GetNearbyLocations()
    {
        List<Location> nearbyLocations = [];
        if (Parent.Locations.Count > 0)
        {
            foreach (var location in Parent.Locations)
            {
                if (location == this)
                    continue;
                nearbyLocations.Add(location);
            }
        }
        return nearbyLocations;
    }

    public override string ToString() => Name;
}================================================================================

File: ./Environments/LocationFeatures.cs/EnvironmentFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class EnvironmentFeature : LocationFeature
{
    public enum LocationType
    {
        OpenPlain,      // No natural shelter
        Forest,         // Trees provide some wind/rain protection
        Cave,           // Natural temperature moderation
        Cliff,          // Wind protection from one direction
        RiverBank,      // Water nearby, but exposure
        HighGround      // More wind but better visibility
    }
    private LocationType Type;
    public double TemperatureModifier { get; } = 0; // degrees F adjustment
    public double NaturalOverheadCoverage { get; } = 0;
    public double NaturalWindProtection { get; } = 0;

    public EnvironmentFeature(Location location, double tempModifier, double overheadCoverage, double windProtection) : base("shelter", location)
    {
        TemperatureModifier = tempModifier;
        NaturalOverheadCoverage = overheadCoverage;
        NaturalWindProtection = windProtection;
    }
    public EnvironmentFeature(Location location, LocationType type)
        : base("locationType", location)
    {
        Type = type;

        switch (type)
        {
            case LocationType.Forest:
                NaturalWindProtection = 0.4;     // 40% wind reduction
                NaturalOverheadCoverage = 0.3;   // 30% precipitation protection
                TemperatureModifier = 3.0;       // 3°F warmer in winter, cooler in summer
                break;

            case LocationType.Cave:
                NaturalWindProtection = 0.9;     // 90% wind protection
                NaturalOverheadCoverage = 0.95;  // 95% precipitation protection
                TemperatureModifier = 15.0;      // 15°F warmer in winter, cooler in summer
                break;

            case LocationType.Cliff:
                NaturalWindProtection = 0.6;     // 60% wind protection
                NaturalOverheadCoverage = 0.2;   // 20% precipitation protection
                TemperatureModifier = 2.0;       // 2°F temperature moderation
                break;

            case LocationType.RiverBank:
                NaturalWindProtection = 0.1;     // 10% wind protection
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -2.0;      // 2°F cooler from water proximity
                break;

            case LocationType.HighGround:
                NaturalWindProtection = -0.2;    // 20% increased wind
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -4.0;      // 4°F cooler from elevation
                break;

            case LocationType.OpenPlain:
            default:
                NaturalWindProtection = 0.0;
                NaturalOverheadCoverage = 0.0;
                TemperatureModifier = 0.0;
                break;
        }
    }

    // Get description of the location type
    public string GetDescription()
    {
        return Type switch
        {
            LocationType.Forest => "A forest with trees providing some shelter from the elements.",
            LocationType.Cave => "A cave offering protection from wind and precipitation.",
            LocationType.Cliff => "A cliff face providing some protection from the wind.",
            LocationType.RiverBank => "The bank of a river, exposed but with access to water.",
            LocationType.HighGround => "Higher elevation with increased exposure to wind.",
            LocationType.OpenPlain => "An open area with no natural protection.",
            _ => "An undefined location type."
        };
    }

}================================================================================

File: ./Environments/LocationFeatures.cs/ForageFeature.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;
using text_survival.Items;

namespace text_survival.Environments;

public class ForageFeature(Location location, double resourceDensity = 1) : LocationFeature("forage", location)
{
    private double baseResourceDensity = resourceDensity;
    private int numberOfHoursForaged = 0;
    private Dictionary<Func<Item>, double> resourceRarities = [];
    private double ResourceDensity => baseResourceDensity / (numberOfHoursForaged + 1);

    public void Forage(int hours)
    {
        // todo: change the order of operations here
        List<Item> itemsFound = [];
        foreach (Func<Item> factory in resourceRarities.Keys)
        {
            double chance = ResourceDensity * resourceRarities[factory];

            for (int i = 0; i < hours; i++)
            {
                if (Utils.DetermineSuccess(chance))
                {
                    var item = factory();
                    Output.Write("You found: ", item);
                    item.IsFound = true;
                    ParentLocation.Items.Add(item);
                    numberOfHoursForaged++;
                }
            }
        }
        World.Update(hours * 60);
    }

    public void AddResource(Func<Item> factory, double rarity)
    {
        resourceRarities.Add(factory, rarity);
    }
}
================================================================================

File: ./Environments/LocationFeatures.cs/LocationFeature.cs
--------------------------------------------------------------------------------

using text_survival.Survival;

namespace text_survival.Environments;

public abstract class LocationFeature
{
    public string Name { get; private set; }
    protected Location ParentLocation { get; private set; }
    public LocationFeature(string name, Location location)
    {
        Name = name;
        ParentLocation = location;
    }
    // public virtual void Initialize() { }
    // public virtual void Update() { }
}



================================================================================

File: ./Environments/LocationFeatures.cs/ShelterFeature.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ShelterFeature : LocationFeature
{
    // todo add enums and presets like environment features
    public double TemperatureInsulation { get; } = 0; // ambient temp protection 0-1
    public double OverheadCoverage { get; } = 0; // rain / snow / sun protection 0-1
    public double WindCoverage { get; } = 0; // wind protection 0-1
    // public double Durability {get; private}
    public ShelterFeature(Location location, double tempInsulation, double overheadCoverage, double windCoverage) : base("shelter", location)
    {
        TemperatureInsulation = tempInsulation;
        OverheadCoverage = overheadCoverage;
        WindCoverage = windCoverage;
    }
    
}================================================================================

File: ./Environments/LocationFeatures.cs/HeatSourceFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class HeatSourceFeature : LocationFeature
{
    public bool IsActive { get; private set; }
    public double HeatOutput { get; private set; } // In Fahrenheit
    public double FuelRemaining { get; private set; } // 0-1 scale
    public double FuelConsumptionRate { get; private set; } // Per hour
    
    public HeatSourceFeature(Location location, double heatOutput = 15.0) 
        : base("heatSource", location)
    {
        IsActive = false;
        HeatOutput = heatOutput; // Default 15°F increase
        FuelRemaining = 0;
        FuelConsumptionRate = 0.1; // 10% per hour
    }
    
    public void AddFuel(double amount)
    {
        FuelRemaining = Math.Min(1.0, FuelRemaining + amount);
        
        // Activate if adding fuel to inactive source
        if (!IsActive && FuelRemaining > 0)
            IsActive = true;
    }
    
    // Update for fuel consumption
    public void Update(TimeSpan elapsed)
    {
        if (!IsActive || FuelRemaining <= 0)
            return;
            
        // Calculate fuel consumption
        double hoursElapsed = elapsed.TotalHours;
        double fuelUsed = FuelConsumptionRate * hoursElapsed;
        
        FuelRemaining = Math.Max(0, FuelRemaining - fuelUsed);
        
        // Deactivate if out of fuel
        if (FuelRemaining <= 0)
            IsActive = false;
    }
    
    // Manually activate/deactivate
    public void SetActive(bool active)
    {
        // Can only activate if there's fuel
        if (active && FuelRemaining > 0)
            IsActive = true;
        else if (!active)
            IsActive = false;
    }
}================================================================================

File: ./Environments/Zone.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class Zone
    {
        public string Name { get; }
        public string Description { get; }
        public bool Visited = false;
        private double BaseTemperature { get; }
        public int Elevation { get; }
        public virtual List<Location> Locations { get; } = [];
        private LocationTable LocationTable;
        public ZoneWeather Weather;


        public Zone(string name, string description, LocationTable locationTable, double baseTemp = 20, int elevation = 0)
        {
            Name = name;
            Description = description;
            BaseTemperature = baseTemp;
            Elevation = elevation;
            LocationTable = locationTable;
            Weather = new(this);
            if (!LocationTable.IsEmpty())
            {
                for (int i = 0; i < 3; i++)
                {
                    Locations.Add(LocationTable.GenerateRandom(this));
                }
            }

        }

        public void Update()
        {
            Locations.ForEach(x => x.Update());
        }

        public override string ToString() => Name;

    }
}
================================================================================

File: ./Environments/WorldMap.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class WorldMap
    {
        private Dictionary<(int, int), Zone> map = new();

        private int X;
        private int Y;

        public WorldMap(Zone startingZone)
        {
            X = 0;
            Y = 0;
            map.Add((X, Y), startingZone);
            startingZone.Visited = true;
        }

        public Zone CurrentZone => GetZone(X, Y);
        public Zone North => GetZone(X, Y + 1);
        public Zone South => GetZone(X, Y - 1);
        public Zone East => GetZone(X + 1, Y);
        public Zone West => GetZone(X - 1, Y);


        public void MoveNorth() => MoveTo(X, Y + 1);
        public void MoveSouth() => MoveTo(X, Y - 1);
        public void MoveEast() => MoveTo(X + 1, Y);
        public void MoveWest() => MoveTo(X - 1, Y);


        private void MoveTo(int x, int y)
        {
            Zone zone = GetZone(x, y) ?? throw new Exception("Invalid zone.");
            X = x;
            Y = y;
            zone.Visited = true;
        }

        private Zone GetZone(int x, int y)
        {
            Zone? zone = map.GetValueOrDefault((x, y));
            if (zone == null)
            {
                zone = GenerateRandomZone();
                map.Add((x, y), zone);
            }
            return zone;
        }

        private Zone GenerateRandomZone()
        {
            // todo
            return Utils.GetRandomFromList([ZoneFactory.MakeForestZone(), ZoneFactory.MakeCaveSystemZone()]);
        }

    }
}
================================================================================

File: ./Environments/ZoneFactory.cs
--------------------------------------------------------------------------------
namespace text_survival.Environments;

public static class ZoneFactory
{
    public static Zone MakeForestZone(string name = "", string description = "", double baseTemp = 20)
    {
        // Create a location table specifically for forest locations
        LocationTable forestLocationTable = new LocationTable();
        
        // Add various forest location types with appropriate weights
        forestLocationTable.AddFactory(LocationFactory.MakeForest, 3.0); // Most common
        
        // You can add more forest-related locations here when implemented
        // forestLocationTable.AddFactory(LocationFactory.MakeTrail, 2.0);
        // forestLocationTable.AddFactory(LocationFactory.MakeRiverbank, 1.5);
        // forestLocationTable.AddFactory(LocationFactory.MakeHillside, 1.0);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> forestZoneNames = ["Forest", "Woods", "Woodland", "Taiga", "Wildwood", "Timberland", "Pine Forest", "Birch Forest"];
            List<string> forestZoneAdjectives = [
                "", "Deep", "Ancient", "Verdant", "Mysterious", "Shadowy", "Enchanted", "Wild", "Dark", "Dense", 
                "Northern", "Southern", "Eastern", "Western", "Frozen", "Boreal", "Glacial", "Snowy", "Frost-rimmed", 
                "Ice-laden", "Primeval", "Rime-covered", "Mammoth", "Misty", "Foggy"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(forestZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(forestZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> forestDescriptions = [
                "A vast expanse of snow-covered trees stretching as far as the eye can see.",
                "Frost-covered trees with icicles hanging from branches, filtering weak sunlight to the forest floor.",
                "A quiet forest with the occasional sounds of wildlife echoing through the icy stillness.",
                "Evergreen trees stand tall amidst the snow, creating a sanctuary for cold-adapted creatures.",
                "A sprawling woodland with ice-crusted paths winding between ancient trees and frozen undergrowth.",
                "Mammoth trails wind between the massive tree trunks, where herds seek shelter from the harsh winds.",
                "Rime-covered trees glisten in the pale light, their branches laden with snow and ice.",
                "The forest floor is covered with a thick blanket of snow, punctuated by animal tracks.",
                "Shadows stretch long across the pristine snow as sunlight filters through the dense canopy.",
                "Ancient pines stand as sentinels, their needles heavy with frost and snow."
            ];
            
            description = Utils.GetRandomFromList(forestDescriptions);
        }
        
        // Create and return the forest zone
        return new Zone(name, description, forestLocationTable, baseTemp);
    }
    
    public static Zone MakeCaveSystemZone(string name = "", string description = "", double baseTemp = 10)
    {
        // Create a location table specifically for cave system locations
        LocationTable caveLocationTable = new LocationTable();
        
        // Add various cave location types with appropriate weights
        caveLocationTable.AddFactory(LocationFactory.MakeCave, 3.0); // Most common
        
        // You can add more cave-related locations here when implemented
        // caveLocationTable.AddFactory(LocationFactory.MakeTrail, 1.0); // Cave entrance trails
        // caveLocationTable.AddFactory(LocationFactory.MakeHillside, 1.5); // Cave entrances in hillsides
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> caveZoneNames = [
                "Cave System", "Caverns", "Underground Complex", "Grotto Network", "Subterranean Labyrinth",
                "Cave Refuge", "Ice Caverns", "Shelter System", "Hibernation Caves", "Painted Caves"
            ];
            List<string> caveZoneAdjectives = [
                "", "Deep", "Ancient", "Crystal", "Mysterious", "Dark", "Echoing", "Forgotten", "Hidden", "Vast", "Winding",
                "Frost-lined", "Ice-walled", "Glacial", "Ancestral", "Bone-filled", "Mammoth", "Protected", "Ritual",
                "Clan", "Fur-lined", "Warm", "Painted", "Firelit"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(caveZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(caveZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> caveDescriptions = [
                "A maze of dark tunnels and chambers offering refuge from the harsh ice age climate.",
                "A network of interconnected caves with icicles and ice formations hanging from the ceiling.",
                "Warm, sheltered caverns with the sound of meltwater dripping echoing in the darkness.",
                "An intricate system of underground passages formed by ancient glacial movements.",
                "A sprawling subterranean network with chambers used by clans for shelter and ritual.",
                "Cave walls adorned with ancient paintings depicting mammoth hunts and clan ceremonies.",
                "Floors littered with bones and artifacts from generations of human habitation.",
                "Narrow passages opening to large chambers where fires have burned for countless seasons.",
                "Ancestral shelters where generations have found protection from the deadly cold.",
                "Ice-rimmed entrances leading to surprisingly warm chambers deep within the earth."
            ];
            
            description = Utils.GetRandomFromList(caveDescriptions);
        }
        
        // Create and return the cave system zone with cooler base temperature
        return new Zone(name, description, caveLocationTable, baseTemp);
    }
    
    public static Zone MakeTundraZone(string name = "", string description = "", double baseTemp = 0)
    {
        // Create a location table specifically for tundra locations
        LocationTable tundraLocationTable = new LocationTable();
        
        // Add various tundra location types with appropriate weights
        tundraLocationTable.AddFactory(LocationFactory.MakePlain, 4.0); // Most common
        // tundraLocationTable.AddFactory(LocationFactory.MakeHillside, 2.0);
        // tundraLocationTable.AddFactory(LocationFactory.MakeRiverbank, 1.5);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> tundraZoneNames = [
                "Tundra", "Steppe", "Plains", "Mammoth Plains", "Permafrost", "Ice Fields", 
                "Frozen Expanse", "Glacier Edge", "Frost Plains", "Hunting Grounds"
            ];
            List<string> tundraZoneAdjectives = [
                "", "Vast", "Windswept", "Endless", "Frozen", "Desolate", "Barren", "Ancient", 
                "Mammoth", "Glacial", "Northern", "Pristine", "Inhospitable", "Snow-covered", 
                "Primal", "Harsh", "Woolly", "Thundering", "Game-rich", "Megafauna"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(tundraZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(tundraZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> tundraDescriptions = [
                "An endless expanse of snow and ice, where mighty herds of woolly mammoth roam.",
                "Windswept plains stretching to the horizon, where only the hardiest plants survive.",
                "Wide open spaces where great herds of ice age megafauna gather to graze.",
                "A harsh landscape dominated by permafrost and spotted with patches of tough grasses.",
                "Snow-covered plains where saber-toothed predators stalk their mammoth prey.",
                "Vast open tundra where the wind howls unimpeded across the frozen landscape.",
                "The thunder of mammoth herds can be heard across these ancient hunting grounds.",
                "A stark but beautiful landscape of ice, snow, and occasional hardy vegetation.",
                "Glacial plains carved by the retreating ice sheet, leaving a harsh but life-filled realm.",
                "The domain of the woolly mammoth, where these giants travel in family groups across the snow."
            ];
            
            description = Utils.GetRandomFromList(tundraDescriptions);
        }
        
        // Create and return the tundra zone with much colder base temperature
        return new Zone(name, description, tundraLocationTable, baseTemp);
    }
    
    public static Zone MakeRiverValleyZone(string name = "", string description = "", double baseTemp = 15)
    {
        // Create a location table specifically for river valley locations
        LocationTable riverValleyLocationTable = new LocationTable();
        
        // Add various river valley location types with appropriate weights
        riverValleyLocationTable.AddFactory(LocationFactory.MakeRiverbank, 4.0); // Most common
        // riverValleyLocationTable.AddFactory(LocationFactory.MakeForest, 2.0); // Riverside forests
        // riverValleyLocationTable.AddFactory(LocationFactory.MakeHillside, 1.5); // Valley sides
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> riverZoneNames = [
                "River Valley", "Waterway", "Glacial Valley", "River Basin", "Floodplain", 
                "Stream Network", "River Lands", "Meltwater Valley", "River Territory"
            ];
            List<string> riverZoneAdjectives = [
                "", "Winding", "Frozen", "Ancient", "Deep", "Fertile", "Ice-carved", "Glacier-fed", 
                "Protected", "Sheltered", "Resource-rich", "Fish-filled", "Life-giving", "Abundant",
                "Clay-rich", "Game-rich", "Meandering", "Mammoth-crossed"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(riverZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(riverZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> riverDescriptions = [
                "A network of glacier-fed rivers and streams cutting through the icy landscape.",
                "Partially frozen waterways that provide essential resources for all life in the region.",
                "A river valley carved by ancient glacial movements, now home to diverse ice age life.",
                "Ice-rimmed waters flowing through a sheltered valley, attracting animals from miles around.",
                "A life-giving river system where clay, fish, and fresh water can be harvested.",
                "Mammoth herds gather along these banks to drink and bathe in the cold waters.",
                "The sound of rushing water breaks the winter silence as the river cuts through ice and snow.",
                "A critical resource in the frozen world, this river network sustains countless creatures.",
                "Ancient humans have left traces of their camps along these fertile riverbanks for generations.",
                "Where ice meets flowing water, creating a unique ecosystem in the frozen landscape."
            ];
            
            description = Utils.GetRandomFromList(riverDescriptions);
        }
        
        // Create and return the river valley zone with slightly warmer base temperature
        return new Zone(name, description, riverValleyLocationTable, baseTemp);
    }
    
    // // Method to create a complete ice age world with multiple zones
    // public static List<Zone> CreateIceAgeWorld()
    // {
    //     List<Zone> world = new List<Zone>();
        
    //     // Create various zones with ice age appropriate base temperatures
    //     Zone forestZone = MakeForestZone(baseTemp: 10); // Colder than default
    //     world.Add(forestZone);
        
    //     Zone caveZone = MakeCaveSystemZone(baseTemp: 5); // Even colder caves
    //     world.Add(caveZone);
        
    //     Zone tundraZone = MakeTundraZone(); // Already very cold (0)
    //     world.Add(tundraZone);
        
    //     Zone riverValleyZone = MakeRiverValleyZone(baseTemp: 8); // Slightly warmer than surroundings but still cold
    //     world.Add(riverValleyZone);
        
    //     return world;
    // }
}================================================================================

File: ./Environments/Weather.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ZoneWeather
{

    // todo: improve sunrise and sunset logic,
    // todo: add more continuity and state to more granular changes
    public double BaseTemperature { get; private set; } // In Celsius
    public WeatherCondition CurrentCondition { get; private set; }
    public double Precipitation { get; private set; } // 0-1 intensity
    public double WindSpeed { get; private set; }    // 0-1 intensity
    public double CloudCover { get; private set; }   // 0-1 coverage

    // Season tracking
    public enum Season { Winter, Spring, Summer, Fall }
    public Season CurrentSeason { get; private set; } = Season.Fall; // Start in fall

    // Weather conditions for Ice Age Europe
    public enum WeatherCondition
    {
        Clear,      // Clear, cold skies
        Cloudy,     // Overcast conditions
        Misty,      // Low visibility with moisture
        LightSnow,  // Light snowfall (common in Ice Age)
        Rainy,      // Cold rain (uncommon but possible)
        Blizzard,   // Heavy snow with wind (dangerous)
        Stormy      // Thunderstorms (rare, mostly summer)
    }

    // Add to ZoneWeather class
    public double SunlightIntensity
    {
        get
        {
            // No sun at night
            if (!IsDaytime())
                return 0;

            // Base sun intensity from time of day
            double timeOfDayFactor = GetSunIntensityByTime();

            // Reduction factors from weather conditions
            double cloudReduction = CloudCover * 0.9; // Clouds block up to 90% of sunlight

            // Additional reduction based on weather condition
            double conditionReduction = CurrentCondition switch
            {
                WeatherCondition.Misty => 0.6,
                WeatherCondition.Blizzard => 0.9,
                WeatherCondition.LightSnow => 0.3,
                WeatherCondition.Rainy => 0.5,
                WeatherCondition.Stormy => 0.8,
                _ => 0.0
            };
            // Calculate final intensity (0-1)
            double baseIntensity = timeOfDayFactor * (1 - cloudReduction);
            return baseIntensity * (1 - conditionReduction);
        }
    }

    private bool IsDaytime()
    {
        // todo: flesh this out and combine it with the temperature cycle 
        int hour = World.Time.Hour;

        // Seasonal variation in daylight hours
        int sunriseHour, sunsetHour;

        switch (CurrentSeason)
        {
            case Season.Winter:
                sunriseHour = 8;  // Late sunrise
                sunsetHour = 16;  // Early sunset
                break;
            case Season.Spring:
            case Season.Fall:
                sunriseHour = 6;  // Normal sunrise
                sunsetHour = 18;  // Normal sunset
                break;
            case Season.Summer:
                sunriseHour = 4;  // Early sunrise
                sunsetHour = 20;  // Late sunset
                break;
            default:
                sunriseHour = 6;
                sunsetHour = 18;
                break;
        }

        return hour >= sunriseHour && hour < sunsetHour;
    }

    private double GetSunIntensityByTime()
    {
        // Get sun intensity purely based on time of day (0-1)
        int hour = World.Time.Hour;
        int minute = World.Time.Minute;

        // No sunlight before sunrise or after sunset
        if (!IsDaytime())
            return 0;

        // Convert to minutes since sunrise (0-720)
        double minutesSinceSunrise = ((hour - 6) * 60) + minute;
        double dayLengthMinutes = 12 * 60; // 12 hours of daylight

        // Calculate angle for sine function (0 to π over the day)
        double angle = (minutesSinceSunrise / dayLengthMinutes) * Math.PI;

        // Sine wave peaks at noon (6 hours after sunrise)
        return Math.Sin(angle);
    }

    // Time and update tracking
    private TimeSpan _weatherDuration;
    private TimeSpan _timeSinceChange = TimeSpan.Zero;

    // Zone this weather belongs to
    private Zone _zone;

    public ZoneWeather(Zone zone)
    {
        _zone = zone;

        // Initialize with fall weather
        BaseTemperature = 0; // 0°C is about 32°F - freezing point
        CurrentCondition = WeatherCondition.Clear;
        Precipitation = 0;
        WindSpeed = 0.3; // Moderate wind - 30% of maximum
        CloudCover = 0.3; // Light clouds - 30% coverage

        _weatherDuration = TimeSpan.FromHours(6);
    }

    public void Update(TimeSpan elapsed)
    {
        _timeSinceChange += elapsed;

        // Time to change weather?
        if (_timeSinceChange >= _weatherDuration)
        {
            GenerateNewWeather();
            _timeSinceChange = TimeSpan.Zero;
        }
    }

    private void GenerateNewWeather()
    {
        // Generate new weather conditions based on season and zone
        // Determine base temperature range for season
        double minTemp, maxTemp;
        double precipChance;
        double snowRatio; // Chance of precipitation being snow vs rain

        switch (CurrentSeason)
        {
            case Season.Winter:
                minTemp = -30; // -30°C (-22°F) extreme winter low
                maxTemp = -5;  // -5°C (23°F) winter "warm" day
                precipChance = 0.2; // 20% chance of precipitation
                snowRatio = 0.95;   // 95% of precip is snow in winter
                break;

            case Season.Spring:
                minTemp = -15; // -15°C (5°F) cold spring night
                maxTemp = 5;   // 5°C (41°F) mild spring day
                precipChance = 0.25; // 25% chance of precipitation
                snowRatio = 0.6;    // 60% of precip is snow in spring
                break;

            case Season.Summer:
                minTemp = -5;  // -5°C (23°F) cold summer night
                maxTemp = 15;  // 15°C (59°F) warm summer day
                precipChance = 0.15; // 15% chance of precipitation
                snowRatio = 0.2;    // 20% of precip is snow in summer
                break;

            case Season.Fall:
                minTemp = -10; // -10°C (14°F) cold fall night
                maxTemp = 5;   // 5°C (41°F) mild fall day
                precipChance = 0.2;  // 20% chance of precipitation
                snowRatio = 0.7;    // 70% of precip is snow in fall
                break;

            default:
                minTemp = -15;
                maxTemp = 0;
                precipChance = 0.2;
                snowRatio = 0.8;
                break;
        }

        // Apply zone-specific modifications
        if (_zone.Elevation > 0)
        {
            // Higher elevation = colder (-0.6°C per 100m elevation)
            double elevationEffect = _zone.Elevation * -0.006; // -0.6% per 100m
            minTemp += elevationEffect;
            maxTemp += elevationEffect;
        }

        // Get time of day temperature modifier (0-1 scale)
        double timeOfDayFactor = GetTimeOfDayFactor();

        // Calculate random temperature within range, biased toward colder
        // For example: With Spring (-15°C to 5°C) at noon (factor=1.0):
        // Temperature range = -15 + (5-(-15)) * random(0,0.8) * 1.0 = -15 to +1°C
        double temperatureRange = maxTemp - minTemp;
        double randomFlux = Utils.RandDouble(0, 1);

        BaseTemperature = minTemp + (temperatureRange * randomFlux * timeOfDayFactor);

        // Determine weather condition
        if (Utils.RandDouble(0, 1) < precipChance) // Precipitation check (0.15-0.25 chance)
        {
            // Determine type of precipitation
            double snowVsRainRoll = Utils.RandDouble(0, 1);

            if (snowVsRainRoll < snowRatio) // Snow event
            {
                // Determine if blizzard (rare) or light snow (common)
                if (Utils.RandDouble(0, 1) < 0.15) // 15% of snow events are blizzards
                {
                    CurrentCondition = WeatherCondition.Blizzard;
                    Precipitation = Utils.RandDouble(0.7, 1.0); // 70-100% intensity
                    WindSpeed = Utils.RandDouble(0.7, 1.0);     // 70-100% of max wind
                    CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                }
                else
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.6); // 20-60% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.5);     // 20-50% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
                }
            }
            else // Rain event (uncommon in Ice Age)
            {
                // Only happens when temperature is above freezing
                if (BaseTemperature > 0)
                {
                    // Determine if stormy (very rare) or rainy
                    if (CurrentSeason == Season.Summer && Utils.RandDouble(0, 1) < 0.1) // 10% of summer rain is storms
                    {
                        CurrentCondition = WeatherCondition.Stormy;
                        Precipitation = Utils.RandDouble(0.6, 0.9); // 60-90% intensity
                        WindSpeed = Utils.RandDouble(0.5, 0.8);     // 50-80% of max wind
                        CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(2); // 1-3 hours
                    }
                    else
                    {
                        CurrentCondition = WeatherCondition.Rainy;
                        Precipitation = Utils.RandDouble(0.3, 0.6); // 30-60% intensity
                        WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                        CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                    }
                }
                else // Temperature too cold for rain, adjust to snow
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.5); // 20-50% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(5); // 1-9 hours
                }
            }
        }
        else // No precipitation
        {
            // Choose between clear, cloudy or misty
            double clearVsCloudyRoll = Utils.RandDouble(0, 1);

            if (clearVsCloudyRoll < 0.4) // 40% chance for clear
            {
                CurrentCondition = WeatherCondition.Clear;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.1, 0.5);     // 10-50% of max wind
                CloudCover = Utils.RandDouble(0, 0.2);      // 0-20% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(9); // 1-17 hours
            }
            else if (clearVsCloudyRoll < 0.8) // 40% chance for cloudy
            {
                CurrentCondition = WeatherCondition.Cloudy;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.2, 0.6);     // 20-60% of max wind
                CloudCover = Utils.RandDouble(0.5, 0.8);    // 50-80% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
            }
            else // 20% chance for misty
            {
                CurrentCondition = WeatherCondition.Misty;
                Precipitation = Utils.RandDouble(0, 0.1);   // 0-10% light moisture
                WindSpeed = Utils.RandDouble(0, 0.2);       // 0-20% of max wind
                CloudCover = Utils.RandDouble(0.6, 0.9);    // 60-90% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(3); // 1-5 hours
            }
        }
    }

    private TimeSpan GenerateRandomWeatherDuration(int typicalHours = 6)
    {
        // int minHours = 1; // using roll instead which has 1 as default
        int maxHours = (typicalHours * 2) - 1;

        // triangular distribution - similar to normal dist, 
        // where values in the center are more common and extremes are rare
        // kind of like rolling dice, it's rare to roll 3 ones or 3 sixes
        int r1 = Utils.Roll(maxHours);
        int r2 = Utils.Roll(maxHours);
        int r3 = Utils.Roll(maxHours);
        double sum = r1 + r2 + r3;
        double average = sum / 3.0;
        int minutes = (int)(average * 60);
        return TimeSpan.FromMinutes(minutes);
    }

    private double GetTimeOfDayFactor()
    {
        // Returns 0-1 value representing relative temperature (0=coldest, 1=warmest)
        // todo combine this with seasonal day/ night lengths
        int minutesInDay = 24 * 60;
        int coldestTime = 4 * 60; // 4 AM

        int currentMinute = World.Time.Hour * 60 + World.Time.Minute;
        double minSinceColdest = currentMinute - coldestTime;
        double percentOfDay = minSinceColdest / minutesInDay; // scale so .5 is warmest and 0/1 is coldest
        double radians = 2 * Math.PI * percentOfDay; // scale for Cos

        // cos(x) => -1 to 1, but we need to shift to 0-1 so divide by 2 and shift up by 
        // but also the cos function needs to be flipped since cos(0 or 1) = 1, but we want 0 and 1 to be the min, so just * -1
        double temperature = -1 * (Math.Cos(radians) / 2) + .5; // Cos results in -1 to 1, so scale to 0-1 (divide 2, shift)

        return temperature;
    }

    // Convert Celsius to Fahrenheit
    public double TemperatureInFahrenheit => (BaseTemperature * 9 / 5) + 32;

    // Get detailed weather description
    public string GetWeatherDescription()
    {
        string temp = GetTemperatureDescription();
        string conditions = GetConditionsDescription();
        string wind = GetWindDescription();

        return $"{temp} {conditions} {wind}";
    }

    private string GetTemperatureDescription()
    {
        if (BaseTemperature < -25)
            return "It's brutally cold.";
        else if (BaseTemperature < -15)
            return "It's extremely cold.";
        else if (BaseTemperature < -5)
            return "It's very cold.";
        else if (BaseTemperature < 0)
            return "It's freezing cold.";
        else if (BaseTemperature < 5)
            return "It's cold.";
        else if (BaseTemperature < 10)
            return "It's cool.";
        else
            return "It's mild."; // As warm as it gets in Ice Age
    }

    private string GetConditionsDescription()
    {
        switch (CurrentCondition)
        {
            case WeatherCondition.Clear:
                return "The sky is clear.";

            case WeatherCondition.Cloudy:
                return "The sky is cloudy and gray.";

            case WeatherCondition.Misty:
                return "A cold mist hangs in the air.";

            case WeatherCondition.Rainy:
                if (Precipitation < 0.5)
                    return "A cold drizzle is falling.";
                else
                    return "Cold rain is falling steadily.";

            case WeatherCondition.LightSnow:
                if (Precipitation < 0.3)
                    return "A few snowflakes drift through the air.";
                else
                    return "Snow is falling steadily.";

            case WeatherCondition.Blizzard:
                return "A blizzard rages with heavy snow and wind.";

            case WeatherCondition.Stormy:
                return "A thunderstorm rumbles overhead.";

            default:
                return "";
        }
    }

    private string GetWindDescription()
    {
        if (WindSpeed < 0.2)           // 0-20%
            return "The air is still.";
        else if (WindSpeed < 0.4)      // 20-40%
            return "A light breeze blows.";
        else if (WindSpeed < 0.6)      // 40-60%
            return "A cold wind blows steadily.";
        else if (WindSpeed < 0.8)      // 60-80%
            return "Strong, bitter winds howl across the landscape.";
        else                           // 80-100%
            return "Powerful, freezing gusts threaten to knock you over.";
    }

    // Set season
    public void SetSeason(Season season)
    {
        CurrentSeason = season;
        GenerateNewWeather(); // Update weather for new season
    }
}


================================================================================

File: ./Environments/LocationFactory.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments;

public static class LocationFactory
{
    public static Location MakeForest(Zone parent)
    {
        // Create a base forest location
        Location location = new Location("Forest", parent);

        // Generate a more descriptive name with ice age theme
        List<string> forestNames = ["Forest", "Woodland", "Grove", "Thicket", "Pine Stand", "Birch Grove"];
        List<string> forestAdjectives = [
            "Frost-bitten", "Snow-laden", "Ice-coated", "Permafrost", "Glacial", "Silent", "Frozen", "Snowy",
            "Windswept", "Frigid", "Boreal", "Primeval", "Shadowy", "Ancient", "Taiga",
             "Frosty", "Dark", "Foggy", "Overgrown",
            "Dense", "Old", "Misty", "Quiet", "Pristine", "Forgotten", "Cold", "Verdant", "Mossy", "Wet"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(forestAdjectives);
        string name = Utils.GetRandomFromList(forestNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with high resource density for forests (1.2)
        ForageFeature forageFeature = new ForageFeature(location, 1.2);

        // Add natural resources to the forage feature - more forest-appropriate items
        forageFeature.AddResource(ItemFactory.MakeBerry, 5.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeWater, 2.0);     // Available but not as common
        forageFeature.AddResource(ItemFactory.MakeMushroom, 4.0);  // Common in forests
        forageFeature.AddResource(ItemFactory.MakeStick, 8.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFirewood, 4.0);   // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 3.0);     // Fairly common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for forest
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Forest));

        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomForestItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);   // Common
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Rare
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (40% chance)
        if (Utils.DetermineSuccess(.5))
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            location.SpawnNpcs(npcCount);
        }

        return location;
    }

    public static Location MakeCave(Zone parent)
    {
        // Create a base cave location
        Location location = new Location("Cave", parent);

        // Generate a more descriptive name with ice age theme
        List<string> caveNames = ["Cave", "Cavern", "Grotto", "Hollow", "Shelter"];
        List<string> caveAdjectives = [
            "Icicle-lined", "Frost-rimmed", "Ice-floored", "Bone-strewn", "Mammoth-bone", "Winding", "Ancient",
            "Hidden", "Ancestral", "Painted", "Rocky", "Echoing", "Ice-walled", "Hibernation",
            "Crystal-ice", "Glacier-carved", "Frosty", "Icy",
            "Dark", "Shadowy", "Damp", "Deep", "Frozen", "Narrow", "Secluded",
            "Granite",  "Glowing",  "Cold", "Crystal", "Protected"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(caveAdjectives);
        string name = Utils.GetRandomFromList(caveNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with moderate resource density for caves (0.8)
        ForageFeature forageFeature = new ForageFeature(location, 0.8);

        // Add resources to the forage feature - cave-appropriate items
        forageFeature.AddResource(ItemFactory.MakeMushroom, 3.0);  // Can find mushrooms in caves
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 2.0);     // More common in caves
        forageFeature.AddResource(ItemFactory.MakeClay, 1.0);      // Near cave entrances
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.3); // Rare but valuable

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for cave
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cave));

        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomCaveItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeSpider, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeRat, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeBat, 4.0);
        npcSpawner.AddActor(NpcFactory.MakeCaveBear, 0.5);
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (50% chance)
        if (Utils.RandInt(0, 9) < 5)
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            location.SpawnNpcs(npcCount);
        }

        return location;
    }

    public static Location MakeRiverbank(Zone parent)
    {
        // Create a base riverbank location
        Location location = new Location("Riverbank", parent);

        // Generate a more descriptive name with ice age theme
        List<string> riverNames = ["River", "Stream", "Creek", "Brook", "Rapids", "Ford", "Ice-Melt", "Waterfall", "Shallows"];
        List<string> riverAdjectives = [
            "Ice-rimmed", "Glacial", "Snowmelt", "Half-frozen", "Ice-flow", "Narrow", "Mammoth-crossing",
            "Frozen-edged", "Icy", "Slush-filled", "Ice-bridged", "Cold", "Mist-shrouded", "Foggy", "Glacier-fed",
            "Thawing", "Crystalline", "Ice-dammed", "Frigid", "Quiet", "Thundering", "Bone-strewn", "Glistening",
            "Rushing", "Flowing", "Clear", "Muddy", "Wide", "Rocky", "Sandy", "Shallow", "Deep",
            "Misty", "Meandering", "Winding", "Fast-flowing", "Gentle", "Noisy", "Bubbling"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(riverAdjectives);
        string name = Utils.GetRandomFromList(riverNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with good resource density for riverbanks (1.1)
        ForageFeature forageFeature = new ForageFeature(location, 1.1);

        // Add resources to the forage feature - river-appropriate items
        forageFeature.AddResource(ItemFactory.MakeWater, 10.0);    // Very abundant
        forageFeature.AddResource(ItemFactory.MakeFish, 6.0);      // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 4.0);     // Common near water
        forageFeature.AddResource(ItemFactory.MakeClay, 5.0);      // Common at riverbanks
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // River stones
        forageFeature.AddResource(ItemFactory.MakeFlint, 1.0);     // Occasionally found

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for riverbank
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.RiverBank));

        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomRiverbankItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner for riverbanks
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 2.0);   // Predators come to water
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Bears fish at rivers
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (30% chance)
        if (Utils.DetermineSuccess(.3))
        {
            location.SpawnNpcs(1);
        }

        return location;
    }

    public static Location MakePlain(Zone parent)
    {
        // Create a base plains location
        Location location = new Location("Plain", parent);

        // Generate a more descriptive name with ice age theme
        List<string> plainNames = ["Plain", "Steppe", "Tundra", "Mammoth Grounds", "Permafrost", "Glacier-edge", "Grassland", "Prairie", "Meadow"];
        List<string> plainAdjectives = [
            "Windswept", "Permafrost", "Glacial", "Frozen", "Vast", "Rolling", "Endless", "Mammoth-trampled",
            "Snow-covered", "Ice-plain", "Desolate", "Frosty", "Exposed", "Bison-grazed",
            "Bleak", "Stark", "Harsh", "Woolly", "Flat", "Frost-cracked", "Mammoth",
            "Open", "Windy", "Cold", "Barren", "Grassy", "Empty", "Rocky", "Wild"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(plainAdjectives);
        string name = Utils.GetRandomFromList(plainNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with low-moderate resource density for plains (0.7)
        ForageFeature forageFeature = new ForageFeature(location, 0.7);

        // Add resources to the forage feature - plains-appropriate items
        forageFeature.AddResource(ItemFactory.MakeRoots, 6.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeBerry, 2.0);     // Less common
        forageFeature.AddResource(ItemFactory.MakeStick, 1.0);     // Rare (few trees)
        forageFeature.AddResource(ItemFactory.MakeStone, 4.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for open plain
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.OpenPlain));

        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomPlainsItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner - plains have megafauna!
        var npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);               // Common
        npcSpawner.AddActor(NpcFactory.MakeWoollyMammoth, 0.5);      // Rare but possible
        npcSpawner.AddActor(NpcFactory.MakeSaberToothTiger, 0.7);    // Uncommon
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (40% chance)
        if (Utils.DetermineSuccess(.4))
        {
            location.SpawnNpcs(1);
        }

        return location;
    }

    public static Location MakeHillside(Zone parent)
    {
        // Create a base hillside location
        Location location = new Location("Hillside", parent);

        // Generate a more descriptive name with ice age theme
        List<string> hillNames = ["Ridge", "Moraine", "Slope", "Drift", "Crag", "Bluff", "Outcrop", "Hill", "Hillside", "Knoll"];
        List<string> hillAdjectives = [
            "Glacier-carved", "Ice-cracked", "Snow-swept", "Wind-scoured", "Ice-exposed", "Frost-heaved", "Craggy",
            "Rugged", "Snow-capped", "Icy", "Ice-scarred", "Stone", "High", "Misty", "Frost-shattered",
            "Eroded", "Ancient", "Mammoth-trail", "Granite", "Shaded", "Splintered",
            "Rocky", "Steep", "Gentle", "Windswept", "Exposed", "Barren", "Weathered",
            "Protected", "Treacherous", "Cold", "Foggy"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(hillAdjectives);
        string name = Utils.GetRandomFromList(hillNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with moderate resource density for hillsides (0.9)
        ForageFeature forageFeature = new ForageFeature(location, 0.9);

        // Add resources to the forage feature - hillside-appropriate items
        forageFeature.AddResource(ItemFactory.MakeStone, 8.0);        // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 3.0);        // More common on hillsides
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.5); // Rare but possible
        forageFeature.AddResource(ItemFactory.MakeRoots, 2.0);         // Less common
        forageFeature.AddResource(ItemFactory.MakeOchrePigment, 1.0);  // Sometimes found on hills

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for hillside (using cliff as closest match)
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cliff));

        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomHillsideItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner for hillsides
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 2.0);    // Snakes like rocky areas
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (30% chance)
        if (Utils.DetermineSuccess(.3))
        {
            location.SpawnNpcs(1);
        }

        return location;
    }

    // Helper methods to generate random location-appropriate items

    private static Item GetRandomForestItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 5.0 },
            { ItemFactory.MakeBerry, 4.0 },
            { ItemFactory.MakeStick, 8.0 },
            { ItemFactory.MakeFirewood, 5.0 },
            { ItemFactory.MakeTorch, 0.5 },
            { ItemFactory.MakeSpear, 0.2 },
            { ItemFactory.MakeHealingHerbs, 1.0 }
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomCaveItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 4.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 3.0 },
            { ItemFactory.MakeTorch, 1.0 },
            { ItemFactory.MakeBone, 4.0 },
            { ItemFactory.MakeObsidianShard, 0.5 },
            { ItemFactory.MakeOchrePigment, 0.2 }
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomRiverbankItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeWater, 8.0 },
            { ItemFactory.MakeFish, 5.0 },
            { ItemFactory.MakeClay, 6.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 2.0 },
            { ItemFactory.MakeRoots, 3.0 }
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomPlainsItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeRoots, 6.0 },
            { ItemFactory.MakeStone, 5.0 },
            { ItemFactory.MakeBone, 3.0 },
            { ItemFactory.MakeSinew, 1.0 },
            { ItemFactory.MakeBerry, 2.0 },
            { ItemFactory.MakeMammothTusk, 0.1 } // Very rare find
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomHillsideItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 5.0 },
            { ItemFactory.MakeObsidianShard, 1.0 },
            { ItemFactory.MakeOchrePigment, 2.0 },
            { ItemFactory.MakeHandAxe, 0.2 }
        };

        return Utils.GetRandomWeighted(options)();
    }
}================================================================================

