File: ./obj/Debug/net9.0/text_survival.AssemblyInfo.cs
--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("text_survival")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+18a2d1dc87c8d3fc981b7555c14962ccb1438d74")]
[assembly: System.Reflection.AssemblyProductAttribute("text_survival")]
[assembly: System.Reflection.AssemblyTitleAttribute("text_survival")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

================================================================================

File: ./obj/Debug/net9.0/text_survival.GlobalUsings.g.cs
--------------------------------------------------------------------------------
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
================================================================================

File: ./obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs
--------------------------------------------------------------------------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
================================================================================

File: ./Bodies/BodyPartTargeter.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Bodies;

public static class BodyTargetHelper
{

    public static BodyRegion? GetPartByName(Body body, string name)
    {
        return GetAllMajorParts(body).FirstOrDefault(p => p.Name == name);
    }

    public static Tissue? GetTissueByName(BodyRegion part, string name)
    {
        return GetTissues(part).FirstOrDefault(p => p.Name == name);
    }

    public static BodyRegion GetRandomMajorPartByCoverage(Body body)
    {
        var parts = GetAllMajorParts(body);
        var partChances = parts.Where(p => !p.IsDestroyed).ToDictionary(p => p, p => p.Coverage);
        return Utils.GetRandomWeighted(partChances);
    }

    public static List<BodyRegion> GetAllMajorParts(Body body)
    {
        return body.Parts;
    }

    public static List<Organ> GetAllOrgans(Body body)
    {
        return GetAllMajorParts(body).SelectMany(p => p.Organs).ToList();
    }

    public static List<Tissue> GetAllTissues(Body body)
    {
        List<Tissue> tissues = [];
        GetAllMajorParts(body).ForEach(p => tissues.AddRange(GetTissues(p)));
        GetAllOrgans(body).ForEach(tissues.Add);
        return tissues;
    }

    public static List<Tissue> GetTissues(BodyRegion part)
    {
        return [part.Skin, part.Bone, part.Muscle];
    }

    public static List<Organ> GetOrgans(BodyRegion part)
    {
        return part.Organs;
    }

    public static Organ? SelectRandomOrganToHit(BodyRegion part, double damageAmount)
    {
        // External organs can be hit even with light damage
        var externalOrgans = part.Organs.Where(o => o.IsExternal).ToList();
        if (externalOrgans.Count > 0 && damageAmount > 0)
        {
            return externalOrgans[Random.Shared.Next(externalOrgans.Count)];
        }

        // Internal organs need significant penetrating damage
        var internalOrgans = part.Organs.Where(o => !o.IsExternal).ToList();
        if (internalOrgans.Count > 0 && damageAmount > 5) // Threshold for internal damage
        {
            return internalOrgans[Random.Shared.Next(internalOrgans.Count)];
        }

        return null; // No organ hit
    }
}================================================================================

File: ./Bodies/BodyStats.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;

public class BodyStats
{
    public double BodyWeight;
	public double MuscleWeight;
	public double FatWeight;
	public double HealthPercent; // 0-1
}================================================================================

File: ./Bodies/BodyPart.cs
--------------------------------------------------------------------------------
﻿using System.ComponentModel.DataAnnotations;
using System.Runtime.CompilerServices;
using text_survival.IO;

namespace text_survival.Bodies;


public static class BodyRegionNames
{
    public const string Head = "Head";
    public const string Chest = "Chest";
    public const string Abdomen = "Abdomen";
    public const string LeftArm = "Left Arm";
    public const string RightArm = "Right Arm";
    public const string LeftLeg = "Left Leg";
    public const string RightLeg = "Right Leg";
}


public class BodyRegion(string name, double coverage)
{
    // Core properties
    public string Name { get; } = name;
    public double Coverage { get; set; } = coverage;

    // part makeup
    public Tissue Skin { get; set; } = new Tissue("Skin");
    public Tissue Muscle { get; set; } = new Muscle();
    public Tissue Bone { get; set; } = new Bone();
    public List<Organ> Organs { get; set; } = [];

    public bool IsDestroyed => Condition <= 0;
    public double Condition => AggregateCondition();

    private double AggregateCondition()
    {
        double overallCondition = 1;
        foreach (var tissue in new List<Tissue> { Skin, Muscle, Bone })
        {
            // weakest link
            overallCondition = Math.Min(overallCondition, tissue.Condition);
        }
        //todo: determine if organs should contribute 
        return overallCondition;
    }

    // public void Describe()
    // {
    //     // Calculate health percentage
    //     int healthPercent = (int)(Condition * 100); 

    //     // Determine damage severity description
    //     string damageDescription;
    //     if (healthPercent <= 0)
    //     {
    //         damageDescription = "destroyed";
    //     }
    //     else if (healthPercent < 20)
    //     {
    //         damageDescription = "critically damaged";
    //     }
    //     else if (healthPercent < 40)
    //     {
    //         damageDescription = "severely damaged";
    //     }
    //     else if (healthPercent < 60)
    //     {
    //         damageDescription = "moderately damaged";
    //     }
    //     else if (healthPercent < 80)
    //     {
    //         damageDescription = "lightly damaged";
    //     }
    //     else if (healthPercent < 100)
    //     {
    //         damageDescription = "slightly damaged";
    //     }
    //     else
    //     {
    //         damageDescription = "in perfect condition";
    //     }

    //     // Output description line
    //     Output.WriteLine($"- {Name} is {damageDescription} ({healthPercent}%)");
    // }
    public override string ToString() => Name;
}================================================================================

File: ./Bodies/AbilityCalculator.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;

public static class AbilityCalculator
{
    // unified interface that just accepts body
    public static double CalculateStrength(Body body) => CalculateStrength(body.GetBodyStats(), CapacityCalculator.GetCapacities(body));
    public static double CalculateSpeed(Body body) => CalculateSpeed(body.GetBodyStats(), CapacityCalculator.GetCapacities(body));
    public static double CalculateVitality(Body body) => CalculateVitality(body.GetBodyStats(), CapacityCalculator.GetCapacities(body));
    public static double CalculatePerception(Body body) => CalculatePerception(CapacityCalculator.GetCapacities(body));
    public static double CalculateColdResistance(Body body) => CalculateColdResistance(body.GetBodyStats());


    // actual calculator methods
    private static double CalculateStrength(BodyStats stats, CapacityContainer capacities)
    {
        // derived stats
        double bfPercent = stats.FatWeight / stats.BodyWeight;
        double musclePercent = stats.MuscleWeight / stats.BodyWeight;

        // Base strength that everyone has
        double baseStrength = 0.30; // 30% strength from structural aspects

        // Muscle contribution with diminishing returns
        double muscleContribution;
        if (musclePercent < 0.2) // Below normal
            muscleContribution = musclePercent * 2.5; // Rapid gains when building from low muscle
        else if (musclePercent < 0.4) // Normal to athletic
            muscleContribution = 0.5 + (musclePercent - 0.2) * 1.0; // Moderate gains
        else // Athletic+
            muscleContribution = 0.7 + (musclePercent - 0.4) * 0.5; // Diminishing returns

        muscleContribution += stats.MuscleWeight / 3 / 100;  // 1% bonus for every 3KG muscle

        double fatBonus = stats.FatWeight / 50 / 100; // 1% bonus for every 50KG of fat
        // Very low body fat impairs strength
        fatBonus -= (bfPercent < 0.05) ? (0.05 - bfPercent) * 3.0 : 0;

        double manipulationContribution = 0.80 + 0.20 * capacities.Manipulation; // can reduce by 20%
        double movingContribution = 0.50 + 0.50 * capacities.Moving; // can reduce by 50%
        double bloodPumping = capacities.BloodPumping; // Energy delivery - can reduce by 100%
        double bodyContribution = baseStrength + muscleContribution + fatBonus;
        return bodyContribution * movingContribution * manipulationContribution * bloodPumping;
    }

    private static double CalculateSpeed(BodyStats stats, CapacityContainer capacities)
    {
        double movingCapacity = capacities.Moving;

        // derived stats
        double baseWeight = stats.BodyWeight - stats.MuscleWeight - stats.FatWeight;
        double bfPercent = stats.FatWeight / stats.BodyWeight;
        double musclePercent = stats.MuscleWeight / stats.BodyWeight;

        // 1% faster/slower for each 1.5% difference from human baseline (30%)
        // so 50% muscle = 30% bonus
        double muscleModifier = (musclePercent - Body.BaselineHumanStats.musclePercent) / 1.5;
        muscleModifier += stats.MuscleWeight / 20 / 100; // add a 1% bonus for every 20KG of muscle


        // Minimal fat has no penalty, excess has increasing penalties
        double fatPenalty;
        if (bfPercent < 0.10)
        {
            // 10% is minimal necessary fat
            fatPenalty = -.01; // negative penalty if under 10% bf
        }
        else if (bfPercent <= Body.BaselineHumanStats.fatPercent)
        {
            fatPenalty = ((bfPercent - .10) * .20) - .01; // at baseline a 0% penalty
        }
        else
        {
            // Steeper penalty for excess, 1.5% reduction per 1% of fat 
            // 1.5(fat% - baselineFat%)
            // fat% => speed penalty (abs)
            // 20%  =>  8.5%, 
            // 30%  => 23.5%
            // 40%  => 38.5%
            // 50%  => 53.5%
            fatPenalty = (bfPercent - Body.BaselineHumanStats.fatPercent) * 1.5;
        }
        fatPenalty += stats.FatWeight / 10 / 100; // 1% penalty per 10kg of fat

        // Penalty for excess weight relative to frame (high fat and/or muscle percent)
        // -(ratio^.7 - 1)
        // ratio => penalty (abs)
        // 0.1   => +0.80
        // 0.5   => +0.38
        // 0.9   => +0.07
        // 1.5   => -0.33
        // 3.0   => -1.16
        double structuralWeightRatio = baseWeight / stats.BodyWeight / 0.45; // avg 45% structure weight
        double weightEffect = -(Math.Pow(structuralWeightRatio, 0.7) - 1.0);

        // smaller creatures are faster and larger ones are slower
        // 1 - .03(Log2(sizeRatio)) 
        // ratio => speed (multiplier)
        // 0.1 => 1.40  
        // 0.5 => 1.03   - 1/2 size means 3% faster
        // 2.0 => 0.97   - 3% slower  
        // 10. => 0.80   - 20% slower
        // 50  => 0.83
        double sizeRatio = stats.BodyWeight / Body.BaselineHumanStats.overallWeight;
        double sizeModifier = 1 - 0.03 * Math.Log(sizeRatio, 2);

        return movingCapacity * (1 + muscleModifier - fatPenalty + weightEffect) * sizeModifier;
    }
    private static double CalculateVitality(BodyStats stats, CapacityContainer capacities)
    {
        double breathing = capacities.Breathing;
        double bloodPumping = capacities.BloodPumping;
        double digestion = capacities.Digestion;

        // derived stats
        double bfPercent = stats.FatWeight / stats.BodyWeight;
        double musclePercent = stats.MuscleWeight / stats.BodyWeight;

        double organFunction = (2 * (breathing + bloodPumping) + digestion) / 5;

        // Base vitality that scales more gently with body composition
        double baseMultiplier = 0.7;  // Everyone gets 70% baseline
        double muscleContribution = musclePercent * 0.25;  // Up to 25% from muscle
        double fatContribution;

        // Essential fat is beneficial, excess isn't
        if (bfPercent < .10)
            fatContribution = bfPercent * 0.5;  // Fat is very important when low
        else if (bfPercent < .25)
            fatContribution = 0.05;  // Optimal fat gives 5%
        else
            fatContribution = 0.05 - (bfPercent - .25) * 0.1;  // Excess fat penalizes slightly

        double bodyComposition = baseMultiplier + muscleContribution + fatContribution;
        return organFunction;// * bodyComposition;
    }

    private static double CalculatePerception(CapacityContainer capacities)
    {
        double sight = capacities.Sight;
        double hearing = capacities.Hearing;

        return (sight + hearing) / 2;
    }

    private static double CalculateColdResistance(BodyStats stats)
    {
        double bfPercent = stats.FatWeight / stats.BodyWeight;

        // Base cold resistance that everyone has
        double baseColdResistance = 0.5;
        double fatInsulation;

        if (bfPercent < 0.05)
            fatInsulation = bfPercent / 0.05 * 0.1;  // Linear up to 5%
        else if (bfPercent < 0.15)
            fatInsulation = 0.1 + ((bfPercent - 0.05) / 0.1 * 0.15);  // From 0.1 to 0.25
        else
            fatInsulation = 0.25 + ((bfPercent - 0.15) * 0.15);  // Diminishing returns after 15%

        return baseColdResistance + fatInsulation;
    }
}================================================================================

File: ./Bodies/DamageInfo.cs
--------------------------------------------------------------------------------

namespace text_survival.Bodies;


// Comprehensive damage information

public enum DamageType
{
    Blunt,
    Sharp,
    Pierce,
    Poison,
    Bleed,

}
public class DamageInfo
{
    public DamageInfo() { }
    public DamageInfo(double amount,
                      DamageType type = DamageType.Blunt,
                      string? source = null,
                      string? targetPartName = null
                      )
    {
        Amount = amount;
        Type = type;
        Source = source;
        TargetPartName = targetPartName;
    }

    public double Amount { get; set; }
    public DamageType Type { get; set; } = DamageType.Blunt;
    public string? Source { get; set; }
    public string? TargetPartName { get; set; }
}

// Comprehensive healing information
public class HealingInfo
{
    public double Amount { get; set; }
    public string Type { get; set; } = "natural"; // natural, medical, magical
    public string? TargetPart { get; set; }
    public double Quality { get; set; } = 1.0; // Effectiveness multiplier
    public string? Source { get; set; }
}

================================================================================

File: ./Bodies/Body.cs
--------------------------------------------------------------------------------

using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;
using text_survival.Survival;

namespace text_survival.Bodies;

/// <summary>
/// External context that the body needs to update
/// </summary>
public class SurvivalContext
{
    public double LocationTemperature;
    public double ClothingInsulation;
    public double ActivityLevel;
}

public class Body
{
    // Root part and core properties
    public readonly bool IsPlayer = false;
    public readonly List<BodyRegion> Parts;
    public double Health => CalculateOverallHealth();

    private double CalculateOverallHealth()
    {
        // simple avg for now
        double health = Parts.Average(p => p.Condition);
        health = Parts.SelectMany(p => p.Organs.Select(o => o.Condition)).ToList().Append(health).Min();
        return health;
    }


    public double MaxHealth => 1;
    public bool IsDestroyed => Health <= 0;

    public bool IsTired => Energy > 60; // can sleep for at least 1 hr

    public readonly EffectRegistry EffectRegistry;

    private readonly double _baseWeight;

    public Body(string ownerName, BodyCreationInfo stats, EffectRegistry effectRegistry)
    {
        OwnerName = ownerName;
        IsPlayer = stats.IsPlayer;
        EffectRegistry = effectRegistry;
        Parts = BodyPartFactory.CreateBody(stats.type);

        // Initialize physical composition
        BodyFat = stats.overallWeight * stats.fatPercent;
        Muscle = stats.overallWeight * stats.musclePercent;
        _baseWeight = stats.overallWeight - BodyFat - Muscle;

        BodyTemperature = 98.6;
    }

    public double BodyFat;
    public double Muscle;

    public readonly string OwnerName;
    public double BodyFatPercentage => BodyFat / Weight;
    public double MusclePercentage => Muscle / Weight;
    public double Weight => _baseWeight + BodyFat + Muscle;
    public double BodyTemperature { get; set; }

    private double CalorieStore = 1000;
    private double Energy = 800;
    private double Hydration = 3000;

    /// <summary>
    /// Damage application rules: 
    /// 1. Body.Damage() is the only way to apply damage 
    /// 2. Body handles all targeting resolution (string -> IBodyPart)
    /// 3. Body handles damage distribution and penetration logic
    /// 4. Effects should create Damage info and pass it here 
    /// </summary>
    public void Damage(DamageInfo damageInfo)
    {
        DamageProcessor.DamageBody(damageInfo, this);
    }


    public void Heal(HealingInfo healingInfo)
    {
        // Distribute healing across damaged parts
        if (healingInfo.TargetPart != null)
        {
            var targetPart = Parts.FirstOrDefault(p => p.Name == healingInfo.TargetPart);
            if (targetPart != null)
            {
                HealBodyPart(targetPart, healingInfo);
                return;
            }
        }

        // Heal most damaged parts first
        var damagedParts = Parts
            .Where(p => p.Condition < 1.0)
            .OrderBy(p => p.Condition)
            .ToList();

        if (damagedParts.Count > 0)
        {
            HealBodyPart(damagedParts[0], healingInfo);
        }
    }

    private static void HealBodyPart(BodyRegion part, HealingInfo healingInfo)
    {
        double healingAmount = healingInfo.Amount * healingInfo.Quality;

        // Heal materials first, then organs
        var materials = new[] { part.Skin, part.Muscle, part.Bone }.Where(m => m != null);
        foreach (var material in materials)
        {
            if (material!.Condition < 1.0 && healingAmount > 0)
            {
                double heal = Math.Min(healingAmount, (1.0 - material.Condition) * material.Toughness);
                material.Condition = Math.Min(1.0, material.Condition + heal / material.Toughness);
                healingAmount -= heal;
            }
        }

        // Heal organs
        foreach (var organ in part.Organs.Where(o => o.Condition < 1.0))
        {
            if (healingAmount > 0)
            {
                double heal = Math.Min(healingAmount, (1.0 - organ.Condition) * organ.Toughness);
                organ.Condition = Math.Min(1.0, organ.Condition + heal / organ.Toughness);
                healingAmount -= heal;
            }
        }
    }

    public void Update(TimeSpan timePassed, SurvivalContext context)
    {
        var data = BundleSurvivalData();
        data.environmentalTemp = context.LocationTemperature;
        data.ColdResistance = context.ClothingInsulation;
        data.activityLevel = context.ActivityLevel;

        var result = SurvivalProcessor.Process(data, (int)timePassed.TotalMinutes, EffectRegistry.GetAll());
        UpdateBodyBasedOnResult(result);
    }


    private void UpdateBodyBasedOnResult(SurvivalProcessorResult result)
    {
        var resultData = result.Data;
        BodyTemperature = resultData.Temperature;
        CalorieStore = resultData.Calories;
        Hydration = resultData.Hydration;
        Energy = resultData.Energy;

        result.Effects.ForEach(EffectRegistry.AddEffect);

        foreach (string message in result.Messages)
        {
            string formattedMessage = message.Replace("{target}", OwnerName);
            Output.WriteLine(formattedMessage);
        }
    }

    // helper for baseline male human stats
    public static BodyCreationInfo BaselineHumanStats => new BodyCreationInfo
    {
        type = BodyTypes.Human,
        overallWeight = 75, // KG ~165 lbs
        fatPercent = .15, // pretty lean
        musclePercent = .30 // low end of athletic
    };
    public static BodyCreationInfo BaselinePlayerStats
    {
        get
        {
            var stats = BaselineHumanStats;
            stats.IsPlayer = true;
            return stats;
        }
    }
    public bool Rest(int minutes)
    {
        var data = BundleSurvivalData();
        data.activityLevel = .5; // half metabolism
        int minutesSlept = 0;
        var result = SurvivalProcessor.Sleep(data, minutes);
        UpdateBodyBasedOnResult(result);

        // just heal once at the end
        HealingInfo healing = new HealingInfo()
        {
            Amount = minutesSlept / 10,
            Type = "natural",
            Quality = Energy <= 0 ? 1 : .7, // healing quality is better after a full night's sleep
        };
        Heal(healing);

        World.Update(minutes); // need to fix, right now we are double updating

        return Energy <= 0;
    }
    public void Consume(FoodItem food)
    {
        CalorieStore += food.Calories;
        Hydration += food.WaterContent;

        if (food.HealthEffect != null)
        {
            Heal(food.HealthEffect);
        }
        if (food.DamageEffect != null)
        {
            Damage(food.DamageEffect);
        }
    }

    public SurvivalData BundleSurvivalData() => new SurvivalData()
    {
        Temperature = BodyTemperature,
        Calories = CalorieStore,
        Hydration = Hydration,
        Energy = Energy,
        BodyStats = GetBodyStats(),
    };

    public BodyStats GetBodyStats() => new BodyStats
    {
        BodyWeight = Weight,
        MuscleWeight = Muscle,
        FatWeight = BodyFat,
        HealthPercent = Health,
    };

}================================================================================

File: ./Bodies/BodyDescriber.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Survival;

namespace text_survival.Bodies
{
    public static class BodyDescriber
    {
        public static void Describe(Body body)
        {
            const int barWidth = 10;
            const int boxWidth = 65;
            // Header
            Output.WriteLine("┌", new string('─', boxWidth), "┐");
            PrintCenteredHeader("BODY STATUS");

            // Health and Body Composition (3 columns)
            Output.WriteLine("├─────────────────────┬─────────────────────┬─────────────────────┤");

            // Health row
            string healthBar = CreateProgressBar((int)(body.Health * 100), barWidth);
            string healthValueStr = $"[{healthBar}] {(int)(body.Health * 100)}%";
            string healthStatus = GetHealthStatus((int)(body.Health * 100));
            Output.WriteLine("│ Health              │ ", healthValueStr.PadRight(19), " │ ", healthStatus.PadRight(19), " │");

            // Body composition row
            string bodyCompValue = $"{Math.Round(body.Weight * 2.2, 1)} lbs";
            string bodyCompStatus = $"{(int)(body.BodyFatPercentage * 100)}% fat, {(int)(body.MusclePercentage * 100)}% muscle";
            Output.WriteLine("│ Body Composition    │ ", bodyCompValue.PadRight(19), " │ ", bodyCompStatus.PadRight(19), " │");

            // Capabilities section (4 columns)
            PrintDivider(boxWidth);
            PrintCenteredHeader("CAPABILITIES");
            PrintDivider(boxWidth);

            // Individual capabilities
            PrintCapabilityRow("Strength", AbilityCalculator.CalculateStrength(body));
            PrintCapabilityRow("Speed", AbilityCalculator.CalculateSpeed(body));
            PrintCapabilityRow("Vitality", AbilityCalculator.CalculateVitality(body));
            PrintCapabilityRow("Perception", AbilityCalculator.CalculatePerception(body));
            PrintCapabilityRow("Cold Resistance", AbilityCalculator.CalculateColdResistance(body));

            // Body parts section (if any damaged)
            var damagedParts = body.Parts.Where(p => p.Condition < 1.0).ToList();
            if (damagedParts.Count > 0)
            {
                PrintDivider(boxWidth);
                PrintCenteredHeader("BODY PARTS");
                PrintDivider(boxWidth);

                foreach (var part in damagedParts)
                {
                    PrintBodyPartRow(part);
                }
            }

            // Active effects section
            var activeEffects = body.EffectRegistry.GetAll();
            if (activeEffects.Count > 0)
            {
                PrintDivider(boxWidth);
                PrintCenteredHeader("ACTIVE EFFECTS");
                PrintDivider(boxWidth);

                foreach (var effect in activeEffects)
                {
                    PrintEffectRow(effect);
                }
            }

            Output.WriteLine("└─────────────────────┴─────────────────────┴─────────────┴───────┘");
        }

        private static void PrintCenteredHeader(string text, int width = 65)
        {
            Output.WriteLine("├", text.PadLeft((width + text.Length) / 2).PadRight(width), "┤");
        }

        private static void PrintDivider(int width)
        {
            string line = "│" + new string('─', width) + "│";
            Output.WriteLine(line);
        }
        private static void PrintCapabilityRow(string name, double value)
        {
            const int barWidth = 10;
            string bar = CreateProgressBar((int)(value * 100), barWidth);
            string valueStr = $"[{bar}] {(int)(value * 100)}%";
            string status = GetCapabilityStatus(value);

            Output.WriteLine("│ ", name.PadRight(19), " │ ", valueStr.PadRight(19), " │ ", status.PadRight(11), " │       │");
        }

        private static void PrintBodyPartRow(BodyRegion part)
        {
            const int barWidth = 10;
            string bar = CreateProgressBar((int)(part.Condition * 100), barWidth);
            string valueStr = $"[{bar}] {(int)(part.Condition * 100)}%";
            string status = GetDamageDescription(part.Condition);

            Output.WriteLine("│ ", part.Name.PadRight(19), " │ ", valueStr.PadRight(19), " │ ", status.PadRight(11), " │       │");
        }

        private static void PrintEffectRow(Effect effect)
        {
            const int barWidth = 10;
            string bar = CreateProgressBar((int)(effect.Severity * 100), barWidth);
            string trendIndicator = GetTrendIndicator(effect);
            string valueStr = $"[{bar}] {(int)(effect.Severity * 100)}%{trendIndicator}";
            string status = effect.GetSeverityDescription();
            string target = GetEffectTarget(effect);

            Output.WriteLine("│ ", effect.EffectKind.PadRight(19), " │ ", valueStr.PadRight(19), " │ ", status.PadRight(11), " │ ", target.PadRight(5), " │");
        }

        private static string CreateProgressBar(int percent, int width)
        {
            int filled = (int)(percent / 100.0 * width);
            int empty = width - filled;
            return new string('█', filled) + new string('░', empty);
        }

        private static string GetHealthStatus(int percent)
        {
            return percent switch
            {
                >= 90 => "Excellent",
                >= 75 => "Good",
                >= 50 => "Fair",
                >= 25 => "Poor",
                _ => "Critical"
            };
        }

        private static string GetCapabilityStatus(double value)
        {
            return value switch
            {
                >= 0.9 => "Excellent",
                >= 0.75 => "Good",
                >= 0.5 => "Fair",
                >= 0.25 => "Poor",
                _ => "Critical"
            };
        }

        private static string GetDamageDescription(double condition)
        {
            return condition switch
            {
                <= 0 => "Destroyed",
                < 0.2 => "Critical",
                < 0.4 => "Severe",
                < 0.6 => "Moderate",
                < 0.8 => "Light",
                _ => "Minor"
            };
        }

        private static string GetTrendIndicator(Effect effect)
        {
            if (effect.hourlySeverityChange > 0)
                return " (+)";
            else if (effect.hourlySeverityChange < 0)
                return " (-)";
            else
                return "";
        }

        private static string GetEffectTarget(Effect effect)
        {
            if (string.IsNullOrEmpty(effect.TargetBodyPart))
                return "Core";
            else
                return effect.TargetBodyPart.Length > 5 ? effect.TargetBodyPart.Substring(0, 5) : effect.TargetBodyPart;
        }



        public static void DescribeSurvivalStats(SurvivalData data)
        {
            const int boxWidth = 53;
            const int barWidth = 20;

            // Calculate percentages
            int caloriesPercent = (int)(data.Calories / SurvivalProcessor.MAX_CALORIES * 100);
            int hydrationPercent = (int)(data.Hydration / SurvivalProcessor.MAX_HYDRATION * 100);
            int energyPercent = (int)(data.Energy / SurvivalProcessor.MAX_ENERGY_MINUTES * 100);

            // Create progress bars
            string caloriesBar = CreateProgressBar(caloriesPercent, barWidth);
            string hydrationBar = CreateProgressBar(hydrationPercent, barWidth);
            string energyBar = CreateProgressBar(energyPercent, barWidth);

            // Status descriptions
            string caloriesStatus = GetCaloriesStatus(caloriesPercent);
            string hydrationStatus = GetHydrationStatus(hydrationPercent);
            string exhaustionStatus = GetEnergyStatus(energyPercent);
            string tempStatus = GetTemperatureStatus(data.Temperature);

            // Build status lines
            string healthLine = $"Food:    [{caloriesBar}] {caloriesPercent}% {caloriesStatus}";
            string waterLine = $"Water:   [{hydrationBar}] {hydrationPercent}% {hydrationStatus}";
            string energyLine = $"Energy:  [{energyBar}] {energyPercent}% {exhaustionStatus}";
            string tempLine = $"Temp:    {data.Temperature:F1}°F ({tempStatus})";

            // Display with proper padding
            Output.WriteLine($"┌{new string('─', boxWidth)}┐");
            Output.WriteLine($"│ {healthLine,-(boxWidth - 2)} │");
            Output.WriteLine($"│ {waterLine,-(boxWidth - 2)} │");
            Output.WriteLine($"│ {energyLine,-(boxWidth - 2)} │");
            Output.WriteLine($"│ {tempLine,-(boxWidth - 2)} │");
            Output.WriteLine($"└{new string('─', boxWidth)}┘");
        }

        private static string GetCaloriesStatus(int percent)
        {
            return percent switch
            {
                >= 80 => "Well Fed",
                >= 60 => "Satisfied",
                >= 40 => "Peckish",
                >= 20 => "Hungry",
                _ => "Starving"
            };
        }

        private static string GetHydrationStatus(int percent)
        {
            return percent switch
            {
                >= 80 => "Hydrated",
                >= 60 => "Fine",
                >= 40 => "Thirsty",
                >= 20 => "Parched",
                _ => "Dehydrated"
            };
        }

        private static string GetEnergyStatus(int percent)
        {
            return percent switch
            {
                >= 90 => "Energized",
                >= 80 => "Alert",
                >= 40 => "Normal",
                >= 30 => "Tired",
                >= 20 => "Very Tired",
                _ => "Exhausted"
            };
        }

        private static string GetTemperatureStatus(double temp)
        {
            return temp switch
            {
                >= 100 => "Feverish",
                >= 99 => "Hot",
                >= 97 => "Normal",
                >= 95 => "Cool",
                _ => "Cold"
            };
        }
    }

}================================================================================

File: ./Bodies/Tissue.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;

public class Tissue(string name, double toughness = 1)
{
    public string Name { get; } = name;
    public double Condition { get; set; } = 1.0;
    public double Toughness { get; set; } = toughness;

    public virtual CapacityContainer GetBaseCapacities() => new(); // Most tissues don't provide base capacities    
    public virtual CapacityContainer GetConditionMultipliers()
    {
        {
            // Default: condition affects everything equally
            return new CapacityContainer
            {
                Moving = Condition,
                Manipulation = Condition,
                Breathing = Condition,
                BloodPumping = Condition,
                Consciousness = Condition,
                Sight = Condition,
                Hearing = Condition,
                Digestion = Condition
            };
        }
    }

    // Protection multipliers for different damage types
    public double BluntMultiplier { get; set; } = 1.0;
    public double SharpMultiplier { get; set; } = 1.0;
    public double PierceMultiplier { get; set; } = 1.0;

    public double GetProtection(DamageType damageType)
    {
        // protection provided to sub layers
        double baseProtection = Toughness * Condition;

        return damageType switch
        {
            DamageType.Blunt => baseProtection * BluntMultiplier,
            DamageType.Sharp => baseProtection * SharpMultiplier,
            DamageType.Pierce => baseProtection * PierceMultiplier,
            _ => baseProtection
        };
    }

    public double GetNaturalAbsorption(DamageType damageType)
    {
        double baseThreshold = Name switch
        {
            OrganNames.Heart => 8,
            OrganNames.Brain => 6,
            OrganNames.LeftLung or OrganNames.RightLung => 10,
            OrganNames.Liver => 5,
            _ => 1
        };

        return damageType switch
        {
            DamageType.Blunt => baseThreshold,
            DamageType.Sharp => baseThreshold * 0.4,
            DamageType.Pierce => baseThreshold * 0.2,
            _ => baseThreshold * 0.6
        };
    }
}

class Muscle() : Tissue("Muscle", 1)
{
    
     public override CapacityContainer GetBaseCapacities()
    {
        // Muscle contributes to physical capacities
        return new CapacityContainer
        {
            Moving = 1,        // Each muscle group adds to movement
            Manipulation = 1,  // Each muscle group adds to manipulation
        };
    }
    public override CapacityContainer GetConditionMultipliers()
    {
        // Muscle primarily affects movement and manipulation
        return new CapacityContainer
        {
            Moving = Condition,
            Manipulation = Condition,
            // Other capacities get minimal impact
            Breathing = 0.8 + (Condition * 0.2),
            BloodPumping = 0.9 + (Condition * 0.1),
            Consciousness = 1.0,
            Sight = 1.0,
            Hearing = 1.0,
            Digestion = 1.0
        };
    }
}

class Bone() : Tissue("Bone", 10)
{
    public override CapacityContainer GetConditionMultipliers()
    {
        return new CapacityContainer
        {
            Moving = Condition * Condition, // squared, small impact near 1, exponential debuff approaching 0
            Manipulation = Condition,
            BloodPumping = 0.8 + (0.2 * Condition),
            // Other capacities get minimal impact
            Breathing = 1.0,
            Consciousness = 1.0,
            Sight = 1.0,
            Hearing = 1.0,
            Digestion = 1.0
        };
    }
}
================================================================================

File: ./Bodies/BodyCreationInfo.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;

/// <summary>
/// Struct to keep the actor constructors clean
/// </summary>
public struct BodyCreationInfo
{
    public BodyTypes type;
    public double overallWeight; // KG
    public double fatPercent; // 0-1
    public double musclePercent; // 0-1
    public bool IsPlayer;
}


public enum BodyTypes
{
    Human,
    Quadruped,
    Serpentine,
    Arachnid,
    Flying
}
================================================================================

File: ./Bodies/BodyPartFactory.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Bodies;

public static class BodyPartFactory
{

    public static List<BodyRegion> CreateBody(BodyTypes type)
    {
        return type switch
        {
            BodyTypes.Human => CreateHumanBody(),
            BodyTypes.Quadruped => CreateQuadrupedBody(),
            BodyTypes.Serpentine => CreateSerpentineBody(),
            BodyTypes.Arachnid => CreateArachnidBody(),
            BodyTypes.Flying => CreateFlyingBody(),
            _ => throw new NotImplementedException("Invalid body type")
        };
    }

    public static List<BodyRegion> CreateHumanBody()
    {
        var parts = new List<BodyRegion>();

        // HEAD - 10% coverage
        var head = new BodyRegion(BodyRegionNames.Head, 10.0);
        // Skull is very tough (20), but head overall is average
        head.Bone.Toughness = 20;
        
        // Brain - controls consciousness, very fragile
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes - each provides half sight, fragile, external
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));

        // Ears - each provides half hearing, moderately fragile, external
        head.Organs.Add(new Organ(OrganNames.LeftEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.5 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.5 
        }, isExternal: true));

        parts.Add(head);

        // CHEST - 25% coverage
        var chest = new BodyRegion(BodyRegionNames.Chest, 25.0);
        // Ribcage protection
        chest.Bone.Toughness = 12;

        // Heart - critical for blood pumping, moderately tough
        chest.Organs.Add(new Organ(OrganNames.Heart, 5.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Lungs - each provides half breathing capacity, somewhat fragile
        chest.Organs.Add(new Organ(OrganNames.LeftLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));
        
        chest.Organs.Add(new Organ(OrganNames.RightLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));

        parts.Add(chest);

        // ABDOMEN - 20% coverage
        var abdomen = new BodyRegion(BodyRegionNames.Abdomen, 20.0);
        
        // Liver - major digestive organ, moderately tough
        abdomen.Organs.Add(new Organ(OrganNames.Liver, 4.0, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        // Stomach - digestive organ, somewhat fragile
        abdomen.Organs.Add(new Organ(OrganNames.Stomach, 3.0, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        // Kidneys - redundant organs, each can handle most of the load
        abdomen.Organs.Add(new Organ("Left Kidney", 4.0, new CapacityContainer 
        { 
            // BloodFiltration = 0.75 - would need to add this capacity
        }, isExternal: false));
        
        abdomen.Organs.Add(new Organ("Right Kidney", 4.0, new CapacityContainer 
        { 
            // BloodFiltration = 0.75 - would need to add this capacity
        }, isExternal: false));

        parts.Add(abdomen);

        // LEFT ARM - 10% coverage
        var leftArm = new BodyRegion(BodyRegionNames.LeftArm, 10.0);
        // No specific organs, but contributes to manipulation through muscle/bone
        // The base capacities could be set on the part itself or through muscle
        parts.Add(leftArm);

        // RIGHT ARM - 10% coverage  
        var rightArm = new BodyRegion(BodyRegionNames.RightArm, 10.0);
        parts.Add(rightArm);

        // LEFT LEG - 12.5% coverage
        var leftLeg = new BodyRegion(BodyRegionNames.LeftLeg, 12.5);
        parts.Add(leftLeg);

        // RIGHT LEG - 12.5% coverage
        var rightLeg = new BodyRegion(BodyRegionNames.RightLeg, 12.5);
        parts.Add(rightLeg);

        return parts;
    }

    public static List<BodyRegion> CreateQuadrupedBody()
    {
        var parts = new List<BodyRegion>();

        // HEAD - 15% coverage (proportionally larger for quadrupeds)
        var head = new BodyRegion("Head", 15.0);
        head.Bone.Toughness = 15; // Slightly less protected than human skull
        
        // Brain
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes - better sight for predators/prey
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.6 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.6 
        }, isExternal: true));

        // Ears - better hearing
        head.Organs.Add(new Organ(OrganNames.LeftEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.6 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.6 
        }, isExternal: true));

        parts.Add(head);

        // TORSO - 35% coverage (larger torso for quadrupeds)
        var torso = new BodyRegion("Torso", 35.0);
        
        // Heart
        torso.Organs.Add(new Organ(OrganNames.Heart, 5.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Lungs
        torso.Organs.Add(new Organ(OrganNames.LeftLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));
        
        torso.Organs.Add(new Organ(OrganNames.RightLung, 3.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));

        // Digestive organs
        torso.Organs.Add(new Organ(OrganNames.Liver, 4.0, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        torso.Organs.Add(new Organ(OrganNames.Stomach, 3.0, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        parts.Add(torso);

        // LEGS - 12.5% each for four legs
        var frontLeftLeg = new BodyRegion("Front Left Leg", 12.5);
        var frontRightLeg = new BodyRegion("Front Right Leg", 12.5);
        var rearLeftLeg = new BodyRegion("Rear Left Leg", 12.5);
        var rearRightLeg = new BodyRegion("Rear Right Leg", 12.5);

        parts.AddRange([frontLeftLeg, frontRightLeg, rearLeftLeg, rearRightLeg]);

        return parts;
    }

    public static List<BodyRegion> CreateSerpentineBody()
    {
        var parts = new List<BodyRegion>();

        // HEAD - 20% coverage
        var head = new BodyRegion("Head", 20.0);
        head.Bone.Toughness = 8; // Less protected than mammalian skulls
        
        // Brain
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.5 
        }, isExternal: true));

        parts.Add(head);

        // BODY - 80% coverage (long serpentine body)
        var body = new BodyRegion("Body", 80.0);
        
        // Heart
        body.Organs.Add(new Organ(OrganNames.Heart, 4.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Single lung (snakes typically have one functional lung)
        body.Organs.Add(new Organ("Lung", 3.0, new CapacityContainer 
        { 
            Breathing = 1.0 
        }, isExternal: false));

        // Digestive organs
        body.Organs.Add(new Organ(OrganNames.Liver, 4.0, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        body.Organs.Add(new Organ(OrganNames.Stomach, 3.0, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        parts.Add(body);

        return parts;
    }

    public static List<BodyRegion> CreateArachnidBody()
    {
        var parts = new List<BodyRegion>();

        // CEPHALOTHORAX - 40% coverage (head and thorax combined)
        var cephalothorax = new BodyRegion("Cephalothorax", 40.0);
        cephalothorax.Bone.Toughness = 12; // Chitin is quite tough
        
        // Brain
        cephalothorax.Organs.Add(new Organ(OrganNames.Brain, 0.3, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Multiple eyes - spiders typically have 8 eyes
        for (int i = 1; i <= 8; i++)
        {
            cephalothorax.Organs.Add(new Organ($"Eye {i}", 0.2, new CapacityContainer 
            { 
                Sight = 0.125 // Each contributes 1/8th of total sight
            }, isExternal: true));
        }

        // Heart
        cephalothorax.Organs.Add(new Organ(OrganNames.Heart, 3.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        parts.Add(cephalothorax);

        // ABDOMEN - 20% coverage
        var abdomen = new BodyRegion("Abdomen", 20.0);
        
        // Book lungs (spiders have book lungs instead of regular lungs)
        abdomen.Organs.Add(new Organ("Book Lungs", 2.0, new CapacityContainer 
        { 
            Breathing = 1.0 
        }, isExternal: false));

        // Digestive organs
        abdomen.Organs.Add(new Organ("Digestive System", 3.0, new CapacityContainer 
        { 
            Digestion = 1.0 
        }, isExternal: false));

        parts.Add(abdomen);

        // LEGS - 8 legs, 5% coverage each
        for (int i = 1; i <= 8; i++)
        {
            var leg = new BodyRegion($"Leg {i}", 5.0);
            parts.Add(leg);
        }

        return parts;
    }

    public static List<BodyRegion> CreateFlyingBody()
    {
        var parts = new List<BodyRegion>();

        // HEAD - 12% coverage
        var head = new BodyRegion("Head", 12.0);
        head.Bone.Toughness = 8; // Lighter bones for flight
        
        // Brain
        head.Organs.Add(new Organ(OrganNames.Brain, 0.25, new CapacityContainer 
        { 
            Consciousness = 1.0 
        }, isExternal: false));

        // Eyes - excellent vision for flying
        head.Organs.Add(new Organ(OrganNames.LeftEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.7 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEye, 0.5, new CapacityContainer 
        { 
            Sight = 0.7 
        }, isExternal: true));

        // Ears - excellent hearing
        head.Organs.Add(new Organ(OrganNames.LeftEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.7 
        }, isExternal: true));
        
        head.Organs.Add(new Organ(OrganNames.RightEar, 1.0, new CapacityContainer 
        { 
            Hearing = 0.7 
        }, isExternal: true));

        parts.Add(head);

        // TORSO - 30% coverage
        var torso = new BodyRegion("Torso", 30.0);
        torso.Bone.Toughness = 8; // Hollow bones
        
        // Heart - larger for flight demands
        torso.Organs.Add(new Organ(OrganNames.Heart, 6.0, new CapacityContainer 
        { 
            BloodPumping = 1.0 
        }, isExternal: false));

        // Lungs - highly efficient
        torso.Organs.Add(new Organ(OrganNames.LeftLung, 4.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));
        
        torso.Organs.Add(new Organ(OrganNames.RightLung, 4.0, new CapacityContainer 
        { 
            Breathing = 0.5 
        }, isExternal: false));

        // Digestive organs
        torso.Organs.Add(new Organ(OrganNames.Liver, 3.5, new CapacityContainer 
        { 
            Digestion = 0.6 
        }, isExternal: false));

        torso.Organs.Add(new Organ(OrganNames.Stomach, 2.5, new CapacityContainer 
        { 
            Digestion = 0.4 
        }, isExternal: false));

        parts.Add(torso);

        // WINGS - 15% each
        var leftWing = new BodyRegion("Left Wing", 15.0);
        var rightWing = new BodyRegion("Right Wing", 15.0);
        // Wings are primarily for movement
        
        parts.AddRange([leftWing, rightWing]);

        // LEGS - 6.5% each  
        var leftLeg = new BodyRegion("Left Leg", 6.5);
        var rightLeg = new BodyRegion("Right Leg", 6.5);

        parts.AddRange([leftLeg, rightLeg]);

        return parts;
    }
}================================================================================

File: ./Bodies/CapacityCalculator.cs
--------------------------------------------------------------------------------
using text_survival.Effects;

namespace text_survival.Bodies;

public static class CapacityCalculator
{
    public static CapacityContainer GetCapacities(Body body)
    {
        CapacityContainer total = new();
        foreach (var part in body.Parts)
        {
            total += GetRegionCapacities(part);
        }
        // Apply body-wide effect modifiers
        var bodyModifier = GetEffectCapacityModifiers(body.EffectRegistry);
        total = total.ApplyModifier(bodyModifier);

        // Apply cascading effects
        return ApplyCascadingEffects(total);
    }

    public static CapacityContainer GetRegionCapacities(BodyRegion region)
    {
        // Step 1: Sum all base capacities from organs
        var baseCapacities = new CapacityContainer();
        foreach (var organ in region.Organs)
        {
            baseCapacities += organ.GetBaseCapacities();
        }
        var materials = new[] { region.Skin, region.Muscle, region.Bone }.Where(m => m != null);
        foreach (var material in materials)
        {
            baseCapacities += material!.GetBaseCapacities();
        }

        // Step 2: Calculate combined material multipliers
        // var baseMultipliers = CapacityContainer.GetBaseCapacityMultiplier();
        // foreach (var material in new List<Tissue> { region.Skin, region.Muscle, region.Bone })
        // {
        //     // todo revisit this, I think this will cause too big of an effect, e.g. 0.5*0.5 = .25
        //     var multipliers = material.GetConditionMultipliers();
        //     baseMultipliers = baseMultipliers.ApplyMultipliers(multipliers);
        // }
        // above is OLD way - may remove after testing
        var materialMultipliers = materials.Select(m => m!.GetConditionMultipliers()).ToList();
        var avgMultipliers = AverageCapacityContainers(materialMultipliers);

        // Step 3: Apply multipliers to base capacities
        return baseCapacities.ApplyMultipliers(avgMultipliers);
    }


    private static CapacityContainer AverageCapacityContainers(List<CapacityContainer> containers)
    {
        if (containers.Count == 0) return CapacityContainer.GetBaseCapacityMultiplier();

        var result = new CapacityContainer();
        var capacityNames = CapacityNames.All;
        foreach (var capacityName in capacityNames)
        {
            double avg = containers.Average(c => c.GetCapacity(capacityName));
            result.SetCapacity(capacityName, avg);
        }
        return result;
    }

    private static CapacityContainer ApplyCascadingEffects(CapacityContainer baseCapacities)
    {
        var result = baseCapacities;

        // Poor blood circulation affects everything
        if (result.BloodPumping < 0.5)
        {
            double circulationPenalty = 1.0 - (0.5 - result.BloodPumping);
            result.Consciousness *= circulationPenalty;
            result.Moving *= circulationPenalty;
            result.Manipulation *= circulationPenalty;
        }

        // Can't breathe? Consciousness drops rapidly
        if (result.Breathing < 0.3)
        {
            double oxygenPenalty = result.Breathing / 0.3; // 0.0 to 1.0
            result.Consciousness *= oxygenPenalty;
        }

        // Unconscious? Can't do physical actions
        if (result.Consciousness < 0.1)
        {
            result.Moving *= 0.1;
            result.Manipulation *= 0.1;
        }

        return result;
    }


    public static CapacityModifierContainer GetEffectCapacityModifiers(EffectRegistry effectRegistry)
    {
        CapacityModifierContainer total = new();
        var modifiers = effectRegistry.GetAll().Select(e => e.CapacityModifiers).ToList();
        foreach (var mod in modifiers)
        {
            total += mod;
        }
        return total;
    }

}================================================================================

File: ./Bodies/Organ.cs
--------------------------------------------------------------------------------
namespace text_survival.Bodies;

public static class OrganNames
{
    public const string Brain = "Brain";
    public const string LeftEye = "Left Eye";
    public const string RightEye = "Right Eye";
    public const string LeftEar = "Left Ear";
    public const string RightEar = "Right Ear";
    public const string Heart = "Heart";
    public const string LeftLung = "Left Lung";
    public const string RightLung = "Right Lung";
    public const string Liver = "Liver";
    public const string Stomach = "Stomach";
}


public class Organ(string name, double toughness, CapacityContainer capacities, bool isExternal = false) : Tissue (name, toughness)
{
    public bool IsExternal { get; set; } = isExternal;
    public CapacityContainer _baseCapacities { get; set; } = capacities;
    public override CapacityContainer GetBaseCapacities()
    {
        return _baseCapacities;
    }
}
================================================================================

File: ./Bodies/Capacities.cs
--------------------------------------------------------------------------------

namespace text_survival.Bodies;


// for type hints if needed
public static class CapacityNames
{
    public const string Moving = "Moving";
    public const string Manipulation = "Manipulation";
    public const string Breathing = "Breathing";
    public const string BloodPumping = "BloodPumping";
    public const string Consciousness = "Consciousness";
    public const string Sight = "Sight";
    public const string Hearing = "Hearing";
    public const string Digestion = "Digestion";

    public static readonly List<string> All =
    [
        Moving, Manipulation, Breathing, BloodPumping, Consciousness, Sight, Hearing, Digestion
    ];
}

/// <summary>
/// A container class to hold all capacity values and provide strong typing for body part capacity operations. Implements operators like addition and multiplication.
/// </summary>
public class CapacityContainer
{
    private Dictionary<string, double> capacities = new()
    {
        {CapacityNames.Moving, 0 },
        {CapacityNames.Manipulation, 0},
        {CapacityNames.Breathing, 0},
        {CapacityNames.BloodPumping, 0},
        {CapacityNames.Consciousness, 0},
        {CapacityNames.Sight, 0},
        {CapacityNames.Hearing, 0},
        {CapacityNames.Digestion, 0},
    };

    // Property accessors for backward compatibility if needed
    public double Moving
    {
        get => capacities[CapacityNames.Moving];
        set => capacities[CapacityNames.Moving] = Math.Clamp(value, 0, 1);
    }
    public double Manipulation
    {
        get => capacities[CapacityNames.Manipulation];
        set => capacities[CapacityNames.Manipulation] = Math.Clamp(value, 0, 1);
    }
    public double Breathing
    {
        get => capacities[CapacityNames.Breathing];
        set => capacities[CapacityNames.Breathing] = Math.Clamp(value, 0, 1);
    }
    public double BloodPumping
    {
        get => capacities[CapacityNames.BloodPumping];
        set => capacities[CapacityNames.BloodPumping] = Math.Clamp(value, 0, 1);
    }
    public double Consciousness
    {
        get => capacities[CapacityNames.Consciousness];
        set => capacities[CapacityNames.Consciousness] = Math.Clamp(value, 0, 1);
    }
    public double Sight
    {
        get => capacities[CapacityNames.Sight];
        set => capacities[CapacityNames.Sight] = Math.Clamp(value, 0, 1);
    }
    public double Hearing
    {
        get => capacities[CapacityNames.Hearing];
        set => capacities[CapacityNames.Hearing] = Math.Clamp(value, 0, 1);
    }
    public double Digestion
    {
        get => capacities[CapacityNames.Digestion];
        set => capacities[CapacityNames.Digestion] = Math.Clamp(value, 0, 1);
    }

    public List<double> AllCapacities => capacities.Values.ToList();

    public double GetCapacity(string capacityName) => capacities.GetValueOrDefault(capacityName);
    public void SetCapacity(string capacityName, double value) => capacities[capacityName] = Math.Clamp(value, 0, 1);

    public static CapacityContainer operator +(CapacityContainer a, CapacityContainer b)
    {
        var newCapacities = a.capacities.Keys.Union(b.capacities.Keys)
            .ToDictionary(
                key => key,
                key => Math.Clamp(a.capacities.GetValueOrDefault(key) + b.capacities.GetValueOrDefault(key), 0, 1)
            );
        return new CapacityContainer { capacities = newCapacities };
    }

    public CapacityContainer ApplyMultipliers(CapacityContainer multipliers)
    {
        var newCapacities = capacities.Keys.Union(multipliers.capacities.Keys)
            .ToDictionary(
                key => key,
                key => Math.Clamp(capacities.GetValueOrDefault(key) * multipliers.capacities.GetValueOrDefault(key, 1), 0, 1)
            );
        return new CapacityContainer { capacities = newCapacities };
    }

    public CapacityContainer ApplyMultiplier(double multiplier)
    {
        var newCapacities = capacities.ToDictionary(
            kvp => kvp.Key,
            kvp => Math.Clamp(kvp.Value * multiplier, 0, 1)
        );
        return new CapacityContainer { capacities = newCapacities };
    }

    public CapacityContainer ApplyModifier(CapacityModifierContainer modifiers)
    {
        var newCapacities = capacities.ToDictionary(
            kvp => kvp.Key,
            kvp => Math.Clamp(kvp.Value + modifiers.GetCapacityModifier(kvp.Key), 0, 1)
        );
        return new CapacityContainer { capacities = newCapacities };
    }

    /// <summary>
    /// Helper for generating a base CapacityContainer with all values set to one - intended for capacity multipliers.
    /// </summary>
    /// <returns>A new CapacityContainer that has all values set to 1</returns>
    public static CapacityContainer GetBaseCapacityMultiplier()
    {
        return new CapacityContainer
        {
            capacities = new Dictionary<string, double>
            {
                {CapacityNames.Moving, 1 },
                {CapacityNames.Manipulation, 1},
                {CapacityNames.Breathing, 1},
                {CapacityNames.BloodPumping, 1},
                {CapacityNames.Consciousness, 1},
                {CapacityNames.Sight, 1},
                {CapacityNames.Hearing, 1},
                {CapacityNames.Digestion, 1},
            }
        };
    }
}

public class CapacityModifierContainer
{
    public double GetCapacityModifier(string capacityName) => Math.Clamp(capacities.GetValueOrDefault(capacityName), -1, 1); // Fixed parameter order
    public void SetCapacityModifier(string capacityName, double value) => capacities[capacityName] = Math.Clamp(value, -1, 1);

    private Dictionary<string, double> capacities = new()
    {
        {CapacityNames.Moving, 0 },
        {CapacityNames.Manipulation, 0},
        {CapacityNames.Breathing, 0},
        {CapacityNames.BloodPumping, 0},
        {CapacityNames.Consciousness, 0},
        {CapacityNames.Sight, 0},
        {CapacityNames.Hearing, 0},
        {CapacityNames.Digestion, 0},
    };

    public static CapacityModifierContainer operator +(CapacityModifierContainer a, CapacityModifierContainer b)
    {
        var newModifiers = a.capacities.Keys.Union(b.capacities.Keys)
            .ToDictionary(
                key => key,
                key => a.capacities.GetValueOrDefault(key) + b.capacities.GetValueOrDefault(key)
            );
        return new CapacityModifierContainer { capacities = newModifiers };
    }
}================================================================================

File: ./Bodies/DamageCalculator.cs
--------------------------------------------------------------------------------
using System.Security.Cryptography.X509Certificates;

namespace text_survival.Bodies;

public class DamageResult
{
    public double DamageAbsorbed { get; set; }
    public string HitPartName { get; set; } = "";
    public double HitPartHealthBefore { get; set; }
    public double HitPartHealthAfter { get; set; }
    public double TotalDamageDealt => HitPartHealthBefore - HitPartHealthAfter;
    public List<(string TissueName, double DamageTaken)> TissuesDamaged { get; set; } = new();
    public bool OrganHit { get; set; }
    public string? OrganHitName { get; set; }
    public bool WasPenetrating { get; set; } // Did damage go through layers
}


public static class DamageProcessor
{
    public static DamageResult DamageBody(DamageInfo damageInfo, Body body)
    {
        var result = new DamageResult();

        // If targeting specific part, find it
        BodyRegion hitPart;
        if (damageInfo.TargetPartName != null)
        {
            hitPart = BodyTargetHelper.GetPartByName(body, damageInfo.TargetPartName)
                     ?? BodyTargetHelper.GetRandomMajorPartByCoverage(body);
        }
        else
        {
            // Otherwise, distribute based on coverage
            hitPart = BodyTargetHelper.GetRandomMajorPartByCoverage(body);
        }

        result.HitPartName = hitPart.Name;
        result.HitPartHealthBefore = hitPart.Condition;

        DamagePart(hitPart, damageInfo, result);

        result.HitPartHealthAfter = hitPart.Condition;
        return result;
    }
    private static void DamagePart(BodyRegion part, DamageInfo damageInfo, DamageResult result)
    {
        double remainingDamage = PenetrateLayers(part, damageInfo, result);
        if (remainingDamage <= 0) return;

        var hitOrgan = BodyTargetHelper.SelectRandomOrganToHit(part, damageInfo.Amount);
        if (hitOrgan != null)
        {
            result.OrganHit = true;
            result.OrganHitName = hitOrgan.Name;
            // Create new damage info for the organ with remaining damage
            var organDamage = new DamageInfo
            {
                Amount = remainingDamage,
                Type = damageInfo.Type,
                TargetPartName = hitOrgan.Name
            };
            double organHealthBefore = hitOrgan.Condition;
            DamageTissue(hitOrgan, organDamage);
            result.TissuesDamaged.Add((hitOrgan.Name, organHealthBefore - hitOrgan.Condition));
        }
        else if (part.Muscle != null)
        {
            // Deep tissue damage to muscle
            var muscleDamage = new DamageInfo
            {
                Amount = remainingDamage * 0.5,
                Type = damageInfo.Type
            };
            
            double muscleHealthBefore = part.Muscle.Condition;
            DamageTissue(part.Muscle, muscleDamage);
            double muscleDamageAmount = muscleHealthBefore - part.Muscle.Condition;
            
            if (muscleDamageAmount > 0)
                result.TissuesDamaged.Add((part.Muscle.Name, muscleDamageAmount));
        }
        // DamageTissue(hitOrgan, damageInfo);
    }

    private static void DamageTissue(Tissue tissue, DamageInfo damageInfo)
    {
        double absorption = tissue.GetNaturalAbsorption(damageInfo.Type);
        damageInfo.Amount -= absorption;
        if (damageInfo.Amount <= 0)
        {
            return; // Natural squishiness absorbed it
        }

        double healthLoss = damageInfo.Amount / tissue.GetProtection(damageInfo.Type);
        tissue.Condition = Math.Max(0, tissue.Condition - healthLoss);
    }

    private static double PenetrateLayers(BodyRegion part, DamageInfo damageInfo, DamageResult result)
    {
        double remainingDamage = damageInfo.Amount;
        var layers = new[] { part.Skin, part.Muscle, part.Bone }.Where(l => l != null);

        foreach (var layer in layers)
        {
            if (remainingDamage <= 0) break;

            double protection = layer!.GetProtection(damageInfo.Type);
            double maxAbsorption = remainingDamage * 0.7;
            double actualAbsorption = Math.Min(maxAbsorption, protection);
            
            if (actualAbsorption > 0)
            {
                var layerDamage = new DamageInfo
                {
                    Amount = actualAbsorption,
                    Type = damageInfo.Type
                };
                
                double layerHealthBefore = layer.Condition;
                DamageTissue(layer, layerDamage);
                double layerDamageAmount = layerHealthBefore - layer.Condition;
                
                result.DamageAbsorbed += actualAbsorption;
                
                if (layerDamageAmount > 0)
                    result.TissuesDamaged.Add((layer.Name, layerDamageAmount));
            }
            
            remainingDamage -= actualAbsorption;
        }

        return Math.Max(0, remainingDamage);
    }

}================================================================================

File: ./Magic/Spell.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;

namespace text_survival.Magic;

public class Spell
{
    public string Name { get; private set; }
    public bool NeedsTargetPart { get; private set; }
    private Effect Effect { get; }


    public Spell(string name, Effect effect, bool needsTargetPart)
    {
        Name = name;
        Effect = effect;
        NeedsTargetPart = needsTargetPart;
    }

    public void Cast(Actor target)
    {
        target.EffectRegistry.AddEffect(Effect);
    }
    public void Cast(Actor target, BodyRegion part)
    {
        Effect.TargetBodyPart = part.Name;
        target.EffectRegistry.AddEffect(Effect);
    }

    public override string ToString()
    {
        return Name;
    }


}
================================================================================

File: ./Magic/SpellFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;

namespace text_survival.Magic
{
  public static class SpellFactory
  {
    public static Spell MinorHeal => new Spell("Minor Heal",
                                                  EffectBuilderExtensions
                                                    .CreateEffect("bleed spell")
                                                    .Healing(10)
                                                    .Build(),
                                                  true);
    public static Spell Bleeding => new Spell("Bleeding",
                                              EffectBuilderExtensions
                                                .CreateEffect("bleed spell")
                                                .Bleeding(10)
                                                .WithDuration(60)
                                                .Build(),
                                              false);
    public static Spell Poison => new Spell("Poison",
                                              EffectBuilderExtensions
                                                .CreateEffect("poison spell")
                                                .Poisoned(5)
                                                .WithDuration(180)
                                                .Build(),
                                              false);
  }
}
================================================================================

File: ./PlayerComponents/LocationManger.cs
--------------------------------------------------------------------------------
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

class LocationManager
{
    public LocationManager(Location startingLocation)
    {
        Map = new WorldMap(startingLocation.Parent);
        _currentLocation = startingLocation;
    }
    private WorldMap Map { get; }
    public Location CurrentLocation
    {
        get
        {
            return _currentLocation;
        }
        set
        {
            Output.WriteLine("You go to the ", value);
            int minutes = Utils.RandInt(1, 10);
            World.Update(minutes);
            Output.WriteLine("You arrive at the ", value, " after walking ", minutes, " minutes.");
            _currentLocation = value;
            _currentLocation.Visited = true;
            Output.WriteLine("You should probably look around.");
        }
    }
    private Location _currentLocation;

    public Zone CurrentZone
    {
        get
        {
            return Map.CurrentZone;
        }
        set
        {
            if (Map.North == value)
            {
                Output.WriteLine("You go north.");
                Map.MoveNorth();
            }
            else if (Map.East == value)
            {
                Output.WriteLine("You go east.");
                Map.MoveEast();
            }
            else if (Map.South == value)
            {
                Output.WriteLine("You go south.");
                Map.MoveSouth();
            }
            else if (Map.West == value)
            {
                Output.WriteLine("You go west.");
                Map.MoveWest();
            }
            else
                throw new Exception("Invalid zone!");
            Location? newLocation = Utils.GetRandomFromList(value.Locations);

            CurrentLocation = newLocation ?? throw new Exception("No Locations In Zone");
            Output.WriteLine("You enter ", value);
            Output.WriteLine(value.Description);
        }
    }

    public bool RemoveItemFromLocation(Item item)
    {
        if (_currentLocation.Items.Contains(item))
        {
            _currentLocation.Items.Remove(item);
            return true;
        }
        else
        {
            Container? container = _currentLocation.Containers.FirstOrDefault(x => x.Items.Contains(item));
            if (container != null)
            {
                container.Remove(item);
                return true;
            }
        }
        return false;
    }

    public void AddItemToLocation(Item item)
    {
        _currentLocation.Items.Add(item);
    }

    public void TravelToAdjacentZone()
    {
        Output.WriteLine("Where would you like to go?");

        Output.WriteLine(1, ". North: ", (Map.North.Visited ? Map.North.Name : " Unknown"));
        Output.WriteLine(2, ". East: ", (Map.East.Visited ? Map.East.Name : " Unknown"));
        Output.WriteLine(3, ". South: ", (Map.South.Visited ? Map.South.Name : " Unknown"));
        Output.WriteLine(4, ". West: ", (Map.West.Visited ? Map.West.Name : " Unknown"));

        Output.WriteLine("0. Cancel");
        int input = Input.ReadInt(0, 4);

        if (input == 0) return;

        int minutes = Utils.RandInt(30, 60);
        Output.WriteLine("You travel for ", minutes, " minutes...");

        switch (input)
        {
            case 1:
                CurrentZone = Map.North;
                break;
            case 2:
                CurrentZone = Map.East;
                break;
            case 3:
                CurrentZone = Map.South;
                break;
            case 4:
                CurrentZone = Map.West;
                break;
        }

        World.Update(minutes);
    }

}================================================================================

File: ./PlayerComponents/CombatManager.cs
--------------------------------------------------------------------------------
using System.Runtime;
using Microsoft.VisualBasic;
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

public class CombatManager
{
    public CombatManager(Actor owner)
    {
        Owner = owner;
    }

    public double DetermineDamage()
    {
        // base weapon and skill
        double baseDamage = Owner.ActiveWeapon.Damage;

        double skillBonus = 0;
        if (Owner is Player player)
        {
            skillBonus = player.Skills.Fighting.Level;
        }

        // modifiers
        double strengthModifier = (AbilityCalculator.CalculateStrength(Owner.Body) / 2) + .5; // str determines up to 50%
        // A smaller health modifier up to 30%
        double healthModifier = 0.7 + (0.3 * (Owner.Body.Health / Owner.Body.MaxHealth));
        // todo factor in any effects like adrenaline, etc.
        // This could be expanded based on your EffectRegistry
        double effectsModifier = 1.0;
        double randomModifier = Utils.RandDouble(.5, 1.5);
        double totalModifier = strengthModifier * healthModifier * effectsModifier * randomModifier;

        double damage = (baseDamage + skillBonus) * totalModifier;
        return damage >= 0 ? damage : 0;
    }

    public double DetermineDodgeChance(Actor target)
    {

        double dodgeLevel = 0;
        if (target is Player player)
            dodgeLevel = player.Skills.Reflexes.Level;

        double baseDodge = dodgeLevel / 100;
        double speedDiff = AbilityCalculator.CalculateSpeed(target.Body) - AbilityCalculator.CalculateSpeed(Owner.Body);
        double chance = baseDodge + speedDiff;
        // Output.WriteLine("Debug: Dodge Chance = ", chance);
        chance = Math.Clamp(chance, 0, .95);
        return chance;
    }

    public bool DetermineDodge(Actor target)
    {
        double dodgeChance = DetermineDodgeChance(target);
        if (Utils.DetermineSuccess(dodgeChance))
        {
            Output.WriteLine($"{Owner} dodged the attack!");
            return true;
        }
        return false;
    }

    public bool DetermineHit()
    {
        // Output.WriteLine("Debug: hit Chance: ", Owner.ActiveWeapon.Accuracy);
        double hitChance = Math.Clamp(Owner.ActiveWeapon.Accuracy, .01, .95);
        if (!Utils.DetermineSuccess(hitChance))
        {
            Output.WriteLine($"{Owner} missed!");
            return false;
        }
        return true;
    }

    public bool DetermineBlock(Actor target)
    {
        double blockLevel = 0;
        if (target is Player player)
            blockLevel = player.Skills.Defense.Level;
        double skillBonus = blockLevel / 100;
        double attributeAvg = AbilityCalculator.CalculateStrength(target.Body); // todo 
        double blockAtbAvg = target.ActiveWeapon.BlockChance + attributeAvg / 2;
        double blockChance = blockAtbAvg + skillBonus;
        if (Utils.DetermineSuccess(blockChance))
        {
            Output.WriteLine($"{target} blocked the attack!");
            return true;
        }
        return false;
    }

    public void Attack(Actor target, string? targetedPart = null)
    {
        bool isDodged = DetermineDodge(target);
        if (isDodged)
        {
            // Use our narrator for rich descriptions
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, null, false, true, false);
            Output.WriteLine(description);
            return;
        }

        bool isHit = DetermineHit();
        if (!isHit)
        {
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, null, false, false, false);
            Output.WriteLine(description);
            return;
        }

        // Check for block
        bool isBlocked = DetermineBlock(target);
        if (isBlocked)
        {
            string description = CombatNarrator.DescribeAttack(Owner, target, 0, null, true, false, true);
            Output.WriteLine(description);
            return;
        }

        double damage = DetermineDamage();

        DamageType type = Owner.ActiveWeapon.Class switch
        {
            WeaponClass.Blade or WeaponClass.Claw => DamageType.Sharp,
            WeaponClass.Pierce => DamageType.Pierce,
            _ => DamageType.Blunt
        };

        DamageInfo damageInfo = new(
            amount: damage,
            source: Owner.Name,
            type: type,
            targetPartName: targetedPart
        );

        DamageResult damageResult = DamageProcessor.DamageBody(damageInfo, target.Body);

        string attackDescription = CombatNarrator.DescribeAttack(Owner, target, damageResult, true, false, false);
        Output.WriteLine(attackDescription);

        // Add weapon-specific effect descriptions
        if (damageResult.TotalDamageDealt > 0)
        {
            AddWeaponEffectDescription(Owner.ActiveWeapon.Class, damageResult.TotalDamageDealt);
        }

        if (target is Player player)
        {
            player.Skills.Fighting.GainExperience(1);
        }
        
        Thread.Sleep(1000);
    }

    private static void AddWeaponEffectDescription(WeaponClass weaponClass, double damage)
    {
        if (weaponClass == WeaponClass.Blade && damage > 10)
        {
            Output.WriteDanger("Blood sprays from the wound!");
        }
        else if (weaponClass == WeaponClass.Blunt && damage > 12)
        {
            Output.WriteDanger("You hear a sickening crack!");
        }
        else if (weaponClass == WeaponClass.Pierce && damage > 15)
        {
            Output.WriteDanger("The attack pierces deep into the flesh!");
        }
    }

    public Actor Owner { get; }
}
================================================================================

File: ./PlayerComponents/InventoryManager.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.PlayerComponents;

public class InventoryManager
{
    public InventoryManager(EffectRegistry effectRegistry)
    {
        Armor = [];
        _unarmed = ItemFactory.MakeFists();
        Inventory = new Container("Bag", 10);
        _effectRegistry = effectRegistry;
    }
    private Container Inventory { get; }
    public List<ItemStack> Items => ItemStack.CreateStacksFromItems(Inventory.Items);
    public List<Armor> Armor { get; }
    public Gear? HeldItem { get; private set; }
    private EffectRegistry _effectRegistry { get; }
    // weapon
    private Weapon? _weapon;
    private readonly Weapon _unarmed;
    public bool IsArmed => Weapon != _unarmed;
    public bool IsArmored => Armor.Count != 0;

    public Armor? GetArmorInSpot(EquipSpots spot) => Armor.FirstOrDefault(i => i.EquipSpot == spot);
    public Weapon Weapon
    {
        get => _weapon ?? _unarmed;
        set => _weapon = value;
    }

    public void AddToInventory(Item item)
    {
        Output.WriteLine("You put the ", item, " in your ", Inventory);
        Inventory.Add(item);
    }

    public void RemoveFromInventory(Item item)
    {
        Output.WriteLine("You take the ", item, " from your ", Inventory);
        Inventory.Remove(item);
    }

    public double ArmorRating
    {
        get
        {
            double rating = 0;
            foreach (Armor armor in Armor)
            {
                rating += armor.Rating;
            }
            return rating;
        }
    }

    public double ClothingInsulation => Armor.Sum(a => a.Insulation);

    public void Equip(IEquippable item)
    {
        switch (item)
        {
            case Weapon weapon:
                Unequip(Weapon);
                Weapon = weapon;
                break;
            case Armor armor:
                var oldItem = Armor.FirstOrDefault(i => i.EquipSpot == armor.EquipSpot);
                if (oldItem != null) Unequip(oldItem);
                Armor.Add(armor);
                break;
            case Gear gear:
                if (HeldItem != null) Unequip(HeldItem);
                HeldItem = gear;
                break;
            default:
                Output.WriteLine("You can't equip that.");
                return;
        }
        Inventory.Remove((Item)item);
        item.EquipEffects.ForEach(_effectRegistry.AddEffect);
    }

    public bool CanAutoEquip(IEquippable item)
    {

        if (item is Weapon weapon && !IsArmed)
        {
            Output.WriteLine($"You equip the {weapon}");
            return true;
        }
        else if (item is Armor armor)
        {
            var existingItem = Armor.FirstOrDefault(i => i.EquipSpot == armor.EquipSpot);
            if (existingItem == null)
            {
                Output.WriteLine($"You equip the {armor}");
                return true;
            }
        }
        else if (item is Gear gear && HeldItem == null)
        {
            Output.WriteLine($"You didn't have anything in your hand yet so you equip the {item}");
            return true;
        }
        return false;
    }

    public void Unequip(IEquippable item)
    {
        if (item is not Gear gear) return;
        if (item == _unarmed) return;

        switch (gear)
        {
            case Weapon weapon:
                Weapon = _unarmed;
                break;
            case Armor armor:
                Armor.Remove(armor);
                break;
            case Gear g:
                HeldItem = null;
                break;
            default:
                Output.WriteLine("You can't unequip that.");
                return;
        }
        Output.WriteLine("You unequip ", gear);
        Inventory.Add(gear);
        gear.EquipEffects.ForEach(_effectRegistry.RemoveEffect);
    }
    public void CheckGear()
    {
        DescribeGear(this);
        Output.WriteLine("Would you like to unequip an item?");
        if (Input.ReadYesNo()) return;

        Output.WriteLine("Which item would you like to unequip?");
        // get list of all equipment
        var equipment = new List<IEquippable>();
        equipment.AddRange(Armor);
        if (IsArmed) equipment.Add(Weapon);
        if (HeldItem != null) equipment.Add(HeldItem);

        var choice = Input.GetSelectionFromList(equipment, true);
        if (choice == null) return;
        Unequip(choice);
    }

    public static void DescribeGear(InventoryManager inv)
    {
        if (inv.IsArmed)
        {
            Output.Write("Weapon => ");
            inv.Weapon.Describe();
        }
        foreach (Armor armor in inv.Armor)
        {
            Output.Write(armor.EquipSpot, " => ");
            armor.Describe();
        }
        if (inv.HeldItem is not null)
        {
            Output.Write("Held Item => ");
            inv.HeldItem.Describe();
        }
    }
    public void Describe()
    {
        Output.WriteLine(Inventory, " (", Inventory.Weight(), "/", Inventory.MaxWeight, "):");
    }
}
================================================================================

File: ./Environments/Weather.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ZoneWeather
{

    // todo: improve sunrise and sunset logic,
    // todo: add more continuity and state to more granular changes
    public double BaseTemperature { get; private set; } // In Celsius
    public WeatherCondition CurrentCondition { get; private set; }
    public double Precipitation { get; private set; } // 0-1 intensity
    public double WindSpeed { get; private set; }    // 0-1 intensity
    public double CloudCover { get; private set; }   // 0-1 coverage

    // Season tracking
    public enum Season { Winter, Spring, Summer, Fall }
    public Season CurrentSeason { get; private set; } = Season.Fall; // Start in fall

    // Weather conditions for Ice Age Europe
    public enum WeatherCondition
    {
        Clear,      // Clear, cold skies
        Cloudy,     // Overcast conditions
        Misty,      // Low visibility with moisture
        LightSnow,  // Light snowfall (common in Ice Age)
        Rainy,      // Cold rain (uncommon but possible)
        Blizzard,   // Heavy snow with wind (dangerous)
        Stormy      // Thunderstorms (rare, mostly summer)
    }

    // Add to ZoneWeather class
    public double SunlightIntensity
    {
        get
        {
            // No sun at night
            if (!IsDaytime())
                return 0;

            // Base sun intensity from time of day
            double timeOfDayFactor = GetSunIntensityByTime();

            // Reduction factors from weather conditions
            double cloudReduction = CloudCover * 0.9; // Clouds block up to 90% of sunlight

            // Additional reduction based on weather condition
            double conditionReduction = CurrentCondition switch
            {
                WeatherCondition.Misty => 0.6,
                WeatherCondition.Blizzard => 0.9,
                WeatherCondition.LightSnow => 0.3,
                WeatherCondition.Rainy => 0.5,
                WeatherCondition.Stormy => 0.8,
                _ => 0.0
            };
            // Calculate final intensity (0-1)
            double baseIntensity = timeOfDayFactor * (1 - cloudReduction);
            return baseIntensity * (1 - conditionReduction);
        }
    }

    private bool IsDaytime()
    {
        // todo: flesh this out and combine it with the temperature cycle 
        int hour = World.Time.Hour;

        // Seasonal variation in daylight hours
        int sunriseHour, sunsetHour;

        switch (CurrentSeason)
        {
            case Season.Winter:
                sunriseHour = 8;  // Late sunrise
                sunsetHour = 16;  // Early sunset
                break;
            case Season.Spring:
            case Season.Fall:
                sunriseHour = 6;  // Normal sunrise
                sunsetHour = 18;  // Normal sunset
                break;
            case Season.Summer:
                sunriseHour = 4;  // Early sunrise
                sunsetHour = 20;  // Late sunset
                break;
            default:
                sunriseHour = 6;
                sunsetHour = 18;
                break;
        }

        return hour >= sunriseHour && hour < sunsetHour;
    }

    private double GetSunIntensityByTime()
    {
        // Get sun intensity purely based on time of day (0-1)
        int hour = World.Time.Hour;
        int minute = World.Time.Minute;

        // No sunlight before sunrise or after sunset
        if (!IsDaytime())
            return 0;

        // Convert to minutes since sunrise (0-720)
        double minutesSinceSunrise = ((hour - 6) * 60) + minute;
        double dayLengthMinutes = 12 * 60; // 12 hours of daylight

        // Calculate angle for sine function (0 to π over the day)
        double angle = (minutesSinceSunrise / dayLengthMinutes) * Math.PI;

        // Sine wave peaks at noon (6 hours after sunrise)
        return Math.Sin(angle);
    }

    // Time and update tracking
    private TimeSpan _weatherDuration;
    private TimeSpan _timeSinceChange = TimeSpan.Zero;

    // Zone this weather belongs to
    private Zone _zone;

    public ZoneWeather(Zone zone)
    {
        _zone = zone;

        // Initialize with fall weather
        BaseTemperature = 0; // 0°C is about 32°F - freezing point
        CurrentCondition = WeatherCondition.Clear;
        Precipitation = 0;
        WindSpeed = 0.3; // Moderate wind - 30% of maximum
        CloudCover = 0.3; // Light clouds - 30% coverage

        _weatherDuration = TimeSpan.FromHours(6);
    }

    public void Update(TimeSpan elapsed)
    {
        _timeSinceChange += elapsed;

        // Time to change weather?
        if (_timeSinceChange >= _weatherDuration)
        {
            GenerateNewWeather();
            _timeSinceChange = TimeSpan.Zero;
        }
    }

    private void GenerateNewWeather()
    {
        // Generate new weather conditions based on season and zone
        // Determine base temperature range for season
        double minTemp, maxTemp;
        double precipChance;
        double snowRatio; // Chance of precipitation being snow vs rain

        switch (CurrentSeason)
        {
            case Season.Winter:
                minTemp = -30; // -30°C (-22°F) extreme winter low
                maxTemp = -5;  // -5°C (23°F) winter "warm" day
                precipChance = 0.2; // 20% chance of precipitation
                snowRatio = 0.95;   // 95% of precip is snow in winter
                break;

            case Season.Spring:
                minTemp = -15; // -15°C (5°F) cold spring night
                maxTemp = 5;   // 5°C (41°F) mild spring day
                precipChance = 0.25; // 25% chance of precipitation
                snowRatio = 0.6;    // 60% of precip is snow in spring
                break;

            case Season.Summer:
                minTemp = -5;  // -5°C (23°F) cold summer night
                maxTemp = 15;  // 15°C (59°F) warm summer day
                precipChance = 0.15; // 15% chance of precipitation
                snowRatio = 0.2;    // 20% of precip is snow in summer
                break;

            case Season.Fall:
                minTemp = -10; // -10°C (14°F) cold fall night
                maxTemp = 5;   // 5°C (41°F) mild fall day
                precipChance = 0.2;  // 20% chance of precipitation
                snowRatio = 0.7;    // 70% of precip is snow in fall
                break;

            default:
                minTemp = -15;
                maxTemp = 0;
                precipChance = 0.2;
                snowRatio = 0.8;
                break;
        }

        // Apply zone-specific modifications
        if (_zone.Elevation > 0)
        {
            // Higher elevation = colder (-0.6°C per 100m elevation)
            double elevationEffect = _zone.Elevation * -0.006; // -0.6% per 100m
            minTemp += elevationEffect;
            maxTemp += elevationEffect;
        }

        // Get time of day temperature modifier (0-1 scale)
        double timeOfDayFactor = GetTimeOfDayFactor();

        // Calculate random temperature within range, biased toward colder
        // For example: With Spring (-15°C to 5°C) at noon (factor=1.0):
        // Temperature range = -15 + (5-(-15)) * random(0,0.8) * 1.0 = -15 to +1°C
        double temperatureRange = maxTemp - minTemp;
        double randomFlux = Utils.RandDouble(0, 1);

        BaseTemperature = minTemp + (temperatureRange * randomFlux * timeOfDayFactor);

        // Determine weather condition
        if (Utils.RandDouble(0, 1) < precipChance) // Precipitation check (0.15-0.25 chance)
        {
            // Determine type of precipitation
            double snowVsRainRoll = Utils.RandDouble(0, 1);

            if (snowVsRainRoll < snowRatio) // Snow event
            {
                // Determine if blizzard (rare) or light snow (common)
                if (Utils.RandDouble(0, 1) < 0.15) // 15% of snow events are blizzards
                {
                    CurrentCondition = WeatherCondition.Blizzard;
                    Precipitation = Utils.RandDouble(0.7, 1.0); // 70-100% intensity
                    WindSpeed = Utils.RandDouble(0.7, 1.0);     // 70-100% of max wind
                    CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                }
                else
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.6); // 20-60% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.5);     // 20-50% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
                }
            }
            else // Rain event (uncommon in Ice Age)
            {
                // Only happens when temperature is above freezing
                if (BaseTemperature > 0)
                {
                    // Determine if stormy (very rare) or rainy
                    if (CurrentSeason == Season.Summer && Utils.RandDouble(0, 1) < 0.1) // 10% of summer rain is storms
                    {
                        CurrentCondition = WeatherCondition.Stormy;
                        Precipitation = Utils.RandDouble(0.6, 0.9); // 60-90% intensity
                        WindSpeed = Utils.RandDouble(0.5, 0.8);     // 50-80% of max wind
                        CloudCover = Utils.RandDouble(0.9, 1.0);    // 90-100% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(2); // 1-3 hours
                    }
                    else
                    {
                        CurrentCondition = WeatherCondition.Rainy;
                        Precipitation = Utils.RandDouble(0.3, 0.6); // 30-60% intensity
                        WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                        CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                        _weatherDuration = GenerateRandomWeatherDuration(4); // 1-7 hours
                    }
                }
                else // Temperature too cold for rain, adjust to snow
                {
                    CurrentCondition = WeatherCondition.LightSnow;
                    Precipitation = Utils.RandDouble(0.2, 0.5); // 20-50% intensity
                    WindSpeed = Utils.RandDouble(0.2, 0.4);     // 20-40% of max wind
                    CloudCover = Utils.RandDouble(0.7, 0.9);    // 70-90% cloud cover
                    _weatherDuration = GenerateRandomWeatherDuration(5); // 1-9 hours
                }
            }
        }
        else // No precipitation
        {
            // Choose between clear, cloudy or misty
            double clearVsCloudyRoll = Utils.RandDouble(0, 1);

            if (clearVsCloudyRoll < 0.4) // 40% chance for clear
            {
                CurrentCondition = WeatherCondition.Clear;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.1, 0.5);     // 10-50% of max wind
                CloudCover = Utils.RandDouble(0, 0.2);      // 0-20% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(9); // 1-17 hours
            }
            else if (clearVsCloudyRoll < 0.8) // 40% chance for cloudy
            {
                CurrentCondition = WeatherCondition.Cloudy;
                Precipitation = 0;
                WindSpeed = Utils.RandDouble(0.2, 0.6);     // 20-60% of max wind
                CloudCover = Utils.RandDouble(0.5, 0.8);    // 50-80% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(6); // 1-11 hours
            }
            else // 20% chance for misty
            {
                CurrentCondition = WeatherCondition.Misty;
                Precipitation = Utils.RandDouble(0, 0.1);   // 0-10% light moisture
                WindSpeed = Utils.RandDouble(0, 0.2);       // 0-20% of max wind
                CloudCover = Utils.RandDouble(0.6, 0.9);    // 60-90% cloud cover
                _weatherDuration = GenerateRandomWeatherDuration(3); // 1-5 hours
            }
        }
    }

    private TimeSpan GenerateRandomWeatherDuration(int typicalHours = 6)
    {
        // int minHours = 1; // using roll instead which has 1 as default
        int maxHours = (typicalHours * 2) - 1;

        // triangular distribution - similar to normal dist, 
        // where values in the center are more common and extremes are rare
        // kind of like rolling dice, it's rare to roll 3 ones or 3 sixes
        int r1 = Utils.Roll(maxHours);
        int r2 = Utils.Roll(maxHours);
        int r3 = Utils.Roll(maxHours);
        double sum = r1 + r2 + r3;
        double average = sum / 3.0;
        int minutes = (int)(average * 60);
        return TimeSpan.FromMinutes(minutes);
    }

    private double GetTimeOfDayFactor()
    {
        // Returns 0-1 value representing relative temperature (0=coldest, 1=warmest)
        // todo combine this with seasonal day/ night lengths
        int minutesInDay = 24 * 60;
        int coldestTime = 4 * 60; // 4 AM

        int currentMinute = World.Time.Hour * 60 + World.Time.Minute;
        double minSinceColdest = currentMinute - coldestTime;
        double percentOfDay = minSinceColdest / minutesInDay; // scale so .5 is warmest and 0/1 is coldest
        double radians = 2 * Math.PI * percentOfDay; // scale for Cos

        // cos(x) => -1 to 1, but we need to shift to 0-1 so divide by 2 and shift up by 
        // but also the cos function needs to be flipped since cos(0 or 1) = 1, but we want 0 and 1 to be the min, so just * -1
        double temperature = -1 * (Math.Cos(radians) / 2) + .5; // Cos results in -1 to 1, so scale to 0-1 (divide 2, shift)

        return temperature;
    }

    // Convert Celsius to Fahrenheit
    public double TemperatureInFahrenheit => (BaseTemperature * 9 / 5) + 32;

    // Get detailed weather description
    public string GetWeatherDescription()
    {
        string temp = GetTemperatureDescription();
        string conditions = GetConditionsDescription();
        string wind = GetWindDescription();

        return $"{temp} {conditions} {wind}";
    }

    private string GetTemperatureDescription()
    {
        if (BaseTemperature < -25)
            return "It's brutally cold.";
        else if (BaseTemperature < -15)
            return "It's extremely cold.";
        else if (BaseTemperature < -5)
            return "It's very cold.";
        else if (BaseTemperature < 0)
            return "It's freezing cold.";
        else if (BaseTemperature < 5)
            return "It's cold.";
        else if (BaseTemperature < 10)
            return "It's cool.";
        else
            return "It's mild."; // As warm as it gets in Ice Age
    }

    private string GetConditionsDescription()
    {
        switch (CurrentCondition)
        {
            case WeatherCondition.Clear:
                return "The sky is clear.";

            case WeatherCondition.Cloudy:
                return "The sky is cloudy and gray.";

            case WeatherCondition.Misty:
                return "A cold mist hangs in the air.";

            case WeatherCondition.Rainy:
                if (Precipitation < 0.5)
                    return "A cold drizzle is falling.";
                else
                    return "Cold rain is falling steadily.";

            case WeatherCondition.LightSnow:
                if (Precipitation < 0.3)
                    return "A few snowflakes drift through the air.";
                else
                    return "Snow is falling steadily.";

            case WeatherCondition.Blizzard:
                return "A blizzard rages with heavy snow and wind.";

            case WeatherCondition.Stormy:
                return "A thunderstorm rumbles overhead.";

            default:
                return "";
        }
    }

    private string GetWindDescription()
    {
        if (WindSpeed < 0.2)           // 0-20%
            return "The air is still.";
        else if (WindSpeed < 0.4)      // 20-40%
            return "A light breeze blows.";
        else if (WindSpeed < 0.6)      // 40-60%
            return "A cold wind blows steadily.";
        else if (WindSpeed < 0.8)      // 60-80%
            return "Strong, bitter winds howl across the landscape.";
        else                           // 80-100%
            return "Powerful, freezing gusts threaten to knock you over.";
    }

    // Set season
    public void SetSeason(Season season)
    {
        CurrentSeason = season;
        GenerateNewWeather(); // Update weather for new season
    }
}


================================================================================

File: ./Environments/WorldMap.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class WorldMap
    {
        private Dictionary<(int, int), Zone> map = new();

        private int X;
        private int Y;

        public WorldMap(Zone startingZone)
        {
            X = 0;
            Y = 0;
            map.Add((X, Y), startingZone);
            startingZone.Visited = true;
        }

        public Zone CurrentZone => GetZone(X, Y);
        public Zone North => GetZone(X, Y + 1);
        public Zone South => GetZone(X, Y - 1);
        public Zone East => GetZone(X + 1, Y);
        public Zone West => GetZone(X - 1, Y);


        public void MoveNorth() => MoveTo(X, Y + 1);
        public void MoveSouth() => MoveTo(X, Y - 1);
        public void MoveEast() => MoveTo(X + 1, Y);
        public void MoveWest() => MoveTo(X - 1, Y);


        private void MoveTo(int x, int y)
        {
            Zone zone = GetZone(x, y) ?? throw new Exception("Invalid zone.");
            X = x;
            Y = y;
            zone.Visited = true;
        }

        private Zone GetZone(int x, int y)
        {
            Zone? zone = map.GetValueOrDefault((x, y));
            if (zone == null)
            {
                zone = GenerateRandomZone();
                map.Add((x, y), zone);
            }
            return zone;
        }

        private Zone GenerateRandomZone()
        {
            // todo
            return Utils.GetRandomFromList([ZoneFactory.MakeForestZone(), ZoneFactory.MakeCaveSystemZone()]);
        }

    }
}
================================================================================

File: ./Environments/LocationFactory.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Items;

namespace text_survival.Environments;

public static class LocationFactory
{
    public static Location MakeForest(Zone parent)
    {
        // Create a base forest location
        Location location = new Location("Forest", parent);

        // Generate a more descriptive name with ice age theme
        List<string> forestNames = ["Forest", "Woodland", "Grove", "Thicket", "Pine Stand", "Birch Grove"];
        List<string> forestAdjectives = [
            "Frost-bitten", "Snow-laden", "Ice-coated", "Permafrost", "Glacial", "Silent", "Frozen", "Snowy",
            "Windswept", "Frigid", "Boreal", "Primeval", "Shadowy", "Ancient", "Taiga",
             "Frosty", "Dark", "Foggy", "Overgrown",
            "Dense", "Old", "Misty", "Quiet", "Pristine", "Forgotten", "Cold", "Verdant", "Mossy", "Wet"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(forestAdjectives);
        string name = Utils.GetRandomFromList(forestNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with high resource density for forests (1.2)
        ForageFeature forageFeature = new ForageFeature(location, 1.2);

        // Add natural resources to the forage feature - more forest-appropriate items
        forageFeature.AddResource(ItemFactory.MakeBerry, 5.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeWater, 2.0);     // Available but not as common
        forageFeature.AddResource(ItemFactory.MakeMushroom, 4.0);  // Common in forests
        forageFeature.AddResource(ItemFactory.MakeStick, 8.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFirewood, 4.0);   // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 3.0);     // Fairly common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for forest
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Forest));

        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomForestItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);   // Common
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Rare
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (40% chance)
        if (Utils.DetermineSuccess(.5))
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            location.SpawnNpcs(npcCount);
        }

        return location;
    }

    public static Location MakeCave(Zone parent)
    {
        // Create a base cave location
        Location location = new Location("Cave", parent);

        // Generate a more descriptive name with ice age theme
        List<string> caveNames = ["Cave", "Cavern", "Grotto", "Hollow", "Shelter"];
        List<string> caveAdjectives = [
            "Icicle-lined", "Frost-rimmed", "Ice-floored", "Bone-strewn", "Mammoth-bone", "Winding", "Ancient",
            "Hidden", "Ancestral", "Painted", "Rocky", "Echoing", "Ice-walled", "Hibernation",
            "Crystal-ice", "Glacier-carved", "Frosty", "Icy",
            "Dark", "Shadowy", "Damp", "Deep", "Frozen", "Narrow", "Secluded",
            "Granite",  "Glowing",  "Cold", "Crystal", "Protected"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(caveAdjectives);
        string name = Utils.GetRandomFromList(caveNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with moderate resource density for caves (0.8)
        ForageFeature forageFeature = new ForageFeature(location, 0.8);

        // Add resources to the forage feature - cave-appropriate items
        forageFeature.AddResource(ItemFactory.MakeMushroom, 3.0);  // Can find mushrooms in caves
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 2.0);     // More common in caves
        forageFeature.AddResource(ItemFactory.MakeClay, 1.0);      // Near cave entrances
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.3); // Rare but valuable

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for cave
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cave));

        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomCaveItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeSpider, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeRat, 3.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeBat, 4.0);
        npcSpawner.AddActor(NpcFactory.MakeCaveBear, 0.5);
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (50% chance)
        if (Utils.RandInt(0, 9) < 5)
        {
            // Add 1-2 NPCs from the spawner
            int npcCount = Utils.RandInt(1, 2);
            location.SpawnNpcs(npcCount);
        }

        return location;
    }

    public static Location MakeRiverbank(Zone parent)
    {
        // Create a base riverbank location
        Location location = new Location("Riverbank", parent);

        // Generate a more descriptive name with ice age theme
        List<string> riverNames = ["River", "Stream", "Creek", "Brook", "Rapids", "Ford", "Ice-Melt", "Waterfall", "Shallows"];
        List<string> riverAdjectives = [
            "Ice-rimmed", "Glacial", "Snowmelt", "Half-frozen", "Ice-flow", "Narrow", "Mammoth-crossing",
            "Frozen-edged", "Icy", "Slush-filled", "Ice-bridged", "Cold", "Mist-shrouded", "Foggy", "Glacier-fed",
            "Thawing", "Crystalline", "Ice-dammed", "Frigid", "Quiet", "Thundering", "Bone-strewn", "Glistening",
            "Rushing", "Flowing", "Clear", "Muddy", "Wide", "Rocky", "Sandy", "Shallow", "Deep",
            "Misty", "Meandering", "Winding", "Fast-flowing", "Gentle", "Noisy", "Bubbling"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(riverAdjectives);
        string name = Utils.GetRandomFromList(riverNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with good resource density for riverbanks (1.1)
        ForageFeature forageFeature = new ForageFeature(location, 1.1);

        // Add resources to the forage feature - river-appropriate items
        forageFeature.AddResource(ItemFactory.MakeWater, 10.0);    // Very abundant
        forageFeature.AddResource(ItemFactory.MakeFish, 6.0);      // Common
        forageFeature.AddResource(ItemFactory.MakeRoots, 4.0);     // Common near water
        forageFeature.AddResource(ItemFactory.MakeClay, 5.0);      // Common at riverbanks
        forageFeature.AddResource(ItemFactory.MakeStone, 5.0);     // River stones
        forageFeature.AddResource(ItemFactory.MakeFlint, 1.0);     // Occasionally found

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for riverbank
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.RiverBank));

        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomRiverbankItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner for riverbanks
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 2.0);   // Predators come to water
        npcSpawner.AddActor(NpcFactory.MakeBear, 1.0);   // Bears fish at rivers
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (30% chance)
        if (Utils.DetermineSuccess(.3))
        {
            location.SpawnNpcs(1);
        }

        return location;
    }

    public static Location MakePlain(Zone parent)
    {
        // Create a base plains location
        Location location = new Location("Plain", parent);

        // Generate a more descriptive name with ice age theme
        List<string> plainNames = ["Plain", "Steppe", "Tundra", "Mammoth Grounds", "Permafrost", "Glacier-edge", "Grassland", "Prairie", "Meadow"];
        List<string> plainAdjectives = [
            "Windswept", "Permafrost", "Glacial", "Frozen", "Vast", "Rolling", "Endless", "Mammoth-trampled",
            "Snow-covered", "Ice-plain", "Desolate", "Frosty", "Exposed", "Bison-grazed",
            "Bleak", "Stark", "Harsh", "Woolly", "Flat", "Frost-cracked", "Mammoth",
            "Open", "Windy", "Cold", "Barren", "Grassy", "Empty", "Rocky", "Wild"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(plainAdjectives);
        string name = Utils.GetRandomFromList(plainNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with low-moderate resource density for plains (0.7)
        ForageFeature forageFeature = new ForageFeature(location, 0.7);

        // Add resources to the forage feature - plains-appropriate items
        forageFeature.AddResource(ItemFactory.MakeRoots, 6.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeBerry, 2.0);     // Less common
        forageFeature.AddResource(ItemFactory.MakeStick, 1.0);     // Rare (few trees)
        forageFeature.AddResource(ItemFactory.MakeStone, 4.0);     // Common
        forageFeature.AddResource(ItemFactory.MakeFlint, 0.5);     // Rare

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for open plain
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.OpenPlain));

        // Add initial visible items
        int itemCount = Utils.RandInt(1, 3);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomPlainsItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner - plains have megafauna!
        var npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 3.0);               // Common
        npcSpawner.AddActor(NpcFactory.MakeWoollyMammoth, 0.5);      // Rare but possible
        npcSpawner.AddActor(NpcFactory.MakeSaberToothTiger, 0.7);    // Uncommon
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (40% chance)
        if (Utils.DetermineSuccess(.4))
        {
            location.SpawnNpcs(1);
        }

        return location;
    }

    public static Location MakeHillside(Zone parent)
    {
        // Create a base hillside location
        Location location = new Location("Hillside", parent);

        // Generate a more descriptive name with ice age theme
        List<string> hillNames = ["Ridge", "Moraine", "Slope", "Drift", "Crag", "Bluff", "Outcrop", "Hill", "Hillside", "Knoll"];
        List<string> hillAdjectives = [
            "Glacier-carved", "Ice-cracked", "Snow-swept", "Wind-scoured", "Ice-exposed", "Frost-heaved", "Craggy",
            "Rugged", "Snow-capped", "Icy", "Ice-scarred", "Stone", "High", "Misty", "Frost-shattered",
            "Eroded", "Ancient", "Mammoth-trail", "Granite", "Shaded", "Splintered",
            "Rocky", "Steep", "Gentle", "Windswept", "Exposed", "Barren", "Weathered",
            "Protected", "Treacherous", "Cold", "Foggy"
        ];

        // Pick a random adjective and name
        string adjective = Utils.GetRandomFromList(hillAdjectives);
        string name = Utils.GetRandomFromList(hillNames);
        location.Name = (adjective + " " + name).Trim();

        // Create a ForageFeature with moderate resource density for hillsides (0.9)
        ForageFeature forageFeature = new ForageFeature(location, 0.9);

        // Add resources to the forage feature - hillside-appropriate items
        forageFeature.AddResource(ItemFactory.MakeStone, 8.0);        // Very common
        forageFeature.AddResource(ItemFactory.MakeFlint, 3.0);        // More common on hillsides
        forageFeature.AddResource(ItemFactory.MakeObsidianShard, 0.5); // Rare but possible
        forageFeature.AddResource(ItemFactory.MakeRoots, 2.0);         // Less common
        forageFeature.AddResource(ItemFactory.MakeOchrePigment, 1.0);  // Sometimes found on hills

        // Add the forage feature to the location's features
        location.Features.Add(forageFeature);

        // Add an environment feature for hillside (using cliff as closest match)
        location.Features.Add(new EnvironmentFeature(location, EnvironmentFeature.LocationType.Cliff));

        // Add initial visible items
        int itemCount = Utils.RandInt(2, 4);
        for (int i = 0; i < itemCount; i++)
        {
            Item item = GetRandomHillsideItem();
            location.Items.Add(item);
        }

        // Configure the NPC spawner for hillsides
        NpcTable npcSpawner = new NpcTable();
        npcSpawner.AddActor(NpcFactory.MakeWolf, 1.0);
        npcSpawner.AddActor(NpcFactory.MakeSnake, 2.0);    // Snakes like rocky areas
        location.NpcSpawner = npcSpawner;

        // Determine if we should add NPCs initially (30% chance)
        if (Utils.DetermineSuccess(.3))
        {
            location.SpawnNpcs(1);
        }

        return location;
    }

    // Helper methods to generate random location-appropriate items

    private static Item GetRandomForestItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 5.0 },
            { ItemFactory.MakeBerry, 4.0 },
            { ItemFactory.MakeStick, 8.0 },
            { ItemFactory.MakeFirewood, 5.0 },
            { ItemFactory.MakeTorch, 0.5 },
            { ItemFactory.MakeSpear, 0.2 },
            { ItemFactory.MakeHealingHerbs, 1.0 }
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomCaveItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeMushroom, 4.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 3.0 },
            { ItemFactory.MakeTorch, 1.0 },
            { ItemFactory.MakeBone, 4.0 },
            { ItemFactory.MakeObsidianShard, 0.5 },
            { ItemFactory.MakeOchrePigment, 0.2 }
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomRiverbankItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeWater, 8.0 },
            { ItemFactory.MakeFish, 5.0 },
            { ItemFactory.MakeClay, 6.0 },
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 2.0 },
            { ItemFactory.MakeRoots, 3.0 }
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomPlainsItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeRoots, 6.0 },
            { ItemFactory.MakeStone, 5.0 },
            { ItemFactory.MakeBone, 3.0 },
            { ItemFactory.MakeSinew, 1.0 },
            { ItemFactory.MakeBerry, 2.0 },
            { ItemFactory.MakeMammothTusk, 0.1 } // Very rare find
        };

        return Utils.GetRandomWeighted(options)();
    }

    private static Item GetRandomHillsideItem()
    {
        var options = new Dictionary<Func<Item>, double> {
            { ItemFactory.MakeStone, 8.0 },
            { ItemFactory.MakeFlint, 5.0 },
            { ItemFactory.MakeObsidianShard, 1.0 },
            { ItemFactory.MakeOchrePigment, 2.0 },
            { ItemFactory.MakeHandAxe, 0.2 }
        };

        return Utils.GetRandomWeighted(options)();
    }
}================================================================================

File: ./Environments/Location.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Actors;
using text_survival.IO;
using text_survival.Items;

namespace text_survival.Environments;

public class Location
{
    public string Name;
    public bool Visited = false;
    public bool IsFound { get; set; } = false;
    public IReadOnlyList<Npc> Npcs =>_npcs.AsReadOnly();
    private List<Npc> _npcs = [];
    public List<Item> Items = [];
    public List<Container> Containers = [];
    virtual public Zone Parent { get; }
    public List<LocationFeature> Features = [];

    #region Initialization

    public Location(string name, Zone parent)
    {
        Name = name;
        Parent = parent;
        NpcSpawner = new();
    }

    public T? GetFeature<T>() where T : LocationFeature => Features.OfType<T>().FirstOrDefault();

    public void SpawnNpcs(int numNpcs)
    {
        for (int i = 0; i < numNpcs; i++)
        {
            var npc = NpcSpawner.GenerateRandom();
            if (npc is not null)
            {
                _npcs.Add(npc);
                npc.CurrentLocation = this;
            }
        }
    }
    public virtual NpcTable NpcSpawner { get; set; }


    #endregion Initialization
    public void Interact(Player player)
    {
        Output.WriteLine("You consider heading to the " + Name + "...");
        Output.WriteLine("Do you want to go there? (y/n)");
        if (Input.ReadYesNo())
        {
            player.CurrentLocation = this;
        }
        else
        {
            Output.WriteLine("You decide to stay.");
        }
    }
    
    public double GetTemperature()
    {
        // Get zone's weather temperature (in Fahrenheit)
        double zoneTemp = Parent.Weather.TemperatureInFahrenheit;

        // Start with this base temperature
        double locationTemp = zoneTemp;

        // ------ STEP 1: Apply inherent location modifiers ------
        double overheadCoverage = 0;
        double windProtection = 0;
        var locationType = GetFeature<EnvironmentFeature>();
        if (locationType != null)
        {
            locationTemp += locationType.TemperatureModifier;
            overheadCoverage = locationType.NaturalOverheadCoverage;
            windProtection = locationType.NaturalWindProtection;
        }

        // ------ STEP 2: Apply weather exposure effects ------
        // Wind chill when windy
        double effectiveWindSpeed = 0;
        if (Parent.Weather.WindSpeed > 0.1) // Only significant wind
        {
            effectiveWindSpeed = Parent.Weather.WindSpeed * (1 - windProtection);
            double windSpeedMph = effectiveWindSpeed * 30; // Scale 0-1 to approx mph
            locationTemp = CalculateWindChillNWS(locationTemp, windSpeedMph);
        }

        // Sun warming effects during daytime with clear skies
        double sunIntensity = Parent.Weather.SunlightIntensity;
        double sunExposure = 1 - overheadCoverage;
        // Sun can add up to 10°F on a cold day
        double sunWarming = sunIntensity * sunExposure * 10;

        // Sun effect is more noticeable when cold
        double temperatureAdjustment = sunWarming * Math.Max(0.5, Math.Min(1, (50 - locationTemp) / 30));
        locationTemp += temperatureAdjustment;

        // Precipitation effects
        double precipitation = Parent.Weather.Precipitation;
        precipitation *= 1 - overheadCoverage;
        // todo, determine if this effects temp directly or if we use this elsewhere 
        double precipitationCooling = precipitation * 5; //  simple up to 5°F cooling for now
        locationTemp -= precipitationCooling * (1 - overheadCoverage);

        // ------ STEP 3: Apply shelter effects if present ------
        double insulation = 0;
        var shelter = GetFeature<ShelterFeature>();
        if (shelter != null)
        {
            // Start with minimum temperature a shelter can maintain (in °F)
            double minShelterTemp = 40; // About 4.4°C, what a good shelter can maintain from body heat
            // Calculate warming effect based on insulation quality
            double tempDifference = minShelterTemp - locationTemp;
            insulation = Math.Clamp(shelter.TemperatureInsulation, 0, .9); // cap at 90%
            insulation *= 1 - (precipitation * .3); // precipitation can reduce insulation up to 30%
            insulation *= 1 - (effectiveWindSpeed * .3); // and wind another 30 on top of that

            locationTemp += tempDifference * insulation;
        }

        // If there's a heat source, add its effect
        var heatSource = GetFeature<HeatSourceFeature>();
        if (heatSource != null && heatSource.IsActive)
        {
            // Insulation increases effectiveness of heat sources
            double heatEffect = heatSource.HeatOutput * Math.Max(insulation, .40); // heat sources are less effective outside
            locationTemp += heatEffect;
        }

        return locationTemp;
    }

    public double CalculateWindChillNWS(double temperatureF, double windSpeedMph)
    {
        // NWS formula is only valid for temperatures <= 50°F and wind speeds >= 3 mph
        if (temperatureF > 50 || windSpeedMph < 3)
        {
            return temperatureF;
        }
        // Calculate using the NWS Wind Chill Temperature (WCT) formula
        // https://www.weather.gov/media/epz/wxcalc/windChill.pdf
        // WCT = 35.74 + 0.6215T - 35.75(V^0.16) + 0.4275T(V^0.16)
        // Where T = Air Temperature (°F), V = Wind Speed (mph)
        double windPowFactor = Math.Pow(windSpeedMph, 0.16);
        return 35.74 + (0.6215 * temperatureF) - (35.75 * windPowFactor) + (0.4275 * temperatureF * windPowFactor);
    }

    public void Update()
    {
        // Locations.ForEach(i => i.Update());
        _npcs.ForEach(n => n.Update());
    }

    public List<Location> GetNearbyLocations()
    {
        List<Location> nearbyLocations = [];
        if (Parent.Locations.Count > 0)
        {
            foreach (var location in Parent.Locations)
            {
                if (location == this)
                    continue;
                nearbyLocations.Add(location);
            }
        }
        return nearbyLocations;
    }

    public override string ToString() => Name;
}================================================================================

File: ./Environments/ZoneFactory.cs
--------------------------------------------------------------------------------
namespace text_survival.Environments;

public static class ZoneFactory
{
    public static Zone MakeForestZone(string name = "", string description = "", double baseTemp = 20)
    {
        // Create a location table specifically for forest locations
        LocationTable forestLocationTable = new LocationTable();
        
        // Add various forest location types with appropriate weights
        forestLocationTable.AddFactory(LocationFactory.MakeForest, 3.0); // Most common
        
        // You can add more forest-related locations here when implemented
        // forestLocationTable.AddFactory(LocationFactory.MakeTrail, 2.0);
        // forestLocationTable.AddFactory(LocationFactory.MakeRiverbank, 1.5);
        // forestLocationTable.AddFactory(LocationFactory.MakeHillside, 1.0);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> forestZoneNames = ["Forest", "Woods", "Woodland", "Taiga", "Wildwood", "Timberland", "Pine Forest", "Birch Forest"];
            List<string> forestZoneAdjectives = [
                "", "Deep", "Ancient", "Verdant", "Mysterious", "Shadowy", "Enchanted", "Wild", "Dark", "Dense", 
                "Northern", "Southern", "Eastern", "Western", "Frozen", "Boreal", "Glacial", "Snowy", "Frost-rimmed", 
                "Ice-laden", "Primeval", "Rime-covered", "Mammoth", "Misty", "Foggy"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(forestZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(forestZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> forestDescriptions = [
                "A vast expanse of snow-covered trees stretching as far as the eye can see.",
                "Frost-covered trees with icicles hanging from branches, filtering weak sunlight to the forest floor.",
                "A quiet forest with the occasional sounds of wildlife echoing through the icy stillness.",
                "Evergreen trees stand tall amidst the snow, creating a sanctuary for cold-adapted creatures.",
                "A sprawling woodland with ice-crusted paths winding between ancient trees and frozen undergrowth.",
                "Mammoth trails wind between the massive tree trunks, where herds seek shelter from the harsh winds.",
                "Rime-covered trees glisten in the pale light, their branches laden with snow and ice.",
                "The forest floor is covered with a thick blanket of snow, punctuated by animal tracks.",
                "Shadows stretch long across the pristine snow as sunlight filters through the dense canopy.",
                "Ancient pines stand as sentinels, their needles heavy with frost and snow."
            ];
            
            description = Utils.GetRandomFromList(forestDescriptions);
        }
        
        // Create and return the forest zone
        return new Zone(name, description, forestLocationTable, baseTemp);
    }
    
    public static Zone MakeCaveSystemZone(string name = "", string description = "", double baseTemp = 10)
    {
        // Create a location table specifically for cave system locations
        LocationTable caveLocationTable = new LocationTable();
        
        // Add various cave location types with appropriate weights
        caveLocationTable.AddFactory(LocationFactory.MakeCave, 3.0); // Most common
        
        // You can add more cave-related locations here when implemented
        // caveLocationTable.AddFactory(LocationFactory.MakeTrail, 1.0); // Cave entrance trails
        // caveLocationTable.AddFactory(LocationFactory.MakeHillside, 1.5); // Cave entrances in hillsides
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> caveZoneNames = [
                "Cave System", "Caverns", "Underground Complex", "Grotto Network", "Subterranean Labyrinth",
                "Cave Refuge", "Ice Caverns", "Shelter System", "Hibernation Caves", "Painted Caves"
            ];
            List<string> caveZoneAdjectives = [
                "", "Deep", "Ancient", "Crystal", "Mysterious", "Dark", "Echoing", "Forgotten", "Hidden", "Vast", "Winding",
                "Frost-lined", "Ice-walled", "Glacial", "Ancestral", "Bone-filled", "Mammoth", "Protected", "Ritual",
                "Clan", "Fur-lined", "Warm", "Painted", "Firelit"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(caveZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(caveZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> caveDescriptions = [
                "A maze of dark tunnels and chambers offering refuge from the harsh ice age climate.",
                "A network of interconnected caves with icicles and ice formations hanging from the ceiling.",
                "Warm, sheltered caverns with the sound of meltwater dripping echoing in the darkness.",
                "An intricate system of underground passages formed by ancient glacial movements.",
                "A sprawling subterranean network with chambers used by clans for shelter and ritual.",
                "Cave walls adorned with ancient paintings depicting mammoth hunts and clan ceremonies.",
                "Floors littered with bones and artifacts from generations of human habitation.",
                "Narrow passages opening to large chambers where fires have burned for countless seasons.",
                "Ancestral shelters where generations have found protection from the deadly cold.",
                "Ice-rimmed entrances leading to surprisingly warm chambers deep within the earth."
            ];
            
            description = Utils.GetRandomFromList(caveDescriptions);
        }
        
        // Create and return the cave system zone with cooler base temperature
        return new Zone(name, description, caveLocationTable, baseTemp);
    }
    
    public static Zone MakeTundraZone(string name = "", string description = "", double baseTemp = 0)
    {
        // Create a location table specifically for tundra locations
        LocationTable tundraLocationTable = new LocationTable();
        
        // Add various tundra location types with appropriate weights
        tundraLocationTable.AddFactory(LocationFactory.MakePlain, 4.0); // Most common
        // tundraLocationTable.AddFactory(LocationFactory.MakeHillside, 2.0);
        // tundraLocationTable.AddFactory(LocationFactory.MakeRiverbank, 1.5);
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> tundraZoneNames = [
                "Tundra", "Steppe", "Plains", "Mammoth Plains", "Permafrost", "Ice Fields", 
                "Frozen Expanse", "Glacier Edge", "Frost Plains", "Hunting Grounds"
            ];
            List<string> tundraZoneAdjectives = [
                "", "Vast", "Windswept", "Endless", "Frozen", "Desolate", "Barren", "Ancient", 
                "Mammoth", "Glacial", "Northern", "Pristine", "Inhospitable", "Snow-covered", 
                "Primal", "Harsh", "Woolly", "Thundering", "Game-rich", "Megafauna"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(tundraZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(tundraZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> tundraDescriptions = [
                "An endless expanse of snow and ice, where mighty herds of woolly mammoth roam.",
                "Windswept plains stretching to the horizon, where only the hardiest plants survive.",
                "Wide open spaces where great herds of ice age megafauna gather to graze.",
                "A harsh landscape dominated by permafrost and spotted with patches of tough grasses.",
                "Snow-covered plains where saber-toothed predators stalk their mammoth prey.",
                "Vast open tundra where the wind howls unimpeded across the frozen landscape.",
                "The thunder of mammoth herds can be heard across these ancient hunting grounds.",
                "A stark but beautiful landscape of ice, snow, and occasional hardy vegetation.",
                "Glacial plains carved by the retreating ice sheet, leaving a harsh but life-filled realm.",
                "The domain of the woolly mammoth, where these giants travel in family groups across the snow."
            ];
            
            description = Utils.GetRandomFromList(tundraDescriptions);
        }
        
        // Create and return the tundra zone with much colder base temperature
        return new Zone(name, description, tundraLocationTable, baseTemp);
    }
    
    public static Zone MakeRiverValleyZone(string name = "", string description = "", double baseTemp = 15)
    {
        // Create a location table specifically for river valley locations
        LocationTable riverValleyLocationTable = new LocationTable();
        
        // Add various river valley location types with appropriate weights
        riverValleyLocationTable.AddFactory(LocationFactory.MakeRiverbank, 4.0); // Most common
        // riverValleyLocationTable.AddFactory(LocationFactory.MakeForest, 2.0); // Riverside forests
        // riverValleyLocationTable.AddFactory(LocationFactory.MakeHillside, 1.5); // Valley sides
        
        // Generate a name if one wasn't provided
        if (string.IsNullOrEmpty(name))
        {
            List<string> riverZoneNames = [
                "River Valley", "Waterway", "Glacial Valley", "River Basin", "Floodplain", 
                "Stream Network", "River Lands", "Meltwater Valley", "River Territory"
            ];
            List<string> riverZoneAdjectives = [
                "", "Winding", "Frozen", "Ancient", "Deep", "Fertile", "Ice-carved", "Glacier-fed", 
                "Protected", "Sheltered", "Resource-rich", "Fish-filled", "Life-giving", "Abundant",
                "Clay-rich", "Game-rich", "Meandering", "Mammoth-crossed"
            ];
            
            // Pick a random adjective and name
            string adjective = Utils.GetRandomFromList(riverZoneAdjectives);
            string zoneName = Utils.GetRandomFromList(riverZoneNames);
            name = (adjective + " " + zoneName).Trim();
        }
        
        // Generate a description if one wasn't provided
        if (string.IsNullOrEmpty(description))
        {
            List<string> riverDescriptions = [
                "A network of glacier-fed rivers and streams cutting through the icy landscape.",
                "Partially frozen waterways that provide essential resources for all life in the region.",
                "A river valley carved by ancient glacial movements, now home to diverse ice age life.",
                "Ice-rimmed waters flowing through a sheltered valley, attracting animals from miles around.",
                "A life-giving river system where clay, fish, and fresh water can be harvested.",
                "Mammoth herds gather along these banks to drink and bathe in the cold waters.",
                "The sound of rushing water breaks the winter silence as the river cuts through ice and snow.",
                "A critical resource in the frozen world, this river network sustains countless creatures.",
                "Ancient humans have left traces of their camps along these fertile riverbanks for generations.",
                "Where ice meets flowing water, creating a unique ecosystem in the frozen landscape."
            ];
            
            description = Utils.GetRandomFromList(riverDescriptions);
        }
        
        // Create and return the river valley zone with slightly warmer base temperature
        return new Zone(name, description, riverValleyLocationTable, baseTemp);
    }
    
    // // Method to create a complete ice age world with multiple zones
    // public static List<Zone> CreateIceAgeWorld()
    // {
    //     List<Zone> world = new List<Zone>();
        
    //     // Create various zones with ice age appropriate base temperatures
    //     Zone forestZone = MakeForestZone(baseTemp: 10); // Colder than default
    //     world.Add(forestZone);
        
    //     Zone caveZone = MakeCaveSystemZone(baseTemp: 5); // Even colder caves
    //     world.Add(caveZone);
        
    //     Zone tundraZone = MakeTundraZone(); // Already very cold (0)
    //     world.Add(tundraZone);
        
    //     Zone riverValleyZone = MakeRiverValleyZone(baseTemp: 8); // Slightly warmer than surroundings but still cold
    //     world.Add(riverValleyZone);
        
    //     return world;
    // }
}================================================================================

File: ./Environments/LocationFeatures.cs/ForageFeature.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;
using text_survival.Items;

namespace text_survival.Environments;

public class ForageFeature(Location location, double resourceDensity = 1) : LocationFeature("forage", location)
{
    private double baseResourceDensity = resourceDensity;
    private int numberOfHoursForaged = 0;
    private Dictionary<Func<Item>, double> resourceRarities = [];
    private double ResourceDensity => baseResourceDensity / (numberOfHoursForaged + 1);

    public void Forage(int hours)
    {
        // todo: change the order of operations here
        List<Item> itemsFound = [];
        foreach (Func<Item> factory in resourceRarities.Keys)
        {
            double chance = ResourceDensity * resourceRarities[factory];

            for (int i = 0; i < hours; i++)
            {
                if (Utils.DetermineSuccess(chance))
                {
                    var item = factory();
                    Output.Write("You found: ", item);
                    item.IsFound = true;
                    ParentLocation.Items.Add(item);
                    numberOfHoursForaged++;
                }
            }
        }
        World.Update(hours * 60);
    }

    public void AddResource(Func<Item> factory, double rarity)
    {
        resourceRarities.Add(factory, rarity);
    }
}
================================================================================

File: ./Environments/LocationFeatures.cs/EnvironmentFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class EnvironmentFeature : LocationFeature
{
    public enum LocationType
    {
        OpenPlain,      // No natural shelter
        Forest,         // Trees provide some wind/rain protection
        Cave,           // Natural temperature moderation
        Cliff,          // Wind protection from one direction
        RiverBank,      // Water nearby, but exposure
        HighGround      // More wind but better visibility
    }
    private LocationType Type;
    public double TemperatureModifier { get; } = 0; // degrees F adjustment
    public double NaturalOverheadCoverage { get; } = 0;
    public double NaturalWindProtection { get; } = 0;

    public EnvironmentFeature(Location location, double tempModifier, double overheadCoverage, double windProtection) : base("shelter", location)
    {
        TemperatureModifier = tempModifier;
        NaturalOverheadCoverage = overheadCoverage;
        NaturalWindProtection = windProtection;
    }
    public EnvironmentFeature(Location location, LocationType type)
        : base("locationType", location)
    {
        Type = type;

        switch (type)
        {
            case LocationType.Forest:
                NaturalWindProtection = 0.4;     // 40% wind reduction
                NaturalOverheadCoverage = 0.3;   // 30% precipitation protection
                TemperatureModifier = 3.0;       // 3°F warmer in winter, cooler in summer
                break;

            case LocationType.Cave:
                NaturalWindProtection = 0.9;     // 90% wind protection
                NaturalOverheadCoverage = 0.95;  // 95% precipitation protection
                TemperatureModifier = 15.0;      // 15°F warmer in winter, cooler in summer
                break;

            case LocationType.Cliff:
                NaturalWindProtection = 0.6;     // 60% wind protection
                NaturalOverheadCoverage = 0.2;   // 20% precipitation protection
                TemperatureModifier = 2.0;       // 2°F temperature moderation
                break;

            case LocationType.RiverBank:
                NaturalWindProtection = 0.1;     // 10% wind protection
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -2.0;      // 2°F cooler from water proximity
                break;

            case LocationType.HighGround:
                NaturalWindProtection = -0.2;    // 20% increased wind
                NaturalOverheadCoverage = 0.0;   // No precipitation protection
                TemperatureModifier = -4.0;      // 4°F cooler from elevation
                break;

            case LocationType.OpenPlain:
            default:
                NaturalWindProtection = 0.0;
                NaturalOverheadCoverage = 0.0;
                TemperatureModifier = 0.0;
                break;
        }
    }

    // Get description of the location type
    public string GetDescription()
    {
        return Type switch
        {
            LocationType.Forest => "A forest with trees providing some shelter from the elements.",
            LocationType.Cave => "A cave offering protection from wind and precipitation.",
            LocationType.Cliff => "A cliff face providing some protection from the wind.",
            LocationType.RiverBank => "The bank of a river, exposed but with access to water.",
            LocationType.HighGround => "Higher elevation with increased exposure to wind.",
            LocationType.OpenPlain => "An open area with no natural protection.",
            _ => "An undefined location type."
        };
    }

}================================================================================

File: ./Environments/LocationFeatures.cs/HeatSourceFeature.cs
--------------------------------------------------------------------------------
using text_survival.Environments;

public class HeatSourceFeature : LocationFeature
{
    public bool IsActive { get; private set; }
    public double HeatOutput { get; private set; } // In Fahrenheit
    public double FuelRemaining { get; private set; } 
    public double FuelConsumptionRate { get; private set; } // Per hour
    
    public HeatSourceFeature(Location location, double heatOutput = 15.0) 
        : base("heatSource", location)
    {
        IsActive = false;
        HeatOutput = heatOutput; // Default 15°F increase
        FuelRemaining = 0;
        FuelConsumptionRate = 1; // default
    }
    
    /// <summary>
    /// Note, max 10 hours of burn time
    /// </summary>
    /// <param name="hours"></param>
    public void AddFuel(double hours)
    {
        FuelRemaining = Math.Min(1.0, FuelRemaining + hours);

        // Activate if adding fuel to inactive source
        if (!IsActive && FuelRemaining > 0)
            IsActive = true;
    }
    
    // Update for fuel consumption
    public void Update(TimeSpan elapsed)
    {
        if (!IsActive || FuelRemaining <= 0)
            return;
            
        // Calculate fuel consumption
        double hoursElapsed = elapsed.TotalHours;
        double fuelUsed = FuelConsumptionRate * hoursElapsed;
        
        FuelRemaining = Math.Max(0, FuelRemaining - fuelUsed);
        
        // Deactivate if out of fuel
        if (FuelRemaining <= 0)
            IsActive = false;
    }
    
    // Manually activate/deactivate
    public void SetActive(bool active)
    {
        // Can only activate if there's fuel
        if (active && FuelRemaining > 0)
            IsActive = true;
        else if (!active)
            IsActive = false;
    }
}================================================================================

File: ./Environments/LocationFeatures.cs/LocationFeature.cs
--------------------------------------------------------------------------------

using text_survival.Survival;

namespace text_survival.Environments;

public abstract class LocationFeature
{
    public string Name { get; private set; }
    protected Location ParentLocation { get; private set; }
    public LocationFeature(string name, Location location)
    {
        Name = name;
        ParentLocation = location;
    }
    // public virtual void Initialize() { }
    // public virtual void Update() { }
}



================================================================================

File: ./Environments/LocationFeatures.cs/ShelterFeature.cs
--------------------------------------------------------------------------------
using text_survival;
using text_survival.Environments;

public class ShelterFeature : LocationFeature
{
    // todo add enums and presets like environment features
    public double TemperatureInsulation { get; } = 0; // ambient temp protection 0-1
    public double OverheadCoverage { get; } = 0; // rain / snow / sun protection 0-1
    public double WindCoverage { get; } = 0; // wind protection 0-1
    // public double Durability {get; private}
    public ShelterFeature(Location location, double tempInsulation, double overheadCoverage, double windCoverage) : base("shelter", location)
    {
        TemperatureInsulation = tempInsulation;
        OverheadCoverage = overheadCoverage;
        WindCoverage = windCoverage;
    }
    
}================================================================================

File: ./Environments/Zone.cs
--------------------------------------------------------------------------------
﻿
namespace text_survival.Environments
{
    public class Zone
    {
        public string Name { get; }
        public string Description { get; }
        public bool Visited = false;
        private double BaseTemperature { get; }
        public int Elevation { get; }
        public virtual List<Location> Locations { get; } = [];
        private LocationTable LocationTable;
        public ZoneWeather Weather;


        public Zone(string name, string description, LocationTable locationTable, double baseTemp = 20, int elevation = 0)
        {
            Name = name;
            Description = description;
            BaseTemperature = baseTemp;
            Elevation = elevation;
            LocationTable = locationTable;
            Weather = new(this);
            if (!LocationTable.IsEmpty())
            {
                for (int i = 0; i < 3; i++)
                {
                    Locations.Add(LocationTable.GenerateRandom(this));
                }
            }

        }

        public void Update()
        {
            Locations.ForEach(x => x.Update());
        }

        public override string ToString() => Name;

    }
}
================================================================================

File: ./World.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;

namespace text_survival
{
    public static class World
    {
        public static TimeOnly Time { get; set; } = new TimeOnly(hour: 9, minute: 0);

        public static Player? Player { get; set; }
        public static void Update(int minutes)
        {
            for (int i = 0; i < minutes; i++)
            {
                Player?.Update();
                Player?.CurrentZone.Update();
                Time = Time.AddMinutes(1);
            }
        }

        public enum TimeOfDay
        {
            Night,
            Dawn,
            Morning,
            Afternoon,
            Noon,
            Evening,
            Dusk
        }

        public static TimeOfDay GetTimeOfDay()
        {
            return Time.Hour switch
            {
                < 5 => TimeOfDay.Night,
                < 6 => TimeOfDay.Dawn,
                < 11 => TimeOfDay.Morning,
                < 13 => TimeOfDay.Noon,
                < 17 => TimeOfDay.Afternoon,
                < 20 => TimeOfDay.Evening,
                < 21 => TimeOfDay.Dusk,
                _ => TimeOfDay.Night
            };
        }

    }
}
================================================================================

File: ./IO/Output.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actions;
using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival.IO
{
    public static class Output
    {
        public static int SleepTime = 200;
        public static ConsoleColor DetermineTextColor(object x)
        {
            return x switch
            {
                string => ConsoleColor.White,
                int or float or double => ConsoleColor.Green,
                Npc => ConsoleColor.Red,
                Item => ConsoleColor.Cyan,
                Container => ConsoleColor.Yellow,
                Player => ConsoleColor.Green,
                Zone => ConsoleColor.Blue,
                Location => ConsoleColor.DarkBlue,
                Enum => ConsoleColor.Gray,
                IGameAction => ConsoleColor.White,
                null => ConsoleColor.Red,
                _ => ConsoleColor.Red,
            };
        }

        public static void Write(params object[] args)
        {
            foreach (var arg in args)
            {
                string text = GetFormattedText(arg);
                if (Console.ForegroundColor == ConsoleColor.White)
                {
                    Console.ForegroundColor = DetermineTextColor(arg);
                }
                Console.Write(text);
                Console.ForegroundColor = ConsoleColor.White;
                Thread.Sleep(SleepTime);
            }
        }

        private static string GetFormattedText(params object[] args)
        {
            string result = string.Empty;

            foreach (var arg in args)
            {
                switch (arg)
                {
                    case float f:
                        result += $"{f:F1}";
                        break;
                    case double d:
                        result += $"{d:F1}";
                        break;
                    case null:
                        result += "[NULL]";
                        break;
                    default:
                        result += arg.ToString();
                        break;
                }
            }
            return result;

        }

        public static void WriteLine(params object[] args)
        {
            Write(args);
            Write("\n");
        }


        public static void WriteWarning(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Yellow;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        public static void WriteDanger(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Red;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }

        internal static void WriteSuccess(string str)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Green;
            WriteLine(str);
            Console.ForegroundColor = oldColor;
        }
    }
}
================================================================================

File: ./IO/Input.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.IO
{
    public static class Input
    {
        private static ManualResetEvent manualResetEvent = new ManualResetEvent(false);
        // private static string userInput;
        // public static void OnUserInputReceived(string input)
        // {
        //     userInput = input;
        //     manualResetEvent.Set();
        // }
        public static string Read()
        {
            string? input = "";
            if (Config.io == Config.IOType.Console)
            {
                input = Console.ReadLine();
            }
            else if (Config.io == Config.IOType.Web)
            {
                // await user input from web
                //input = AwaitInput();
                throw new NotImplementedException();
            }

            return input ?? "";
        }

        // public static string AwaitInput()
        // {
        //     manualResetEvent.WaitOne();
        //     manualResetEvent.Reset();
        //     return userInput;
        // }

        public static int ReadInt()
        {
            while (true)
            {
                string? input = Read();
                if (int.TryParse(input, out int result))
                {
                    return result;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number.\n");
                }
            }
        }

        public static int ReadInt(int low, int high)
        {
            while (true)
            {
                int input = ReadInt();
                if (input >= low && input <= high)
                {
                    Output.WriteLine();
                    return input;
                }
                else
                {
                    Output.Write("Invalid input. Please enter a number between ", low, " and ", high, ".\n");
                }
            }
        }

        public static bool ReadYesNo()
        {
            while (true)
            {
                string? input = Read().Trim().ToLower();
                if (input == "y" || input == "yes")
                {
                    return true;
                }
                else if (input == "n" || input == "no")
                {
                    return false;
                }
                else
                {
                    Output.Write("Invalid input. Please enter 'y' or 'n'.\n");
                }
            }
        }

        public static T? GetSelectionFromList<T>(List<T> list, bool cancelOption = false, string cancelMessage = "Cancel")
        {
            list.ForEach(i =>
            {
                if (i != null) Output.WriteLine(list.IndexOf(i) + 1, ". ", i);
            });

            int input;
            if (cancelOption)
            {
                Output.WriteLine(0, ". ", cancelMessage);
                input = ReadInt(0, list.Count);
                if (input == 0)
                {
                    return default;
                }
            }
            else
            {
                input = ReadInt(1, list.Count);
            }

            return list[input - 1];
        }
    }
}
================================================================================

File: ./Command.cs
--------------------------------------------------------------------------------
﻿// namespace text_survival
// {
//     public interface ICommand
//     {
//         public string Name { get; set; }
//         public void Execute();
//     }


//     public class Command<TPlayer> : ICommand
//     {
//         public string Name { get; set; }
//         public Action<TPlayer> Act { get; set; }
//         public TPlayer? Player { get; set; }

//         public Command(string name, Action<TPlayer> act)
//         {
//             Name = name;
//             Act = act;
//         }

//         public void Execute()
//         {
//             if (Player == null)
//             {
//                 throw new Exception("Player is null");
//             }
//             Act.Invoke(Player);
//         }

//         public override string ToString() => Name;
//     }
// }
================================================================================

File: ./CombatNarrator.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Items;

namespace text_survival;

public static class CombatNarrator
{
    private static readonly Dictionary<WeaponClass, List<string>> AttackVerbs = new()
    {
        { WeaponClass.Blade, new List<string> { "slashes", "cuts", "slices", "carves" } },
        { WeaponClass.Blunt, new List<string> { "bashes", "strikes", "smashes", "cracks" } },
        { WeaponClass.Pierce, new List<string> { "stabs", "pierces", "impales", "punctures" } },
        { WeaponClass.Claw, new List<string> { "tears", "rips", "rends", "shreds" } },
        { WeaponClass.Unarmed, new List<string> { "punches", "strikes", "hits", "pounds" } }
    };

    private static readonly Dictionary<WeaponType, List<string>> SpecialAttackDescriptions = new()
    {
        { WeaponType.Spear, new List<string> { "lunges with", "thrusts forward with", "strikes with" } },
        { WeaponType.Claws, new List<string> { "swipes with", "tears with", "mauls with" } },
        { WeaponType.Fangs, new List<string> { "bites with", "snaps with", "sinks" } },
        { WeaponType.Knife, new List<string> { "slashes with", "jabs with", "slices with" } },
        { WeaponType.Club, new List<string> { "swings", "brings down", "thumps with" } }
    };

    // Updated main method to handle DamageResult
    public static string DescribeAttack(Actor attacker, Actor target, DamageResult? damageResult, bool isHit, bool isDodged, bool isBlocked)
    {
        var sb = new System.Text.StringBuilder();

        // 1. Attack Initiation
        string targetPart = damageResult?.HitPartName ?? "body";
        sb.Append(DescribeAttackAttempt(attacker, target, targetPart));

        // 2. Attack Resolution
        if (isDodged)
            sb.Append(DescribeDodge(attacker, target));
        else if (isBlocked)
            sb.Append(DescribeBlock(attacker, target));
        else if (!isHit)
            sb.Append(DescribeMiss(attacker, target));
        else if (damageResult != null)
            sb.Append(DescribeHit(attacker, target, damageResult));

        return sb.ToString();
    }

    // Legacy method for backward compatibility
    public static string DescribeAttack(Actor attacker, Actor target, double damage, string targetPart, bool isHit, bool isDodged, bool isBlocked)
    {
        var sb = new System.Text.StringBuilder();

        // 1. Attack Initiation
        sb.Append(DescribeAttackAttempt(attacker, target, targetPart));

        // 2. Attack Resolution
        if (isDodged)
            sb.Append(DescribeDodge(attacker, target));
        else if (isBlocked)
            sb.Append(DescribeBlock(attacker, target));
        else if (!isHit)
            sb.Append(DescribeMiss(attacker, target));
        else
            sb.Append(DescribeHitLegacy(attacker, target, damage, targetPart));

        return sb.ToString();
    }

    private static string DescribeAttackAttempt(Actor attacker, Actor target, string targetPart)
    {
        WeaponType weaponType = attacker.ActiveWeapon.Type;
        string weaponName = attacker.ActiveWeapon.Name;

        if (attacker is Player)
        {
            // Get special description based on weapon type if available
            if (SpecialAttackDescriptions.TryGetValue(weaponType, out var specialDescs))
            {
                string desc = specialDescs[Utils.RandInt(0, specialDescs.Count - 1)];
                return $"You {desc} your {weaponName}, at {target.Name}'s {targetPart}. ";
            }
            else
            {
                return $"You attack with your {weaponName}, aiming at {target.Name}'s {targetPart}. ";
            }
        }
        else
        {
            // Enemy attacking player
            if (SpecialAttackDescriptions.TryGetValue(weaponType, out var specialDescs))
            {
                string desc = specialDescs[Utils.RandInt(0, specialDescs.Count - 1)];
                return $"The {attacker.Name} {desc} its {weaponName} at your {targetPart}. ";
            }
            else
            {
                return $"The {attacker.Name} attacks with its {weaponName}, lunging at your {targetPart}. ";
            }
        }
    }

    private static string DescribeDodge(Actor attacker, Actor target)
    {
        if (target is Player)
            return $"You quickly sidestep the {attacker.Name}'s attack!";
        else
            return $"The {target.Name} nimbly evades your strike!";
    }

    private static string DescribeBlock(Actor attacker, Actor target)
    {
        if (target is Player)
            return $"You raise your {target.ActiveWeapon.Name} and deflect the attack!";
        else
            return $"The {target.Name} blocks your blow with its {target.ActiveWeapon.Name}!";
    }

    private static string DescribeMiss(Actor attacker, Actor target)
    {
        if (attacker is Player)
            return "Your attack misses, throwing you slightly off balance!";
        else
            return $"The {attacker.Name}'s attack whistles past you, missing entirely!";
    }

    // New method using DamageResult
    private static string DescribeHit(Actor attacker, Actor target, DamageResult damageResult)
    {
        WeaponClass weaponClass = attacker.ActiveWeapon.Class;
        
        // Get appropriate attack verb
        string attackVerb = GetAttackVerb(weaponClass);
        
        // Describe damage severity
        string damageDesc = GetDamageSeverity(damageResult.TotalDamageDealt);
        
        var sb = new System.Text.StringBuilder();
        
        // Basic hit description
        if (attacker is Player)
        {
            sb.Append($"Your attack {attackVerb} the {target.Name}'s {damageResult.HitPartName}, dealing {damageDesc} damage! ");
        }
        else
        {
            sb.Append($"The {attacker.Name}'s attack {attackVerb} your {damageResult.HitPartName}, dealing {damageDesc} damage! ");
        }
        
        // Add penetration details for significant damage
        if (damageResult.WasPenetrating && damageResult.TotalDamageDealt > 5)
        {
            if (damageResult.OrganHit)
            {
                sb.Append($"The attack penetrates deep, striking the {damageResult.OrganHitName}! ");
            }
            else if (damageResult.TissuesDamaged.Any(t => t.TissueName == "Muscle"))
            {
                sb.Append("The attack tears through muscle tissue! ");
            }
        }
        
        // Add part status if significantly damaged
        if (damageResult.HitPartHealthAfter < 0.9)
        {
            string statusDesc = DescribeTargetStatus(damageResult.HitPartName, damageResult.HitPartHealthAfter);
            if (!string.IsNullOrEmpty(statusDesc))
            {
                sb.Append(statusDesc);
            }
        }
        
        // Add damage number for debugging
        sb.Append($"({Math.Round(damageResult.TotalDamageDealt, 1)})");
        
        return sb.ToString();
    }

    // Legacy method for backward compatibility
    private static string DescribeHitLegacy(Actor attacker, Actor target, double damage, string targetPart)
    {
        WeaponClass weaponClass = attacker.ActiveWeapon.Class;

        // Get appropriate attack verb based on weapon class
        string attackVerb = GetAttackVerb(weaponClass);

        // Describe damage severity
        string damageDesc = GetDamageSeverity(damage);

        // Describe hit
        if (attacker is Player)
        {
            return $"Your attack {attackVerb} the {target.Name}'s {targetPart}, dealing {damageDesc} damage! ({Math.Round(damage, 1)})";
        }
        else
        {
            return $"The {attacker.Name}'s attack {attackVerb} your {targetPart}, dealing {damageDesc} damage! ({Math.Round(damage, 1)})";
        }
    }

    private static string GetAttackVerb(WeaponClass weaponClass)
    {
        if (AttackVerbs.TryGetValue(weaponClass, out var verbs))
            return verbs[Utils.RandInt(0, verbs.Count - 1)];
        return "strikes";
    }

    private static string GetDamageSeverity(double damage)
    {
        return damage switch
        {
            <= 2 => "minimal",
            <= 5 => "light",
            <= 10 => "moderate",
            <= 15 => "severe",
            <= 25 => "critical",
            _ => "devastating"
        };
    }

    public static string DescribeTargetStatus(string partName, double healthPercent)
    {
        return healthPercent switch
        {
            <= 0 => $"The {partName} is completely destroyed!",
            < 0.15 => $"The {partName} is maimed and barely functioning!",
            < 0.35 => $"The {partName} is gravely injured!",
            < 0.6 => $"The {partName} is wounded.",
            < 0.9 => $"The {partName} is lightly injured.",
            _ => ""
        };
    }

    public static string DescribeCombatStart(Actor player, Actor enemy)
    {
        List<string> possibleStarts = new()
        {
            $"A {enemy.Name} emerges, its {enemy.ActiveWeapon.Name} at the ready!",
            $"A {enemy.Name} appears and prepares to attack!",
            $"You find yourself face to face with a {enemy.Name}!",
            $"A hostile {enemy.Name} blocks your path!",
            $"A {enemy.Name} lunges towards you suddenly!"
        };

        // Add special descriptions for certain enemy types
        if (enemy.Name.Contains("Wolf"))
            possibleStarts.Add("You hear growling as a wolf steps out from the shadows, fangs bared!");
        else if (enemy.Name.Contains("Bear"))
            possibleStarts.Add("A massive bear rears up on its hind legs, letting out a terrifying roar!");
        else if (enemy.Name.Contains("Snake"))
            possibleStarts.Add("A venomous snake rises up, hood flared, ready to strike!");

        return possibleStarts[Utils.RandInt(0, possibleStarts.Count - 1)];
    }
}================================================================================

File: ./Utils/WeightedTable.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival;

public class GenericWeightedTable<T> where T : class
{
    protected Dictionary<Func<T>, double> weightedFactories = [];

    public GenericWeightedTable() { }
    public void AddFactory(Func<T> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual T GenerateRandom()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)();
    }
}

public class LootTable : GenericWeightedTable<Item>
{
    public void AddItem(Func<Item> itemFactory, double weight = 1)
    {
        AddFactory(itemFactory, weight);
    }

    public Item GenerateRandomItem()
    {
        return base.GenerateRandom();
    }
}

public class LocationTable
{
    protected Dictionary<Func<Zone, Location>, double> weightedFactories = [];

    public void AddFactory(Func<Zone, Location> factory, double weight = 1.0)
    {
        if (weight <= 0f)
            throw new ArgumentException("Weight must be greater than zero", nameof(weight));

        weightedFactories[factory] = weight;
    }

    public bool IsEmpty()
    {
        return weightedFactories.Count == 0;
    }

    public virtual Location GenerateRandom(Zone parent)
    {
        if (IsEmpty())
            throw new InvalidOperationException("Cannot generate from an empty loot table");

        return Utils.GetRandomWeighted(weightedFactories)(parent);
    }
}


public class NpcTable : GenericWeightedTable<Npc>
{
    public void AddActor(Func<Npc> actorFactory, double weight = 1)
    {
        AddFactory(actorFactory, weight);
    }
}================================================================================

File: ./Utils/Utils.cs
--------------------------------------------------------------------------------
﻿namespace text_survival
{
    public static class Utils
    {
        private static readonly Random random = new Random(DateTime.Now.Millisecond);

        static Utils()
        {
            random = new Random(DateTime.Now.Millisecond);
        }

        public static int Roll(int sides)
        {
            return random.Next(1, sides + 1);
        }

        public static bool DetermineSuccess(double chance)
        {
            return (random.NextDouble() < chance);
        }

        public static int RandInt(int low, int high)
        {
            return random.Next(low, high + 1);
        }

        public static float RandFloat(float low, float high)
        {
            return (float)random.NextDouble() * (high - low) + low;
        }

        public static double RandDouble(double low, double high)
        {
            return random.NextDouble() * (high - low) + low;
        }

        public static bool FlipCoin()
        {
            return random.Next(2) == 0;
        }

        public static T? GetRandomEnum<T>() where T : Enum
        {
            Array values = Enum.GetValues(typeof(T));
            return (T?)values.GetValue(Roll(values.Length) - 1);
        }

        public static T GetRandomFromList<T>(List<T> list)
        {
            if (list.Count == 0)
            {
                throw new Exception("List is empty.");
            }
            return list[Roll(list.Count) - 1];
        }
        
    public static T GetRandomWeighted<T>(IDictionary<T, double> choices)
    {
        if (choices == null || choices.Count == 0)
            throw new ArgumentException("Cannot select from an empty collection", nameof(choices));
            
        double totalWeight = choices.Sum(pair => pair.Value);
        if (totalWeight <= 0)
            throw new ArgumentException("Total weight must be positive", nameof(choices));
            
        double roll = random.NextDouble() * totalWeight;
        
        double cumulativeWeight = 0;
        foreach (var pair in choices)
        {
            cumulativeWeight += pair.Value;
            if (roll <= cumulativeWeight)
                return pair.Key;
        }
        
        // This should never happen if weights are positive
        return choices.Keys.Last();
    }
    }
}
================================================================================

File: ./Config.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival
{
    public static class Config
    {
        public enum IOType
        {
            Console,
            Web
        }
        public static IOType io = IOType.Console;

        public static double NOTIFY_EXISTING_STATUS_CHANCE = .05;
    }
}
================================================================================

File: ./Actors/ICombatant.cs
--------------------------------------------------------------------------------
﻿
// using text_survival.Items;
// using text_survival.Level;

// namespace text_survival.Actors
// {
//     public interface ICombatant
//     {
//         bool IsAlive { get; }
//         bool IsEngaged { get; set; }
//         Weapon ActiveWeapon { get; }
//         Attributes Attributes { get; }
//         SkillRegistry _skillRegistry {get;}
//         double ConditionPercent { get; }
//         void Attack(ICombatant target);
//         // double DetermineDamage();
//         // double DetermineHitChance(ICombatant defender);
//         // double DetermineDodgeChance(ICombatant attacker);
//         // double DetermineBlockChance(ICombatant attacker);

//     }
// }
================================================================================

File: ./Actors/Animal.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;

namespace text_survival.Actors
{
    public class Animal : Npc
    {
        public override Weapon ActiveWeapon { get; protected set; }

        public Animal(string name, Weapon weapon, BodyCreationInfo bodyStats) : base(name, weapon, bodyStats)
        {
            Name = name;
            ActiveWeapon = weapon;
        }


        public override string ToString() => Name;
    }
}================================================================================

File: ./Actors/NPC.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Items;
using text_survival.Bodies;

namespace text_survival.Actors
{
    public class Npc : Actor
    {
        #region Properties

        // Basic properties
        public string Description { get; set; }
        public bool IsFound { get; set; }
        public bool IsHostile { get; private set; }
        public override Weapon ActiveWeapon { get; protected set; }

        // IPhysicalEntity implementation
        public double Health => Body.Health;
        public double MaxHealth => Body.MaxHealth;
        public bool IsDestroyed => Body.IsDestroyed;

        // Internal components

        public Container Loot { get; }

        #endregion

        #region Constructor

        public Npc(string name, Weapon weapon, BodyCreationInfo stats) : base(name, stats)
        {
            Description = "";
            IsHostile = true;
            ActiveWeapon = weapon;
            Loot = new Container(name, 10);
        }

        #endregion

        #region Inventory and Loot Methods

        public void AddLoot(Item item) => Loot.Add(item);

        #endregion

        public override string ToString() => Name;
    }
}================================================================================

File: ./Actors/NPCFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Items;

namespace text_survival.Actors
{
    public static class NpcFactory
    {
        public static Animal MakeRat()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Quadruped,
                overallWeight = 2, // large rat
                fatPercent = 0.15,   // 15% fat
                musclePercent = 0.40 // 40% muscle
            };

            // Create a natural weapon for the rat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "teeth", 100)
            {
                Damage = 2,
                Accuracy = 1.2
            };

            Animal rat = new("Rat", weapon, bodyStats)
            {
                Description = "A rat with fleas."
            };
            rat.AddLoot(ItemFactory.MakeSmallMeat());
            return rat;
        }

        public static Animal MakeWolf()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Quadruped,
                overallWeight = 40,   // 40 kg - average wolf
                fatPercent = 0.20,    // 20% fat
                musclePercent = 0.60  // 60% muscle - wolves are muscular
            };

            // Create a natural weapon for the wolf
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.1
            };

            Animal wolf = new("Wolf", weapon, bodyStats)
            {
                Description = "A wolf."
            };
            wolf.AddLoot(ItemFactory.MakeLargeMeat());
            return wolf;
        }

        public static Animal MakeBear()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Quadruped,
                overallWeight = 250,  // 250 kg - large bear
                fatPercent = 0.30,    // 30% fat - bears have more fat reserves
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "claws", 100)
            {
                Damage = 20,
                Accuracy = 0.9
            };

            Animal bear = new("Bear", weapon, bodyStats)
            {
                Description = "A bear."
            };
            bear.AddLoot(ItemFactory.MakeLargeMeat());
            return bear;
        }

        public static Animal MakeSnake()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Serpentine,
                overallWeight = 5,    // 5 kg - medium sized snake
                fatPercent = 0.10,    // 10% fat
                musclePercent = 0.80  // 80% muscle - snakes are almost all muscle
            };

            // Create a natural weapon for the snake
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Fangs", 100)
            {
                Damage = 10,
                Accuracy = 1.0
            };

            Animal snake = new("Snake", weapon, bodyStats)
            {
                Description = "A venomous snake."
            };

            LootTable loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSmallMeat, 2);
            loot.AddItem(ItemFactory.MakeVenomSac);
            snake.AddLoot(loot.GenerateRandomItem());

            // TODO: Apply venom effect
            // snake.ApplyEffect(new PoisonEffect("venom", "natural", 0.8, 2, 180));

            return snake;
        }

        public static Animal MakeBat()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Flying,
                overallWeight = 0.2,   // 200g - small bat
                fatPercent = 0.20,     // 20% fat 
                musclePercent = 0.65   // 65% muscle - flying requires strong muscles
            };

            // Create a natural weapon for the bat
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Tiny Teeth", 100)
            {
                Damage = 2,
                Accuracy = 0.9
            };

            Animal bat = new("Bat", weapon, bodyStats)
            {
                Description = "A small bat with leathery wings."
            };

            return bat;
        }

        public static Animal MakeSpider()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Arachnid,
                overallWeight = 0.1,   // 100g - large spider
                fatPercent = 0.05,     // 5% fat
                musclePercent = 0.45   // 45% muscle
            };

            // Create a natural weapon for the spider
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Venomous Mandibles", 100)
            {
                Damage = 5,
                Accuracy = 1.2
            };

            Animal spider = new("Spider", weapon, bodyStats)
            {
                Description = "A venomous spider with long hairy legs."
            };

            // TODO: Apply venom effect
            // spider.ApplyEffect(new PoisonEffect("venom", "natural", 0.6, 1, 120));

            var loot = new LootTable();
            loot.AddItem(ItemFactory.MakeSpiderSilk);
            loot.AddItem(ItemFactory.MakeVenomSac);
            spider.AddLoot(loot.GenerateRandomItem());

            return spider;
        }

        public static Animal MakeCaveBear()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Quadruped,
                overallWeight = 350,  // 350 kg - larger than a regular bear
                fatPercent = 0.35,    // 35% fat - more for cave survival
                musclePercent = 0.55  // 55% muscle
            };

            // Create a natural weapon for the cave bear - stronger than regular bear
            var weapon = new Weapon(WeaponType.Claws, WeaponMaterial.Organic, "Massive Claws", 100)
            {
                Damage = 25,
                Accuracy = 0.85
            };

            Animal caveBear = new("Cave Bear", weapon, bodyStats)
            {
                Description = "An enormous cave bear with massive claws. It's adapted to cave dwelling and hunting in darkness."
            };

            // Add more meat due to larger size
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());
            caveBear.AddLoot(ItemFactory.MakeLargeMeat());

            return caveBear;
        }

        public static Animal MakeWoollyMammoth()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Quadruped,
                overallWeight = 6000,  // 6 tons - enormous
                fatPercent = 0.35,     // 35% fat for cold protection
                musclePercent = 0.50   // 50% muscle
            };

            // Create a natural weapon for the mammoth
            var weapon = new Weapon(WeaponType.Horns, WeaponMaterial.Organic, "Tusks", 100)
            {
                Damage = 35,
                Accuracy = 0.7
            };

            Animal mammoth = new("Woolly Mammoth", weapon, bodyStats)
            {
                Description = "A massive woolly mammoth with long curved tusks and a thick fur coat."
            };

            // Add large amount of meat and other rare resources
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());
            mammoth.AddLoot(ItemFactory.MakeLargeMeat());

            return mammoth;
        }

        public static Animal MakeSaberToothTiger()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Quadruped,
                overallWeight = 300,   // 300 kg - large cat
                fatPercent = 0.10,
                musclePercent = 0.70   // 70% muscle - extremely powerful
            };

            // Create a natural weapon for the saber-tooth
            var weapon = new Weapon(WeaponType.Fangs, WeaponMaterial.Organic, "Massive Fangs", 100)
            {
                Damage = 30,
                Accuracy = 1.0
            };

            Animal saberTooth = new("Saber-Tooth Tiger", weapon, bodyStats)
            {
                Description = "A fearsome predator with long saber-like canine teeth."
            };

            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());
            saberTooth.AddLoot(ItemFactory.MakeLargeMeat());

            return saberTooth;
        }

        // Human NPCs with various weapons
        public static Npc MakeTribalHunter()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Human,
                overallWeight = 65,
                fatPercent = 0.15,
                musclePercent = 0.60
            };

            // Create a hunting spear
            var weapon = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Wooden Spear", 75)
            {
                Damage = 8,
                Accuracy = 1.2
            };

            // Create hunter with spear
            Npc hunter = new("Tribal Hunter", weapon, bodyStats)
            {
                Description = "A lean, muscular hunter from a nearby tribe."
            };

            // Add some basic equipment to loot
            hunter.AddLoot(ItemFactory.MakeSmallMeat());

            return hunter;
        }

        public static Npc MakeTribalWarrior()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Human,
                overallWeight = 70,
                fatPercent = 0.15,
                musclePercent = 0.65
            };

            // Create a war club
            var weapon = new Weapon(WeaponType.Club, WeaponMaterial.Stone, "War-Club", 80)
            {
                Damage = 12,
                Accuracy = 0.9
            };

            // Create warrior with club
            Npc warrior = new("Tribal Warrior", weapon, bodyStats)
            {
                Description = "A fierce warrior with ritual paint markings."
            };

            // Add some loot
            warrior.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Knapped-Flint Scraper", 60));

            return warrior;
        }

        public static Npc MakeTribalShaman()
        {
            var bodyStats = new BodyCreationInfo
            {
                type = BodyTypes.Human,
                overallWeight = 60,
                fatPercent = 0.20,
                musclePercent = 0.45
            };

            // Create a ritual staff
            var weapon = new Weapon(WeaponType.Knife, WeaponMaterial.Bone, "Shamanic Bone-Knife", 90)
            {
                Damage = 6,
                Accuracy = 1.1
            };

            // Create shaman with staff
            Npc shaman = new("Tribal Shaman", weapon, bodyStats)
            {
                Description = "An elderly shaman adorned with animal bones and feathers."
            };

            // Add some rare loot
            shaman.AddLoot(new Weapon(WeaponType.Knife, WeaponMaterial.Obsidian, "Night-Glass Ritual Knife", 95));

            return shaman;
        }
    }
}================================================================================

File: ./Actors/IBuffable.cs
--------------------------------------------------------------------------------
﻿// using text_survival.Magic;

// namespace text_survival.Actors
// {
//     public interface IBuffable //: IActor
//     {
//         public List<Buff> Buffs { get; }

//         public void AddBuff(Buff buff)
//         {
//             if (buff.Target == null)
//                 buff.ApplyTo(this);
//             Buffs.Add(buff);
//         }
//         public void RemoveBuff(Buff buff)
//         {
//             if (buff.Target == this)
//                 buff.Remove();
//             Buffs.Remove(buff);
//         }

//     }
// }
================================================================================

File: ./Actors/Actor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.Items;
using text_survival.PlayerComponents;

namespace text_survival.Actors;

public abstract class Actor
{
    public string Name;
    public virtual Location? CurrentLocation { get; set; }
    public virtual void Attack(Actor target, string? bodyPart = null) => combatManager.Attack(target, bodyPart);

    public bool IsEngaged { get; set; }
    public bool IsAlive => !Body.IsDestroyed;
    public abstract Weapon ActiveWeapon { get; protected set; }

    public virtual void Update()
    {
        EffectRegistry.Update();
        var context = new SurvivalContext
        {
            ActivityLevel = 2,
            LocationTemperature = CurrentLocation.GetTemperature(),
        };
        Body.Update(TimeSpan.FromMinutes(1), context);
    }
    public Body Body { get; init; }
    public EffectRegistry EffectRegistry { get; init; }
    protected CombatManager combatManager { get; init; }

    public override string ToString() => Name;

    protected Actor(string name, BodyCreationInfo stats)
    {
        Name = name;
        EffectRegistry = new EffectRegistry(this);
        this.combatManager = new CombatManager(this);
        Body = new Body(Name, stats, EffectRegistry);
    }
}


================================================================================

File: ./Actions/Action.cs
--------------------------------------------------------------------------------
using text_survival.IO;
namespace text_survival.Actions;

public interface IGameAction
{
    public string Name { get; set; }
    public void Execute(GameContext ctx);
    public bool IsAvailable(GameContext ctx);
}

public abstract class GameActionBase(string name) : IGameAction
{
    public virtual string Name { get; set; } = name;
    public virtual bool IsAvailable(GameContext ctx) => true;
    public void Execute(GameContext ctx)
    {
        OnExecute(ctx);
        World.Update(1);
        SelectNextAction(ctx);
    }

    protected abstract void OnExecute(GameContext ctx);
    protected abstract List<IGameAction> GetNextActions(GameContext ctx);

    private void SelectNextAction(GameContext ctx)
    {
        if (ctx.NextActionOverride != null)
        {
            ctx.NextActionOverride.Execute(ctx);
            ctx.NextActionOverride = null;
            return;
        }

        var actions = GetNextActions(ctx).Where(a => a.IsAvailable(ctx)).ToList();
        if (actions.Count == 0)
        {
            return; // back to main game loop   
        }
        else if (actions.Count == 1)
        {
            actions[0].Execute(ctx);
            return;
        }
        Output.WriteLine("\n" + userPrompt);
        IGameAction action = Input.GetSelectionFromList(actions)!;
        action.Execute(ctx);
    }
    protected virtual string userPrompt => "";
    public override string ToString() => Name;
}

================================================================================

File: ./Actions/ActionFactory.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Crafting;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Magic;

namespace text_survival.Actions;

public static class ActionFactory
{
    private static ActionBuilder CreateAction(string name) => ActionBuilderExtensions.CreateAction(name);
    public static class Common
    {
        public static IGameAction Return(string name = "Back")
        {
            return CreateAction(name).ThenReturn().Build();
        }
        public static IGameAction BackTo(string description, Func<IGameAction> actionFactory)
        {

            return CreateAction($"Back to {description}")
                    .ThenShow(ctx => [actionFactory()])
                    .Build();
        }

        public static IGameAction MainMenu()
        {
            return CreateAction("Main Menu")
                   .Do(ctx => BodyDescriber.Describe(ctx.player.Body))
                   .ThenShow(ctx => [
                        Describe.LookAround(ctx.currentLocation),
                        Survival.Forage(),
                        Inventory.OpenInventory(),
                        Crafting.OpenCraftingMenu(),
                        Describe.CheckStats(),
                        Survival.Sleep(),
                        Movement.Move(),
                   ])
                   .Build();
        }
    }

    public static class Survival
    {
        public static IGameAction Forage(string name = "Forage")
        {
            return CreateAction("Forage")
                .When(ctx => ctx.currentLocation.GetFeature<ForageFeature>() != null)
                .ShowMessage("You forage for 1 hour")
                .Do(ctx =>
                {
                    var forageFeature = ctx.currentLocation.GetFeature<ForageFeature>()!;
                    forageFeature.Forage(1);
                })
                .AndGainExperience("Foraging")
                .ThenShow(_ => [Forage("Keep foraging"), Common.Return("Finish foraging")])
                .Build();
        }

        public static IGameAction Sleep()
        {
            return CreateAction("Sleep")
            .When(ctx => ctx.player.Body.IsTired)
            .Do(ctx =>
            {
                Output.WriteLine("How many hours would you like to sleep?");
                ctx.player.Sleep(Input.ReadInt() * 60);
            })
            .ThenReturn()
            .Build();
        }
    }

    public static class Movement
    {
        public static IGameAction GoToLocation(Location location)
        {
            return CreateAction($"Go to {location.Name}{(location.Visited ? " (Visited)" : "")}")
            .When(_ => location.IsFound)
            .Do(ctx => location.Interact(ctx.player))
            .ThenReturn()
            .Build();
        }

        public static IGameAction Travel()
        {
            return CreateAction("Travel to a different area")
            .When(ctx => ctx.currentLocation.GetFeature<ShelterFeature>() == null) // when not inside a shelter
            .Do(ctx => ctx.player.Travel()) // todo move out of player class
            .ThenReturn()
            .Build();
        }

        public static IGameAction Move()
        {
            return CreateAction("Go somewhere else")
            .When(ctx => AbilityCalculator.CalculateVitality(ctx.player.Body) > .2)
            .Do(ctx => // just determine what text to display
            {
                var locations = ctx.currentLocation.GetNearbyLocations().Where(l => l.IsFound).ToList();
                bool inside = ctx.player.CurrentLocation.GetFeature<ShelterFeature>() != null;
                if (inside)
                {
                    Output.WriteLine($"You can leave the shelter and go outside.");
                }
                if (locations.Count == 0)
                {
                    Output.WriteLine("You don't see anywhere noteworthy nearby; you can stay here or travel to a new area.");
                    return;
                }
                else if (locations.Count == 1)
                {
                    Output.WriteLine($"You can go to the {locations[0].Name} or pack up and leave the region.");
                }
                else
                {
                    Output.WriteLine("You see several places that you can go to from here, or you can pack up and leave the region.");
                }
            })
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>();
                foreach (var location in ctx.currentLocation.GetNearbyLocations())
                {
                    options.Add(GoToLocation(location));
                }
                options.Add(Travel());
                options.Add(Common.Return("Stay Here..."));
                return options;
            })
            .Build();
        }
    }

    public static class Inventory
    {
        public static IGameAction DescribeItem(Item item)
        {
            return CreateAction($"Inspect {item}")
            .Do(_ => item.Describe())
            .ThenShow(_ => [OpenInventory()])
            .Build();
        }

        public static IGameAction DropItem(Item item)
        {
            return CreateAction($"Inspect {item}")
            .ShowMessage($"You drop the {item}")
            .Do(ctx => ctx.player.DropItem(item))
            .ThenShow(_ => [OpenInventory()])
            .Build();
        }

        public static IGameAction UseItem(Item item)
        {
            return CreateAction($"Use {item}")
            .Do(ctx => ctx.player.UseItem(item))
            .ThenShow(_ => [OpenInventory()])
            .Build();
        }

        public static IGameAction OpenInventory()
        {
            return CreateAction($"Open inventory")
            .OnlyIfHasItems()
            .Do(ctx => ctx.player.inventoryManager.Describe())
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>();
                foreach (ItemStack stack in ctx.player.inventoryManager.Items)
                {
                    options.Add(DecideInventoryAction(stack));
                }
                options.Add(Common.Return("Close Inventory"));
                return options;
            })
            .WithPrompt("Select an item:")
            .Build();
        }

        public static IGameAction OpenContainer(Container container)
        {
            return CreateAction($"Look in {container}{(container.IsEmpty ? " (Empty)" : "")}")
            .When(ctx => container.IsFound && !container.IsEmpty)
            .OnlyIfCanBypassHostiles()
            .ShowMessage($"You open the {container}")
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>();
                var itemStacks = ItemStack.CreateStacksFromItems(container.Items);
                foreach (var stack in itemStacks)
                {
                    options.Add(TakeStackFromContainer(container, stack));
                }
                options.Add(TakeAllFromContainer(container));
                options.Add(Common.Return($"Close {container.Name}"));
                return options;
            })
            .WithPrompt("Select an item:")
            .Build();
        }

        public static IGameAction TryToReachContainer(Container container)
        {
            return CreateAction($"Try to reach {container.Name}")
                 .When(ctx => container.IsFound &&
                            !container.IsEmpty)
                 .OnlyIfBlockedByHostiles()
                 .Do(ctx => Output.WriteLine("You couldn't get past the ", CombatUtils.GetFastestHostileNpc(ctx.currentLocation)!, "!"))
                 .ThenShow(ctx => [Combat.StartCombat(CombatUtils.GetFastestHostileNpc(ctx.currentLocation)!)])
                 .Build();
        }

        public static IGameAction DecideInventoryAction(ItemStack stack)
        {
            Item item = stack.Peek();
            return CreateAction(stack.DisplayName)
            .ThenShow(_ => [UseItem(item),
                            DescribeItem(item),
                            DropItem(item),
                            Common.BackTo("inventory", OpenInventory)]
                            )
            .WithPrompt($"What would you like to do with the {item.Name}")
            .Build();
        }

        public static IGameAction TakeAllFromContainer(Container container)
        {
            return CreateAction("Take all")
            .When(_ => container.Count() > 1)
            .Do(ctx =>
            {
                while (!container.IsEmpty)
                {
                    var item = container.Items.First();
                    container.Remove(item);
                    ctx.player.TakeItem(item);
                }
            })
            .ThenReturn()
            .Build();
        }


        public static IGameAction TakeStackFromContainer(Container container, ItemStack stack)
        {
            return CreateAction($"Take {stack.DisplayName}")
            .Do(ctx =>
            {
                while (stack.Count > 0)
                {
                    var item = stack.Pop();
                    container.Remove(item);
                    ctx.player.TakeItem(item);
                }
            })
            .ThenShow(_ => [OpenContainer(container)]) // will be auto selected until the container is empty then it will auto return
            .Build();
        }

        public static IGameAction PickUpItem(Item item)
        {
            return CreateAction($"Pick up {item.Name}")
            .When(_ => item.IsFound)
            .OnlyIfCanBypassHostiles()
            .ShowMessage($"You take the {item}")
            .Do(ctx => ctx.player.TakeItem(item))
            .ThenLookAround()
            .Build();
        }

        public static IGameAction LootNpc(Npc npc)
        {
            return CreateAction($"Loot {npc.Name}")
            .When(_ => npc.IsFound)
            .When(_ => !npc.IsAlive)
            .When(_ => !npc.Loot.IsEmpty)
            .OnlyIfCanBypassHostiles()
            .ThenShow(_ => [OpenContainer(npc.Loot)])
            .Build();
        }

    }

    public static class Combat
    {
        public static IGameAction StartCombat(Npc enemy)
        {
            return CreateAction($"Fight {enemy.Name}")
            .When(ctx => enemy.IsAlive && enemy.IsFound)
            .Do(ctx =>
            {
                Output.WriteLine("!");
                Thread.Sleep(500);
                Output.WriteLine(CombatNarrator.DescribeCombatStart(ctx.player, enemy));

                ctx.player.IsEngaged = true;
                enemy.IsEngaged = true;
                ctx.EngagedEnemy = enemy;

                // First strike determination
                bool enemyFirstStrike = AbilityCalculator.CalculateSpeed(enemy.Body) > AbilityCalculator.CalculateSpeed(ctx.player.Body);

                if (enemyFirstStrike)
                {
                    Output.WriteLine($"The {enemy.Name} moves with surprising speed!");
                    Thread.Sleep(500);
                    ctx.NextActionOverride = EnemyCombatTurn(enemy);
                    return;
                }
                else
                {
                    Output.WriteLine("You're quick to react, giving you the initiative!");
                    Thread.Sleep(500);
                }
            })
            .ThenShow(_ => [PlayerCombatTurn(enemy)])
            .Build();
        }

        public static IGameAction AttackEnemy(Npc enemy)
        {
            return CreateAction($"Attack {enemy.Name}")
            .Do(ctx => ctx.player.Attack(enemy))
            .ThenShow(ctx => [EnemyCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }


        public static IGameAction TargetedAttackEnemy(Npc enemy)
        {
            return CreateAction($"Targeted Attack {enemy.Name}")
            .When(ctx => ctx.player.Skills.Fighting.Level > 1)
            .Do(ctx =>
            {
                int fightingSkill = ctx.player.Skills.Fighting.Level;
                var targetPart = SelectTargetPart(enemy, fightingSkill);
                if (targetPart != null)
                {
                    ctx.player.Attack(enemy, targetPart.Name);
                }
                else
                {
                    ctx.NextActionOverride = PlayerCombatTurn(enemy);
                }
            })
            .ThenShow(ctx => [EnemyCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }
        private static BodyRegion? SelectTargetPart(Actor enemy, int depth)
        {
            if (depth <= 0)
            {
                Output.WriteWarning("You don't have enough skill to target an attack");
                return null;
            }
            Output.WriteLine($"Where do you want to target your attack on the {enemy.Name}?");

            List<BodyRegion> allParts = [];

            foreach (var part in enemy.Body.Parts)
            {
                if (depth > 0)
                    allParts.Add(part);
                // if (depth > 1)
                //     allParts.Add(part.Skin);
                // if (depth > 2)
                //     allParts.Add(part.Muscle);
                // if (depth > 3)
                //     allParts.Add(part.Bone);
                // if (depth > 4)
                //     allParts.AddRange(part.Organs);
            }

            var choice = Input.GetSelectionFromList(allParts, true);
            if (choice == null)
                return null;

            // todo return part itself
            return choice;
        }

        public static IGameAction EndCombat(Npc enemy)
        {
            return CreateAction("End Combat")
            .When(ctx => !enemy.IsEngaged || !ctx.player.IsEngaged || !ctx.player.IsAlive || !enemy.IsAlive)
            .Do(ctx =>
            {
                ctx.player.IsEngaged = false;
                enemy.IsEngaged = false;

                // Combat end
                if (!ctx.player.IsAlive)
                {
                    Output.WriteDanger("Your vision fades to black as you collapse... You have died!");
                    Environment.Exit(0);
                }
                else if (!enemy.IsAlive)
                {
                    string[] victoryMessages = [
                    $"The {enemy.Name} collapses, defeated!",
                    $"You stand victorious over the fallen {enemy.Name}!",
                    $"With a final blow, you bring down the {enemy.Name}!"
                ];
                    Output.WriteLine(victoryMessages[Utils.RandInt(0, victoryMessages.Length - 1)]);

                    // Calculate experience based on enemy difficulty
                    int xpGain = CalculateExperienceGain(enemy);
                    Output.WriteLine($"You've gained {xpGain} fighting experience!");
                    ctx.player.Skills.Fighting.GainExperience(xpGain);
                }
            })
            .ThenReturn()
            .Build();
        }
        private static int CalculateExperienceGain(Npc enemy)
        {
            int baseXP = 5;

            // Adjust based on enemy weight/size
            double sizeMultiplier = Math.Clamp(enemy.Body.Weight / 50, 0.5, 3.0);

            // Adjust based on enemy weapon damage
            double weaponMultiplier = Math.Clamp(enemy.ActiveWeapon.Damage / 8, 0.5, 2.0);

            return (int)(baseXP * sizeMultiplier * weaponMultiplier);
        }

        public static IGameAction Flee(Npc enemy)
        {
            return CreateAction("Flee")
            .When(ctx => AbilityCalculator.CalculateSpeed(ctx.player.Body) > .25)
            .Do(ctx =>
            {
                if (CombatUtils.SpeedCheck(ctx.player, enemy))
                {
                    Output.WriteLine("You got away!");
                    enemy.IsEngaged = false;
                    ctx.player.IsEngaged = false;
                    ctx.player.Skills.Reflexes.GainExperience(2);
                }
                else
                {
                    Output.WriteLine("You weren't fast enough to get away from ", enemy, "!");
                    ctx.player.Skills.Reflexes.GainExperience(1);
                }
            })
            .ThenShow(_ => [EnemyCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }
        public static IGameAction EnemyCombatTurn(Npc enemy)
        {
            return CreateAction("Enemy Turn")
            .When(ctx => ctx.player.IsAlive && enemy.IsAlive && enemy.IsEngaged)
            .Do(ctx =>
            {
                Thread.Sleep(500); // Pause before enemy attack
                enemy.Attack(ctx.player);
            })
            .ThenShow(ctx => [PlayerCombatTurn(enemy), EndCombat(enemy)])
            .Build();
        }

        public static IGameAction PlayerCombatTurn(Npc enemy)
        {
            return CreateAction("Player Turn")
            .When(ctx => ctx.player.IsAlive && enemy.IsAlive && ctx.player.IsEngaged)
            .Do(ctx =>
            {
                Output.WriteLine("─────────────────────────────────────");
                DisplayCombatStatus(ctx.player, enemy);
            })
            .ThenShow(ctx => [AttackEnemy(enemy), TargetedAttackEnemy(enemy), Magic.SelectSpell(enemy), Flee(enemy)])
            .Build();
        }

        private static void DisplayCombatStatus(Player player, Actor enemy)
        {
            ConsoleColor oldColor = Console.ForegroundColor;
            // Player status
            Console.ForegroundColor = GetHealthColor(player.Body.Health / player.Body.MaxHealth);
            Output.WriteLine($"You: {Math.Round(player.Body.Health, 0)}/{Math.Round(player.Body.MaxHealth, 0)} HP");
            // Enemy status
            Console.ForegroundColor = GetHealthColor(enemy.Body.Health / enemy.Body.MaxHealth);
            Output.WriteLine($"{enemy.Name}: {Math.Round(enemy.Body.Health, 0)}/{Math.Round(enemy.Body.MaxHealth, 0)} HP");
            Console.ForegroundColor = oldColor;
        }

        private static ConsoleColor GetHealthColor(double healthPercentage)
        {
            if (healthPercentage < 0.2) return ConsoleColor.Red;
            if (healthPercentage < 0.5) return ConsoleColor.Yellow;
            return ConsoleColor.Green;
        }
    }


    public static class Magic
    {
        public static IGameAction SelectSpell(Npc enemy)
        {
            return CreateAction("Cast Spell")
            .When(ctx => ctx.player._spells.Count > 0)
            .ThenShow(ctx =>
            {
                List<IGameAction> options = [];
                foreach (Spell spell in ctx.player._spells)
                {
                    options.Add(SelectSpellTarget(spell, enemy));
                }
                var back = Combat.PlayerCombatTurn(enemy);
                back.Name = "Choose a different action.";
                options.Add(back);
                return options;
            })
            .WithPrompt("Which spell would you like to cast?")
            .Build();
        }

        public static IGameAction SelectSpellTarget(Spell spell, Npc enemy)
        {
            return CreateAction($"Cast {spell}")
            .ThenShow(ctx =>
            {
                var options = new List<IGameAction>
                {
                CastSpellAtTarget(spell, enemy, ctx.player),
                CastSpellAtTarget(spell, enemy, enemy)
                };

                if (ctx.player.Skills.Magic?.Level > 1)
                {
                    options.Add(TargetedCastSpellAtTarget(spell, enemy, ctx.player));
                    options.Add(TargetedCastSpellAtTarget(spell, enemy, enemy));
                }

                return options;
            })
            .WithPrompt($"Which target would you like to cast {spell} on?")
            .Build();
        }

        public static IGameAction CastSpellAtTarget(Spell spell, Npc enemy, Actor target)
        {
            return CreateAction($"Cast {spell} on {target}")
            .Do(ctx => spell.Cast(target))
            .ThenShow(ctx => [Combat.EnemyCombatTurn(enemy), Combat.EndCombat(enemy)])
            .Build();
        }

        public static IGameAction TargetedCastSpellAtTarget(Spell spell, Npc enemy, Actor target)
        {
            return CreateAction($"Targeted Cast {spell} on {target}")
            .When(ctx => ctx.player.Skills.Magic.Level > 1)
            .Do(ctx =>
            {
                int magicSkill = ctx.player.Skills.Magic.Level;
                BodyRegion? targetPart = SelectSpellTargetPart(target, magicSkill);
                if (targetPart != null)
                {
                    spell.Cast(target, targetPart);
                }
                else
                {
                    ctx.NextActionOverride = Combat.PlayerCombatTurn(enemy);
                }
            })
            .ThenShow(ctx => [Combat.EnemyCombatTurn(enemy), Combat.EndCombat(enemy)])
            .Build();
        }

        private static BodyRegion? SelectSpellTargetPart(Actor target, int depth)
        {
            if (depth <= 0)
            {
                Output.WriteWarning("You don't have enough magical skill to target a specific body part");
                return null;
            }

            Output.WriteLine($"Select a part to target on the {target.Name}:");
            var parts = target.Body.Parts;
            return Input.GetSelectionFromList(parts, true);
        }
    }

    public static class Crafting
    {
        public static IGameAction OpenCraftingMenu()
        {
            return CreateAction("Craft Items")
                .ThenShow(ctx =>
                {
                    var actions = new List<IGameAction>();
                    var availableRecipes = ctx.CraftingManager.GetAvailableRecipes();

                    if (availableRecipes.Count == 0)
                    {
                        Output.WriteLine("You don't know how to craft anything here, or you lack the required materials.");
                        return [ShowAllRecipes(), Common.Return("Go back")];
                    }

                    Output.WriteLine("What would you like to craft?");

                    // Group recipes by type
                    var itemRecipes = availableRecipes.Where(r => r.ResultType == CraftingResultType.Item).ToList();
                    var featureRecipes = availableRecipes.Where(r => r.ResultType == CraftingResultType.LocationFeature).ToList();
                    var shelterRecipes = availableRecipes.Where(r => r.ResultType == CraftingResultType.Shelter).ToList();

                    if (itemRecipes.Count != 0)
                    {
                        Output.WriteLine("\n--- Items ---");
                        foreach (var recipe in itemRecipes)
                            actions.Add(CraftItem(recipe));
                    }

                    if (featureRecipes.Count != 0)
                    {
                        Output.WriteLine("\n--- Build Features ---");
                        foreach (var recipe in featureRecipes)
                            actions.Add(CraftItem(recipe));
                    }

                    if (shelterRecipes.Count != 0)
                    {
                        Output.WriteLine("\n--- Build Shelters ---");
                        foreach (var recipe in shelterRecipes)
                            actions.Add(CraftItem(recipe));
                    }

                    actions.Add(ShowAllRecipes());
                    actions.Add(ShowAvailableProperties());
                    actions.Add(Common.Return("Stop crafting"));

                    return actions;
                })
                .Build();
        }

        public static IGameAction CraftItem(CraftingRecipe recipe)
        {
            return CreateAction($"Craft {recipe.Name}")
                .Do(ctx =>
                {
                    // Show recipe details
                    Output.WriteLine($"\nCrafting: {recipe.Name}");
                    Output.WriteLine($"Description: {recipe.Description}");
                    Output.WriteLine($"Time required: {recipe.CraftingTimeMinutes} minutes");
                    Output.WriteLine($"Required skill: {recipe.RequiredSkill} (Level {recipe.RequiredSkillLevel})");
                    Output.WriteLine($"Result type: {recipe.ResultType}");

                    if (recipe.RequiresFire)
                        Output.WriteLine("Requires: Active fire");

                    Output.WriteLine("\nMaterial properties needed:");
                    foreach (var req in recipe.RequiredProperties)
                    {
                        string consumed = req.IsConsumed ? "(consumed)" : "(used)";
                        Output.WriteLine($"- {req.PropertyName}: {req.MinQuantity:F1}+ at {req.MinQuality:F1}+ quality {consumed}");
                    }

                    // Show what player has
                    Output.WriteLine("\nYour available materials:");
                    ShowPlayerProperties(ctx.player, recipe.RequiredProperties);

                    Output.WriteLine("\nDo you want to attempt this craft?");

                    if (Input.ReadYesNo())
                    {
                        ctx.CraftingManager.Craft(recipe);
                    }
                })
                .ThenShow(ctx => [OpenCraftingMenu()])
                .Build();
        }

        public static IGameAction ShowAllRecipes()
        {
            return CreateAction("View All Known Recipes")
                .Do(ctx =>
                {
                    Output.WriteLine("\n=== [ Known Recipes ] ===");

                    var craftingManager = new CraftingSystem(ctx.player);
                    var allRecipes = craftingManager.Recipes.Values
                        .GroupBy(r => r.ResultType)
                        .ToList();

                    foreach (var group in allRecipes)
                    {
                        Output.WriteLine($"\n--- [ {group.Key} Recipes ] ---");
                        foreach (var recipe in group)
                        {
                            PrintRecipeTable(recipe, ctx.player);
                            Output.WriteLine();
                        }
                    }

                })
                .WaitForUserInputToContinue()
                .ThenShow(ctx => [OpenCraftingMenu()])
                .Build();
        }

        private static void PrintRecipeTable(CraftingRecipe recipe, Player player)
        {
            bool canCraft = recipe.CanCraft(player);
            string status = canCraft ? "[✓]" : "[✗]";

            // Header with recipe name
            string header = $">>> {recipe.Name.ToUpper()} {status} <<<";
            int tableWidth = 64;

            Output.WriteLine($"┌{new string('─', tableWidth)}┐");
            Output.WriteLine($"│{header.PadLeft((tableWidth + header.Length) / 2).PadRight(tableWidth)}│");
            Output.WriteLine($"├{new string('─', tableWidth)}┤");

            // Info row
            string fireReq = recipe.RequiresFire ? " • Fire Required" : "";
            string infoRow = $"{recipe.CraftingTimeMinutes} min • {recipe.RequiredSkill} level {recipe.RequiredSkillLevel}{fireReq}";
            Output.WriteLine($"│ {infoRow.PadRight(tableWidth - 2)} │");

            // Description row
            string description = recipe.Description;
            if (description.Length > tableWidth - 2)
            {
                description = string.Concat(description.AsSpan(0, tableWidth - 5), "...");
            }
            Output.WriteLine($"│ {description.PadRight(tableWidth - 2)} │");

            // Materials table header
            Output.WriteLine($"├───────────────────────────────────┬────────┬─────────┬─────────┤");
            Output.WriteLine($"│ Material                          │ Qty    │ Quality │ Consumed│");
            Output.WriteLine($"├───────────────────────────────────┼────────┼─────────┼─────────┤");

            // Materials rows
            foreach (var req in recipe.RequiredProperties)
            {
                string material = req.PropertyName.Length > 31
                    ? req.PropertyName[..28] + "..."
                    : req.PropertyName;

                string quantity = $"{req.MinQuantity:F1}x";
                string quality = $"{req.MinQuality:F1}+";
                string consumed = req.IsConsumed ? "✓" : "✗";

                Output.WriteLine($"│ {material,-33} │ {quantity,6} │ {quality,7} │ {consumed,7} │");
            }

            Output.WriteLine($"└───────────────────────────────────┴────────┴─────────┴─────────┘");
        }

        public static IGameAction ShowAvailableProperties()
        {
            return CreateAction("Show My Materials")
                .Do(ctx =>
                {
                    Output.WriteLine("\n=== Your Material Properties ===");

                    var propertyTotals = new Dictionary<string, (double amount, double avgQuality, int items)>();

                    foreach (var stack in ctx.player.inventoryManager.Items)
                    {
                        var item = stack.FirstItem;
                        foreach (var property in item.CraftingProperties)
                        {
                            if (!propertyTotals.ContainsKey(property.Name))
                            {
                                propertyTotals[property.Name] = (0, 0, 0);
                            }

                            var current = propertyTotals[property.Name];
                            propertyTotals[property.Name] = (
                                current.amount + (property.Quantity * stack.Count),
                                current.avgQuality + (property.Quality * stack.Count),
                                current.items + stack.Count
                            );
                        }
                    }

                    foreach (var kvp in propertyTotals.OrderBy(x => x.Key))
                    {
                        var (amount, qualitySum, items) = kvp.Value;
                        double avgQuality = items > 0 ? qualitySum / items : 0;
                        Output.WriteLine($"{kvp.Key}: {amount:F1} total (avg quality: {avgQuality:F2})");
                    }

                    if (!propertyTotals.Any())
                    {
                        Output.WriteLine("You don't have any materials with useful properties.");
                    }
                })
                .WaitForUserInputToContinue()
                .ThenShow(ctx => [OpenCraftingMenu()])
                .Build();
        }

        private static void ShowPlayerProperties(Player player, List<PropertyRequirement> requirements)
        {
            foreach (var req in requirements)
            {
                double totalAmount = 0;
                double totalQuality = 0;
                int itemCount = 0;

                foreach (var stack in player.inventoryManager.Items)
                {
                    var property = stack.FirstItem.GetProperty(req.PropertyName);
                    if (property != null)
                    {
                        totalAmount += property.Quantity * stack.Count;
                        totalQuality += property.Quality * stack.Count;
                        itemCount += stack.Count;
                    }
                }

                double avgQuality = itemCount > 0 ? totalQuality / itemCount : 0;
                bool sufficient = totalAmount >= req.MinQuantity && avgQuality >= req.MinQuality;
                string status = sufficient ? "✓" : "✗";

                Output.WriteLine($"  {status} {req.PropertyName}: {totalAmount:F1}/{req.MinQuantity:F1} (Q: {avgQuality:F2}/{req.MinQuality:F1})");
            }
        }
    }
    public class Describe
    {
        public static IGameAction LookAround(Location location)
        {
            return CreateAction($"Look around {location.Name}")
            .Do(ctx =>
            {
                // Header with location info
                Output.WriteSuccess($"\t>>> {location.Name.ToUpper()} <<<");
                Output.WriteLine("(", location.Parent, " • ", World.GetTimeOfDay(), " • ", location.GetTemperature(), "°F)");
                Output.WriteLine("\nYou see:");

                // Items and objects found here
                bool hasItems = false;

                foreach (var item in location.Items)
                {
                    Output.WriteLine("\t", item);
                    item.IsFound = true;
                    hasItems = true;
                }

                foreach (var container in location.Containers)
                {
                    Output.WriteLine("\t", container, " [container]");
                    container.IsFound = true;
                    hasItems = true;
                }

                foreach (var npc in location.Npcs)
                {
                    Output.WriteLine("\t", npc, " [creature]");
                    npc.IsFound = true;
                    hasItems = true;
                }

                if (!hasItems)
                {
                    Output.WriteLine("Nothing...");
                }

                // Add spacing before exits if there were items
                var nearbyLocations = location.GetNearbyLocations();
                if (hasItems && nearbyLocations.Count > 0)
                {
                    Output.WriteLine();
                }

                // Exits
                if (nearbyLocations.Count > 0)
                {
                    Output.WriteLine("Nearby Places:");
                }
                foreach (var nearbyLocation in nearbyLocations)
                {
                    Output.WriteLine("\t→ ", nearbyLocation);
                    nearbyLocation.IsFound = true;
                }
                Output.WriteLine();
            })
            .ThenShow(ctx =>
            {
                var actions = new List<IGameAction>();
                foreach (Npc npc in location.Npcs)
                {
                    actions.Add(Combat.StartCombat(npc));
                    actions.Add(Inventory.LootNpc(npc));
                }
                foreach (Item item in location.Items)
                {
                    actions.Add(Inventory.PickUpItem(item));
                }
                foreach (var container in location.Containers)
                {
                    actions.Add(Inventory.OpenContainer(container));
                    actions.Add(Inventory.TryToReachContainer(container));
                }
                actions.Add(Common.Return());
                return actions;
            })
            .WaitForUserInputToContinue()
            .Build();
        }

        public static IGameAction CheckStats()
        {
            return CreateAction("Check Stats")
            .Do(ctx =>
            {
                BodyDescriber.Describe(ctx.player.Body);
                ctx.player.Skills.Describe();
            })
            .WaitForUserInputToContinue()
            .Build();
        }
    }


}================================================================================

File: ./Actions/ActionBuilder.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Actions;

public class ActionBuilder
{
    private string _name = "";
    private readonly List<Func<GameContext, bool>> _isAvailableRequirements = [];
    private readonly List<Action<GameContext>> _onExecuteActions = [];
    private Func<GameContext, List<IGameAction>>? _getNextActions;
    private string? _userPrompt;

    public ActionBuilder Named(string name)
    {
        _name = name;
        return this;
    }

    public ActionBuilder When(Func<GameContext, bool> condition)
    {
        _isAvailableRequirements.Add(condition);
        return this;
    }

    public ActionBuilder Do(Action<GameContext> action)
    {
        _onExecuteActions.Add(action);
        return this;
    }

    public ActionBuilder ThenShow(Func<GameContext, List<IGameAction>> nextActions)
    {
        _getNextActions = nextActions;
        return this;
    }

    public ActionBuilder ThenReturn()
    {
        _getNextActions = _ => [];
        return this;
    }

    public ActionBuilder WithPrompt(string prompt)
    {
        _userPrompt = prompt;
        return this;
    }

    public IGameAction Build()
    {
        if (string.IsNullOrWhiteSpace(_name))
        {
            throw new InvalidOperationException("Action name is required");
        }

        Action<GameContext>? combinedAction = null;
        if (_onExecuteActions.Count > 0)
        {
            combinedAction = ctx => _onExecuteActions.ForEach(x => x(ctx));
        }

        // combines all conditional requirements with AND. i.e returns true iff all are true
        Func<GameContext, bool>? combinedRequirements = null;
        if (_isAvailableRequirements.Count > 0)
        {
            combinedRequirements = ctx => _isAvailableRequirements.All(x => x(ctx));
        }

        return new DynamicAction(
            name: _name,
            isAvailable: combinedRequirements,
            onExecute: combinedAction,
            getNextActions: _getNextActions,
            userPrompt: _userPrompt
        );
    }
}

public static class ActionBuilderExtensions
{
    public static ActionBuilder CreateAction(string name) => new ActionBuilder().Named(name);

    public static ActionBuilder OnlyIfHasItems(this ActionBuilder b)
    {
        return b.When(ctx => ctx.player.inventoryManager.Items.Count > 0);
    }

    public static ActionBuilder ShowMessage(this ActionBuilder b, string message)
    {
        return b.Do(_ => Output.WriteLine(message));
    }

    public static ActionBuilder ThenOpenInventory(this ActionBuilder b)
    {
        return b.ThenShow(ctx => [ActionFactory.Inventory.OpenInventory()]);
    }

    public static ActionBuilder ThenLookAround(this ActionBuilder b)
    {
        return b.ThenShow(ctx => [ActionFactory.Describe.LookAround(ctx.currentLocation)]);
    }

    public static ActionBuilder AndGainExperience(this ActionBuilder b, string skillName, int xp = 1)
    {
        return b.Do(ctx => ctx.player.Skills.GetSkill(skillName).GainExperience(xp));
    }

    public static ActionBuilder TakesMinutes(this ActionBuilder b, int minutes)
    {
        return b.Do(ctx => World.Update(minutes));
    }

    public static ActionBuilder OnlyIfCanBypassHostiles(this ActionBuilder b)
    {
        return b.When(ctx =>
        {
            Npc? npc = CombatUtils.GetFastestHostileNpc(ctx.currentLocation);
            return npc == null || CombatUtils.SpeedCheck(ctx.player, npc);
        });
    }
    public static ActionBuilder OnlyIfBlockedByHostiles(this ActionBuilder b)
    {
        return b.When(ctx =>
        {
            Npc? npc = CombatUtils.GetFastestHostileNpc(ctx.currentLocation);
            return npc != null && !CombatUtils.SpeedCheck(ctx.player, npc);
        });
    }

    public static ActionBuilder WaitForUserInputToContinue(this ActionBuilder b)
    {
        return b.Do(_ =>
        {
            Output.WriteLine("Press any key to continue...");
            Console.ReadKey(true);
        });
    }
}================================================================================

File: ./Actions/GameContext.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Crafting;
using text_survival.Environments;

namespace text_survival.Actions;

public class GameContext(Player player)
{
    public Player player = player;
    public Location currentLocation => player.CurrentLocation;
    public IGameAction? NextActionOverride { get; set; }
    public Npc? EngagedEnemy;
    public CraftingSystem? CraftingManager { get; set; }
}
================================================================================

File: ./Actions/DynamicAction.cs
--------------------------------------------------------------------------------
namespace text_survival.Actions;

public class DynamicAction(
    string name,
    Func<GameContext, bool>? isAvailable,
    Action<GameContext>? onExecute,
    Func<GameContext, List<IGameAction>>? getNextActions,
    string? userPrompt
) : GameActionBase(name)
{
    private readonly Func<GameContext, bool>? _isAvailable = isAvailable;
    private readonly Action<GameContext>? _onExecute = onExecute;
    private readonly Func<GameContext, List<IGameAction>>? _getNextActions = getNextActions;
    private readonly string? _userPrompt = userPrompt;

    public override bool IsAvailable(GameContext ctx)
    {
        return _isAvailable?.Invoke(ctx) ?? true;
    }

    protected override void OnExecute(GameContext ctx)
    {
        _onExecute?.Invoke(ctx);
    }

    protected override List<IGameAction> GetNextActions(GameContext ctx)
    {
        return _getNextActions?.Invoke(ctx) ?? [];
    }
    protected override string userPrompt => _userPrompt ?? base.userPrompt;
}================================================================================

File: ./Level/Skill.cs
--------------------------------------------------------------------------------
﻿

using text_survival.IO;

namespace text_survival.Level
{
    public class Skill
    {
        public int Xp;
        public int Level { get; private set; }
        public string Name { get; set; }
        public int LevelUpThreshold => (Level) * 10;

        public Skill(string name)
        {
            Name = name;
            Xp = 0;
            Level = 0;
        }
        public void GainExperience(int xp)
        {
            Xp += xp;

            if (Xp < LevelUpThreshold) return;
            // else level up
            Xp -= LevelUpThreshold;
            LevelUp();
        }

        public void LevelUp()
        {
            Level++;
            Output.WriteLine("You leveled up ", this, " to level ", Level, "!");
        }

        public override string ToString() => Name;

        public void Describe()
        {
            Output.Write(this, ": ", Level, " (", Xp, "/", LevelUpThreshold, ")");
        }

    }
}
================================================================================

File: ./Level/SkillRegistry.cs
--------------------------------------------------------------------------------
﻿using text_survival.IO;

namespace text_survival.Level
{
    public class SkillRegistry
    {
        public Skill Fighting { get; private set; }
        public Skill Endurance { get; private set; }
        public Skill Reflexes { get; private set; }
        public Skill Defense { get; private set; }
        public Skill Hunting { get; private set; }
        public Skill Crafting { get; private set; }
        public Skill Foraging { get; private set; }
        public Skill Firecraft { get; private set; }
        public Skill Mending { get; private set; }
        public Skill Healing { get; private set; }
        public Skill Magic { get; private set; }

        public SkillRegistry()
        {
            Fighting = new Skill("Fighting");
            Endurance = new Skill("Endurance");
            Reflexes = new Skill("Reflexes");
            Defense = new Skill("Defense");
            Hunting = new Skill("Hunting");
            Crafting = new Skill("Crafting");
            Foraging = new Skill("Foraging");
            Firecraft = new Skill("Firecraft");
            Mending = new Skill("Mending");
            Healing = new Skill("Healing");
            Magic = new Skill("Shamanism");
        }

        public void Describe()
        {
            Output.WriteLine("\nSkills:");

            var allSkills = new[] { Fighting, Endurance, Reflexes, Defense, Hunting, Crafting, Foraging, Firecraft, Mending, Healing, Magic };

            foreach (var skill in allSkills)
            {
                if (skill.Level > 0)
                {
                    Output.WriteLine($"{skill.Name}: {skill.Level} ({skill.Xp}/{skill.LevelUpThreshold})");
                }
            }
        }

        public Skill GetSkill(string skillName)
        {
            return skillName switch
            {
                "Fighting" => Fighting,
                "Endurance" => Endurance,
                "Reflexes" => Reflexes,
                "Defense" => Defense,
                "Hunting" => Hunting,
                "Crafting" => Crafting,
                "Foraging" => Foraging,
                "Firecraft" => Firecraft,
                "Mending" => Mending,
                "Healing" => Healing,
                "Magic" => Magic,
                _ => throw new ArgumentException($"Skill {skillName} does not exist.")
            };
        }
    }
}================================================================================

File: ./Crafting/ItemProperty.cs
--------------------------------------------------------------------------------
namespace text_survival.Crafting;

public class ItemCraftingProperty(string name, double quantity = 1, double quality = 1)
{
    public string Name = name;
    public double Quantity = quantity;
    public double Quality = quality;

    public override string ToString() => $"{Name}: {Quantity:F1} (Q: {Quality:F1})";
}

public class PropertyRequirement(string propertyName, double minQuantity, double minQuality = 0, bool isConsumed = true)
{
    public string PropertyName { get; set; } = propertyName;
    public double MinQuantity { get; set; } = minQuantity;
    public double MinQuality { get; set; } = minQuality;
    public bool IsConsumed { get; set; } = isConsumed;

    public override string ToString() => $"{PropertyName}: {MinQuantity:F1}+ (Q: {MinQuality:F1}+)";
}================================================================================

File: ./Crafting/CraftingSystem.cs
--------------------------------------------------------------------------------
using text_survival.IO;
using text_survival.Environments;
using text_survival.Items;

namespace text_survival.Crafting;

public class CraftingSystem
{
    private readonly Dictionary<string, CraftingRecipe> _recipes = [];
    private readonly Player _player;

    public CraftingSystem(Player player)
    {
        _player = player;
        InitializeRecipes();
    }

    public IReadOnlyDictionary<string, CraftingRecipe> Recipes => _recipes;

    public List<CraftingRecipe> GetAvailableRecipes()
    {
        return _recipes.Values.Where(recipe => recipe.CanCraft(_player)).ToList();
    }

    public void Craft(CraftingRecipe recipe)
    {
        if (!recipe.CanCraft(_player))
        {
            Output.WriteWarning("You cannot craft this item right now.");
            return;
        }

        Output.WriteLine($"You begin working on {recipe.Name}...");

        // Consume time
        World.Update(recipe.CraftingTimeMinutes);

        // Consume ingredients
        recipe.ConsumeIngredients(_player);

        // Generate results based on type
        switch (recipe.ResultType)
        {
            case CraftingResultType.Item:
                var items = recipe.GenerateItemResults(_player);
                foreach (var item in items)
                {
                    _player.TakeItem(item);
                    Output.WriteSuccess($"You successfully crafted: {item.Name}");
                }
                break;

            case CraftingResultType.LocationFeature:
                if (recipe.LocationFeatureResult != null)
                {
                    var feature = recipe.LocationFeatureResult.FeatureFactory(_player.CurrentLocation);
                    _player.CurrentLocation.Features.Add(feature);
                    Output.WriteSuccess($"You successfully built: {recipe.LocationFeatureResult.FeatureName}");
                }
                break;

            case CraftingResultType.Shelter:
                if (recipe.NewLocationResult != null)
                {
                    var newLocation = recipe.NewLocationResult.LocationFactory(_player.CurrentZone);
                    _player.CurrentZone.Locations.Add(newLocation);
                    newLocation.IsFound = true;
                    Output.WriteSuccess($"You successfully built: {recipe.NewLocationResult.LocationName}");
                    Output.WriteLine($"The {newLocation.Name} is now accessible from this area.");
                }
                break;
        }

        // Grant experience
        int xpGain = recipe.RequiredSkillLevel + 2;
        _player.Skills.GetSkill(recipe.RequiredSkill).GainExperience(xpGain);
    }

    private static void ConsumeProperty(Player player, PropertyRequirement requirement)
    {
        double remainingNeeded = requirement.MinQuantity;
        var eligibleStacks = player.inventoryManager.Items
            .Where(stack => stack.FirstItem.HasProperty(requirement.PropertyName, 0, requirement.MinQuality))
            .OrderByDescending(stack => stack.FirstItem.GetProperty(requirement.PropertyName)?.Quality)
            .ToList();

        foreach (var stack in eligibleStacks)
        {
            while (stack.Count > 0 && remainingNeeded > 0)
            {
                var item = stack.FirstItem;
                var property = item.GetProperty(requirement.PropertyName);

                if (property != null && property.Quantity <= remainingNeeded)
                {
                    // Consume entire item
                    remainingNeeded -= property.Quantity;
                    var consumedItem = stack.Pop();
                    player.inventoryManager.RemoveFromInventory(consumedItem);
                }
                else if (property != null)
                {
                    // Partially consume item (reduce its property amount)
                    property.Quantity -= remainingNeeded;
                    remainingNeeded = 0;
                }
            }

            if (remainingNeeded <= 0) break;
        }
    }


    private void InitializeRecipes()
    {
        // Basic Tools
        CreateBasicToolRecipes();

        // Location Features
        CreateLocationFeatureRecipes();

        // Shelter Construction
        CreateShelterRecipes();

        // Cooking Recipes
        CreateCookingRecipes();
    }



    private void CreateBasicToolRecipes()
    {
        var stoneKnife = new RecipeBuilder()
            .Named("Stone Knife")
            .WithDescription("A simple cutting tool made from sharp stone.")
            .RequiringCraftingTime(15)
            .WithPropertyRequirement("Stone", 1, .5)
            .WithPropertyRequirement("Wood", .5, .3)
            .WithPropertyRequirement("Binding", .2, .2)
            .ResultingInItem(ItemFactory.MakeKnife)
            .Build();
        _recipes.Add("stone_knife", stoneKnife);

        // Spear
        var spear = new RecipeBuilder()
            .Named("Wooden Spear")
            .WithDescription("A hunting spear with a sharpened point.")
            .RequiringSkill("Crafting", 1)
            .RequiringCraftingTime(20)
            .WithPropertyRequirement("Wood", 1.5, 0.6)
            .WithPropertyRequirement("Stone", 0.5, 0.7)
            .WithPropertyRequirement("Binding", 0.3, 0.4)
            .ResultingInItem(ItemFactory.MakeSpear)
            .Build();
        _recipes.Add("spear", spear);
    }

    private void CreateLocationFeatureRecipes()
    {
        // Campfire
        var campfire = new RecipeBuilder()
            .Named("Campfire")
            .WithDescription("A fire pit for warmth, light, and cooking.")
            .RequiringSkill("Firecraft")
            .RequiringCraftingTime(20)
            .WithPropertyRequirement("Flammable", 3, 0.4)
            .WithPropertyRequirement("Stone", 2, 0.2) // For fire ring
            .WithPropertyRequirement("Firestarter", .2, .5)
            .ResultingInLocationFeature(new LocationFeatureResult("Campfire", location =>
            {
                var fireFeature = new HeatSourceFeature(location, 20.0);
                fireFeature.AddFuel(.8);
                return fireFeature;
            }))
            .Build();
        _recipes.Add("campfire", campfire);
    }

    private void CreateShelterRecipes()
    {
        // Lean-to Shelter
        var leanTo = new RecipeBuilder()
            .Named("Lean-to Shelter")
            .WithDescription("A simple shelter that provides basic protection.")
            .RequiringSkill("Crafting", 1) //todo: add building skill?
            .RequiringCraftingTime(120)
            .WithPropertyRequirement("Wood", 6, 0.4)
            .WithPropertyRequirement("Binding", 1, 0.3)
            .WithPropertyRequirement("Insulation", 2, 0.2, false) // Leaves, furs, etc.
            .ResultingInStructure("Lean-to Shelter", CreateLeanToShelter)
            .Build();
        _recipes.Add("lean_to", leanTo);

        // Advanced Shelter
        var cabin = new RecipeBuilder()
            .Named("Log Cabin")
            .WithDescription("A sturdy shelter providing excellent protection.")
            .RequiringSkill("Crafting", 3)
            .RequiringCraftingTime(480) // 8 hours
            .WithPropertyRequirement("Wood", 20, 0.7)
            .WithPropertyRequirement("Stone", 5, 0.5) // For foundation
            .WithPropertyRequirement("Binding", 3, 0.5)
            .WithPropertyRequirement("Insulation", 8, 0.4)
            .ResultingInStructure("Log Cabin", CreateLogCabin)
            .Build();
        _recipes.Add("log_cabin", cabin);
    }

    private void CreateCookingRecipes()
    {
        // Cooked Meat
        var cookedMeat = new RecipeBuilder()
            .Named("Cooked Meat")
            .WithDescription("Meat cooked over fire for better nutrition.")
            .RequiringSkill("Firecraft")
            .RequiringCraftingTime(15)
            .RequiringFire(true)
            .WithPropertyRequirement("RawMeat", 1, 0.2)
            .ResultingInItem(() => new FoodItem("Cooked Meat", 800, 0, 1.0)
            {
                CraftingProperties = { new ItemCraftingProperty("CookedMeat", 1.2, 0.9) } // Cooking improves nutrition
            })
            .Build();
        _recipes.Add("cooked_meat", cookedMeat);
    }

    private static Location CreateLeanToShelter(Zone parent)
    {
        var shelter = new Location("Lean-to Shelter", parent);
        shelter.Features.Add(new ShelterFeature(shelter, 0.3, 0.6, 0.4)); // Moderate protection
        shelter.Features.Add(new EnvironmentFeature(shelter, 5.0, 0.6, 0.4)); // 5°F warmer
        return shelter;
    }

    private static Location CreateLogCabin(Zone parent)
    {
        var cabin = new Location("Log Cabin", parent);
        cabin.Features.Add(new ShelterFeature(cabin, 0.7, 0.9, 0.8)); // Excellent protection
        cabin.Features.Add(new EnvironmentFeature(cabin, 15.0, 0.9, 0.8)); // 15°F warmer
        return cabin;
    }
}
================================================================================

File: ./Crafting/CraftingRecipe.cs
--------------------------------------------------------------------------------

using text_survival.Environments;
using text_survival.Items;

namespace text_survival.Crafting;

public enum CraftingResultType
{
    Item,
    LocationFeature,
    Shelter
}


public class CraftingRecipe(string name, string description = "")
{
    public string Name { get; set; } = name;
    public string Description { get; set; } = description;
    public List<PropertyRequirement> RequiredProperties { get; set; } = [];
    public CraftingResultType ResultType { get; set; } = CraftingResultType.Item;
    public List<ItemResult> ResultItems { get; set; } = [];
    public LocationFeatureResult? LocationFeatureResult { get; set; }
    public NewLocationResult? NewLocationResult { get; set; }
    public int RequiredSkillLevel { get; set; } = 0;
    public string RequiredSkill { get; set; } = "Crafting";
    public int CraftingTimeMinutes { get; set; } = 10;
    public bool RequiresFire { get; set; } = false;

    public bool CanCraft(Player player)
    {
        // Check skill requirement
        var skill = player.Skills.GetSkill(RequiredSkill);
        if (skill.Level < RequiredSkillLevel)
            return false;

        // Check if player has required properties
        if (!HasRequiredProperties(player))
            return false;

        // Check location requirements
        if (RequiresFire && !HasFire(player.CurrentLocation))
            return false;

        // Check specific result type requirements
        if (ResultType == CraftingResultType.Shelter && NewLocationResult != null)
        {
            // Can't build shelter inside another shelter
            if (player.CurrentLocation.GetFeature<ShelterFeature>() != null)
                return false;
        }

        return true;
    }

    private bool HasRequiredProperties(Player player)
    {
        foreach (var requirement in RequiredProperties)
        {
            if (!HasSufficientProperty(player, requirement))
                return false;
        }
        return true;
    }

    private static bool HasSufficientProperty(Player player, PropertyRequirement requirement)
    {
        double totalAmount = 0;
        double averageQuality = 0;
        int itemCount = 0;

        foreach (var stack in player.inventoryManager.Items)
        {
            var item = stack.FirstItem;
            var property = item.GetProperty(requirement.PropertyName);

            if (property != null && property.Quality >= requirement.MinQuality)
            {
                totalAmount += property.Quantity * stack.Count;
                averageQuality += property.Quality * stack.Count;
                itemCount += stack.Count;
            }
        }

        if (itemCount > 0)
            averageQuality /= itemCount;

        return totalAmount >= requirement.MinQuantity && averageQuality >= requirement.MinQuality;
    }

    private static bool HasFire(Location location)
    {
        return location.GetFeature<HeatSourceFeature>()?.IsActive == true;
    }

    public void ConsumeIngredients(Player player)
    {
        foreach (var requirement in RequiredProperties.Where(r => r.IsConsumed))
        {
            ConsumeProperty(player, requirement);
        }
    }

    private static void ConsumeProperty(Player player, PropertyRequirement requirement)
    {
        double remainingNeeded = requirement.MinQuantity;
        var eligibleStacks = player.inventoryManager.Items
            .Where(stack => stack.FirstItem.HasProperty(requirement.PropertyName, 0, requirement.MinQuality))
            .OrderByDescending(stack => stack.FirstItem.GetProperty(requirement.PropertyName)?.Quality)
            .ToList();

        foreach (var stack in eligibleStacks)
        {
            while (stack.Count > 0 && remainingNeeded > 0)
            {
                var item = stack.FirstItem;
                var property = item.GetProperty(requirement.PropertyName);

                if (property != null && property.Quantity <= remainingNeeded)
                {
                    // Consume entire item
                    remainingNeeded -= property.Quantity;
                    var consumedItem = stack.Pop();
                    player.inventoryManager.RemoveFromInventory(consumedItem);
                }
                else if (property != null)
                {
                    // Partially consume item (reduce its property amount)
                    property.Quantity -= remainingNeeded;
                    remainingNeeded = 0;
                }
            }

            if (remainingNeeded <= 0) break;
        }
    }

    public List<Item> GenerateItemResults(Player player)
    {
        if (ResultType != CraftingResultType.Item)
            return [];

        var results = new List<Item>();
        var skill = player.Skills.GetSkill(RequiredSkill);

        foreach (var result in ResultItems)
        {
            for (int i = 0; i < result.Quantity; i++)
            {
                var item = result.ItemFactory();

                // Apply quality bonus based on skill and input quality
                ApplyQualityBonus(item, skill.Level, GetInputQuality());

                results.Add(item);
            }
        }

        return results;
    }

    private double GetInputQuality()
    {
        // Calculate average quality of consumed materials
        // This could be enhanced to be more sophisticated
        return 1; // Placeholder
    }

    private void ApplyQualityBonus(Item item, int skillLevel, double inputQuality)
    {
        double skillBonus = skillLevel * 0.02; // 2% per skill level
        double qualityMultiplier = 1 + skillBonus + (inputQuality * 0.1);

        foreach (var property in item.CraftingProperties)
        {
            property.Quality = Math.Min(1.0, property.Quality * qualityMultiplier);
        }

        // Apply to legacy quality system too
        if (item is Weapon weapon)
        {
            weapon.Quality = Math.Min(100, weapon.Quality * qualityMultiplier);
        }
        else if (item is Armor armor)
        {
            armor.Quality = Math.Min(100, armor.Quality * qualityMultiplier);
        }
    }
}


public class ItemResult
{
    public Func<Item> ItemFactory { get; set; }
    public int Quantity { get; set; }

    public ItemResult(Func<Item> factory, int quantity = 1)
    {
        ItemFactory = factory;
        Quantity = quantity;
    }
}

public class LocationFeatureResult
{
    public Func<Location, LocationFeature> FeatureFactory { get; set; }
    public string FeatureName { get; set; }

    public LocationFeatureResult(string featureName, Func<Location, LocationFeature> factory)
    {
        FeatureName = featureName;
        FeatureFactory = factory;
    }
}

public class NewLocationResult
{
    public Func<Zone, Location> LocationFactory { get; set; }
    public string LocationName { get; set; }

    public NewLocationResult(string locationName, Func<Zone, Location> factory)
    {
        LocationName = locationName;
        LocationFactory = factory;
    }
}================================================================================

File: ./Crafting/RecipeBuilder.cs
--------------------------------------------------------------------------------
using text_survival.Environments;
using text_survival.Items;

namespace text_survival.Crafting;

public class RecipeBuilder
{
    private string _name = "";
    private string _description = "";
    private List<PropertyRequirement> _requiredProperties = [];
    private CraftingResultType _resultType = CraftingResultType.Item;
    private List<ItemResult> _resultItems = [];
    private LocationFeatureResult? _locationFeatureResult;
    private NewLocationResult? _newLocationResult;
    private int _requiredSkillLevel = 0;
    private string _requiredSkill = "Crafting";
    private int _craftingTimeMinutes = 10;
    private bool _requiresFire = false;

    public RecipeBuilder Named(string name)
    {
        _name = name;
        return this;
    }

    public RecipeBuilder WithDescription(string description)
    {
        _description = description;
        return this;
    }

    public RecipeBuilder WithPropertyRequirement(PropertyRequirement requirement)
    {
        _requiredProperties.Add(requirement);
        return this;
    }
    public RecipeBuilder WithPropertyRequirement(string propertyName, double minQuantity = 1, double minQuality = 1, bool isConsumed=true)
    {
        _requiredProperties.Add(new PropertyRequirement(propertyName, minQuantity, minQuality, isConsumed));
        return this;
    }

    public RecipeBuilder ResultingInItem(ItemResult itemResult)
    {
        _resultItems.Add(itemResult);
        _resultType = CraftingResultType.Item;
        return this;
    }

    public RecipeBuilder ResultingInItem(Func<Item> itemFactory)
    {
        _resultItems.Add(new ItemResult(itemFactory));
        _resultType = CraftingResultType.Item;
        return this;
    }

    public RecipeBuilder ResultingInLocationFeature(LocationFeatureResult locationResult)
    {
        _locationFeatureResult = locationResult;
        _resultType = CraftingResultType.LocationFeature;
        return this;
    }

    public RecipeBuilder ResultingInStructure(NewLocationResult newStructure)
    {
        _newLocationResult = newStructure;
        _resultType = CraftingResultType.Shelter;
        return this;
    }

    public RecipeBuilder ResultingInStructure(string structureName, Func<Zone, Location> locationFactory)
    {
        _newLocationResult = new NewLocationResult(structureName, locationFactory);
        _resultType = CraftingResultType.Shelter;
        return this;
    }

    public RecipeBuilder UtilizingSkill(string skillName = "Crafting")
    {
        _requiredSkill = skillName;
        return this;
    }
    public RecipeBuilder RequiringSkill(string skillName = "Crafting", int skillLevel = 0)
    {
        _requiredSkill = skillName;
        _requiredSkillLevel = skillLevel;
        return this;
    }

    public RecipeBuilder RequiringCraftingTime(int minutes)
    {
        _craftingTimeMinutes = minutes;
        return this;
    }

    public RecipeBuilder RequiringFire(bool requiresFire = true)
    {
        _requiresFire = requiresFire;
        return this;
    }

    public CraftingRecipe Build()
    {
        if (string.IsNullOrWhiteSpace(_name))
        {
            throw new InvalidOperationException("Name is required");
        }

        var recipe = new CraftingRecipe(_name, _description)
        {
            RequiredProperties = _requiredProperties,
            ResultType = _resultType,
            ResultItems = _resultItems,
            LocationFeatureResult = _locationFeatureResult,
            NewLocationResult = _newLocationResult,
            RequiredSkillLevel = _requiredSkillLevel,
            RequiredSkill = _requiredSkill,
            CraftingTimeMinutes = _craftingTimeMinutes,
            RequiresFire = _requiresFire
        };
        return recipe;
    }
}
================================================================================

File: ./Items/Gear.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Gear : Item, IEquippable
    {
        // private List<Buff> EquipBuffs { get; }
        // public List<Buff> GetEquipBuffs() => EquipBuffs;
        // public void AddEquipBuff(Buff buff) => EquipBuffs.Add(buff);
        // public void RemoveEquipBuff(Buff buff) => EquipBuffs.Remove(buff);
        public List<Effect> EquipEffects { get; set; }
        public double Insulation { get; set; }
        public Gear(string name, double weight = 1, int quality = 50) : base(name, weight, quality)
        {
            EquipEffects = [];
        }
    }

}

================================================================================

File: ./Items/ItemStack.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class ItemStack
{
    public string DisplayName => Items.Count == 1 ? FirstItem.Name : $"{FirstItem.Name} x{Items.Count}";
    public Item FirstItem { get; private set; }
    public Stack<Item> Items { get; private set; }
    public int Count => Items.Count;
    
    public ItemStack(Item item)
    {
        FirstItem = item;
        Items = new Stack<Item>();
        Items.Push(item);
    }
    
    public void Add(Item item)
    {
        if (item.Name != FirstItem.Name)
        {
            throw new ArgumentException($"Cannot add item '{item.Name}' to stack of '{FirstItem.Name}'");
        }
        
        Items.Push(item);
    }
    
    public Item Pop() => Items.Pop();
    public Item Peek() => Items.Peek();
    
    public override string ToString() => DisplayName;
    
    public static List<ItemStack> CreateStacksFromItems(IEnumerable<Item> items)
    {
        var stacksByName = new Dictionary<string, ItemStack>();
        
        foreach (var item in items)
        {
            if (stacksByName.TryGetValue(item.Name, out var stack))
            {
                stack.Add(item);
            }
            else
            {
                stacksByName[item.Name] = new ItemStack(item);
            }
        }
        
        return stacksByName.Values.ToList();
    }
}================================================================================

File: ./Items/ItemFactory.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Effects;


namespace text_survival.Items
{
    public class ItemFactory
    {
        public static readonly Dictionary<string, Func<Item>> ItemDefinitions = new()
        {
            { "Mushroom", MakeMushroom },
            { "Berries", MakeBerry },
            { "Roots", MakeRoots },
            { "Water", MakeWater },
            { "Stick", MakeStick },
            { "Firewood", MakeFirewood },
            { "Flint", MakeFlint },
            { "Clay", MakeClay },
            { "Stone", MakeStone },
            { "Bone", MakeBone },
            { "Spear", MakeSpear },
            { "Club", MakeClub },
            { "HandAxe", MakeHandAxe },
            { "Knife", MakeKnife },
            { "Hide Shield", MakeHideShield },
            { "Fur Armor", MakeFurArmor },
            { "Healing Herbs", MakeHealingHerbs },
            { "Bandage", MakeBandage },
            { "Torch", MakeTorch },
            { "Fish", MakeFish },
            { "Primitive Weapon", Weapon.GenerateRandomWeapon }
        };

        public static Weapon MakeFists()
        {
            return new Weapon(WeaponType.Unarmed, WeaponMaterial.Organic, "Bare Hands");
        }

        public static FoodItem MakeMushroom()
        {
            var mushroom = new FoodItem("Wild Mushroom", 25, 5)
            {
                Description = "A forest mushroom. Some varieties are nutritious, others are deadly.",
                Weight = 0.1F
            };

            double strength = Utils.RandDouble(1, 15);
            string targetOrgan = Utils.GetRandomFromList(["Stomach", "Liver", "Kidney"]);

            if (Utils.FlipCoin())
            {
                mushroom.HealthEffect = new()
                {
                    Amount = strength,
                    Type = "herbal",
                    TargetPart = targetOrgan,
                    Quality = Utils.RandDouble(0, 1.5)
                };
            }
            else
            {
                mushroom.DamageEffect = new()
                {
                    Amount = strength * .66,
                    Type = Bodies.DamageType.Poison,
                    TargetPartName = targetOrgan,
                };
            }
            return mushroom;
        }

        public static FoodItem MakeBerry()
        {
            var item = new FoodItem("Wild Berries", 120, 100);
            string color = Utils.GetRandomFromList(["red", "blue", "black", "purple"]);
            string season = Utils.GetRandomFromList(["autumn", "summer"]);
            item.Description = $"A handful of {color} {season} berries. Sweet and juicy.";
            item.Weight = 0.1F;
            return item;
        }

        public static FoodItem MakeRoots()
        {
            var item = new FoodItem("Foraged Roots", 100, 20)
            {
                Description = "Starchy roots dug from the ground. Tough but nutritious.",
                Weight = 0.3F
            };
            return item;
        }

        public static FoodItem MakeWater()
        {
            var item = new FoodItem("Fresh Water", 0, 1000)
            {
                Description = "Clear water collected from a stream. Stored in a water skin made from animal bladder.",
                Weight = 1
            };
            return item;
        }

        public static Item MakeStick()
        {
            Item stick = new Item("Sturdy Stick")
            {
                Description = "A strong branch, useful for making tools and weapons.",
                Weight = 0.5
            };
            return stick;
        }

        public static Item MakeFirewood()
        {
            var wood = new Item("Firewood")
            {
                Description = "Dry wood gathered for making fires. Essential for warmth and cooking.",
                Weight = 1.5,
                
            };
            return wood;
        }

        public static Item MakeFlint()
        {
            var flint = new Item("Knapping Flint")
            {
                Description = "Sharp-edged stone perfect for making cutting tools and starting fires.",
                Weight = 0.2
            };
            return flint;
        }

        public static Item MakeClay()
        {
            var clay = new Item("River Clay")
            {
                Description = "Malleable clay gathered from a riverbank. Could be shaped into vessels.",
                Weight = 1.0
            };
            return clay;
        }

        public static Item MakeStone()
        {
            var item = new Item("River Stone")
            {
                Description = "A smooth river stone. Useful for tools or cooking.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeBone()
        {
            var bone = new Item("Animal Bone")
            {
                Description = "A sturdy bone from a large animal. Good material for tools and weapons.",
                Weight = 0.3
            };
            return bone;
        }

        public static Weapon MakeSpear()
        {
            Weapon spear = new Weapon(WeaponType.Spear, WeaponMaterial.Wood, "Hunting Spear", 65)
            {
                Description = "A long wooden shaft with a sharpened flint point. Good for hunting and defense.",
                Weight = 1.5
            };
            return spear;
        }

        public static Weapon MakeClub()
        {
            Weapon club = new Weapon(WeaponType.Club, WeaponMaterial.Wood, "War Club", 60)
            {
                Description = "A heavy wooden club reinforced with stone. Brutal but effective.",
                Weight = 2.0
            };
            return club;
        }

        public static Weapon MakeHandAxe()
        {
            Weapon axe = new Weapon(WeaponType.HandAxe, WeaponMaterial.Stone, "Stone Hand Axe", 70)
            {
                Description = "A sharp stone blade bound to a wooden handle with animal sinew.",
                Weight = 1.8
            };
            return axe;
        }

        public static Weapon MakeKnife()
        {
            Weapon knife = new Weapon(WeaponType.Knife, WeaponMaterial.Flint, "Flint Knife", 75)
            {
                Description = "A razor-sharp flint blade with a bone handle. Essential for skinning and cutting.",
                Weight = 0.4
            };
            return knife;
        }

        public static Armor MakeHideShield()
        {
            Armor shield = new Armor("Hide Shield", .15, EquipSpots.Hands, 1)
            {
                Description = "A wooden frame covered with animal hide. Offers basic protection.",
                Weight = 2.0
            };
            return shield;
        }

        public static Armor MakeFurArmor()
        {
            Armor armor = new Armor("Fur Armor", .25, EquipSpots.Chest, 8)
            {
                Description = "A thick fur pelt worn as protection. Offers warmth and some defense against attacks.",
                Weight = 3.0
            };
            return armor;
        }

        public static FoodItem MakeLargeMeat()
        {
            var item = new FoodItem("Large Game Meat", 600, 0)
            {
                Description = "A substantial cut of meat from a large animal. Will need to be cooked.",
                Weight = 1.5
            };
            return item;
        }

        public static FoodItem MakeSmallMeat()
        {
            var item = new FoodItem("Small Game Meat", 200, 0)
            {
                Description = "A modest portion of meat from a small animal. Best cooked before eating.",
                Weight = 0.5
            };
            return item;
        }

        public static Item MakeHealingHerbs()
        {
            var herbs = new FoodItem("Healing Herbs", 10, 5)
            {
                Description = "A bundle of medicinal plants known for their healing properties.",
                Weight = 0.2,
                NumUses = 1,
                HealthEffect = new()
                {
                    Amount = 15,
                    Type = "herbal",
                    Quality = 0.7,
                }
            };
            return herbs;
        }

        public static Item MakeBandage()
        {
            var bandage = new ConsumableItem("Bark Bandage")
            {
                Description = "Strips of inner tree bark pounded soft. Can bind wounds and stop bleeding.",
                Weight = 0.1,
                Effects = [
                    EffectBuilderExtensions.CreateEffect("stop bleed").From("bandage").ClearsEffectType("bleeding").AsInstantEffect().Build()
                ]
            };
            return bandage;
        }

        public static Gear MakeTorch()
        {
            Gear torch = new Gear("Pine Torch", 0.8)
            {
                Description = "A branch wrapped with resin-soaked pine needles. Provides light and warmth.",
                Insulation = 5
            };
            return torch;
        }

        public static FoodItem MakeFish()
        {
            var item = new FoodItem("River Fish", 200, 0)
            {
                Description = "A freshly caught fish. Rich in nutrients and relatively easy to obtain near water.",
                Weight = 0.4
            };
            return item;
        }

        public static Item MakeVenomSac()
        {
            Item venom = new WeaponModifierItem("Venom Sac")
            {
                Description = "A fragile sac of venom extracted from a poisonous creature. Could coat a weapon.",
                Weight = 0.1,
                NumUses = 2,
                Damage = 2
            };
            return venom;
        }

        public static Item MakeSpiderSilk()
        {
            Item silk = new ArmorModifierItem("Spider Silk", [EquipSpots.Hands, EquipSpots.Feet, EquipSpots.Head])
            {
                Weight = 0.1,
                Description = "Fine, strong threads collected from giant spider webs. Useful for binding and insulation.",
                Warmth = 0.5
            };
            return silk;
        }

        public static Armor MakeFurHood()
        {
            Armor hood = new Armor("Fur Hood", .05, EquipSpots.Head, 3)
            {
                Description = "A hood made from animal fur. Keeps the head and ears warm in frigid weather.",
                Weight = 0.3
            };
            return hood;
        }

        public static Armor MakeLeatherTunic()
        {
            Armor tunic = new Armor("Leather Tunic", .10, EquipSpots.Chest, 4)
            {
                Description = "A simple tunic made from tanned animal hide. Basic protection from the elements.",
                Weight = 1.5
            };
            return tunic;
        }

        public static Armor MakeLeatherPants()
        {
            Armor leggings = new Armor("Leather Pants", .08, EquipSpots.Legs, 3)
            {
                Description = "Pants made from tanned animal hide. Protects the legs from brush and minor injuries.",
                Weight = 1.0
            };
            return leggings;
        }

        public static Armor MakeMoccasins()
        {
            Armor shoes = new Armor("Hide Moccasins", .03, EquipSpots.Feet, 2)
            {
                Description = "Soft footwear made from animal hide. More durable than bare feet on rough terrain.",
                Weight = 0.4
            };
            return shoes;
        }

        public static Item MakeMammothTusk()
        {
            Item tusk = new WeaponModifierItem("Mammoth Tusk")
            {
                Description = "A massive curved tusk from a woolly mammoth. Extremely valuable and rare.",
                Weight = 10.0,
                NumUses = 1,
                Damage = 5
            };
            return tusk;
        }

        public static Item MakeSaberToothFang()
        {
            Item fang = new WeaponModifierItem("Saber-Tooth Fang")
            {
                Description = "A long, curved fang from a saber-tooth tiger. Could be fashioned into a deadly weapon.",
                Weight = 0.3,
                NumUses = 1,
                Damage = 4
            };
            return fang;
        }

        public static Item MakeAntlerTine()
        {
            Item antler = new Item("Antler Tine")
            {
                Description = "A prong from a deer or elk antler. Useful for punching holes in hide or as a tool.",
                Weight = 0.2
            };
            return antler;
        }

        public static Item MakeSinew()
        {
            Item sinew = new Item("Animal Sinew")
            {
                Description = "Tough fibrous tissue from animal tendons. Essential for binding, sewing and bowstrings.",
                Weight = 0.1
            };
            return sinew;
        }

        public static Armor MakeBoneNecklace()
        {
            Armor necklace = new Armor("Bone Talisman", 0, EquipSpots.Chest, 0.5)
            {
                Description = "A primitive necklace made from small bones and stones. Said to bring good fortune.",
                Weight = 0.1
            };
            return necklace;
        }

        public static Item MakeObsidianShard()
        {
            Item obsidian = new Item("Obsidian Shard")
            {
                Description = "A piece of naturally occurring volcanic glass. Can be knapped into extremely sharp tools.",
                Weight = 0.2
            };
            return obsidian;
        }

        public static Item MakeOchrePigment()
        {
            Item ochre = new Item("Red Ochre")
            {
                Description = "Earthy clay pigment used for body decoration, cave paintings, and hide treatment.",
                Weight = 0.3
            };
            return ochre;
        }
    }
}================================================================================

File: ./Items/FoodItem.cs
--------------------------------------------------------------------------------
﻿using text_survival.Bodies;

namespace text_survival.Items
{
    public interface IEdible
    {
        int WaterContent { get; }
        int Calories { get; }
    }

    public class FoodItem : Item, IEdible
    {
        public FoodItem(string name, int calories, int waterContent = 0, double weight = .5) : base(name, weight)
        {
            Quality = 100;
            Calories = calories;
            WaterContent = waterContent;
            NumUses = 1;
        }

        public int WaterContent { get; }
        public int Calories { get; }
        public HealingInfo? HealthEffect {get; set;}
        public DamageInfo? DamageEffect {get; set;}
        public void Update()
        {
            Quality -= .1; //TODO: Add spoilage
        }
        public override string ToString() => Name;
    }
}
================================================================================

File: ./Items/Armor.cs
--------------------------------------------------------------------------------
﻿using text_survival.Effects;
using text_survival.Magic;

namespace text_survival.Items
{
    public class Armor : Gear
    {
        public EquipSpots EquipSpot { get; set; }
        public double Rating { get; set; }
        public ArmorClass Type { get; set; }

        public Armor(string name, double rating, EquipSpots equipSpot, double warmth = 0, ArmorClass type = ArmorClass.Light) : base(name)
        {
            EquipEffects = [];
            Rating = rating;
            EquipSpot = equipSpot;
            Insulation = warmth;
            Type = type;
        }


    }
}================================================================================

File: ./Items/ConsumableItem.cs
--------------------------------------------------------------------------------
using text_survival.Effects;
using text_survival.Items;

namespace text_survival.Actors;

class ConsumableItem : Item
{
    public ConsumableItem(string name, int numUses=1) : base(name)
    {
        Effects = [];
        NumUses = numUses;
    }

    public List<Effect> Effects;
}
================================================================================

File: ./Items/IEquippable.cs
--------------------------------------------------------------------------------
﻿
using text_survival.Effects;

namespace text_survival.Items
{
    public interface IEquippable
    {
        public List<Effect> EquipEffects { get; }
    }

}================================================================================

File: ./Items/ModifierItem.cs
--------------------------------------------------------------------------------
namespace text_survival.Items;

public class WeaponModifierItem : Item
{
    public double Damage { get; set; }
    public WeaponModifierItem(string name) : base(name)
    {
        Damage = 0;
    }

}

public class ArmorModifierItem : Item
{
    public List<EquipSpots> ValidArmorTypes;
    public double Warmth { get; set; }
    public double Rating { get; set; }
    public ArmorModifierItem(string name, List<EquipSpots> validArmorTypes) : base(name)
    {
        ValidArmorTypes = validArmorTypes;
        Warmth = 0;
        Rating = 0;
    }

}================================================================================

File: ./Items/ItemEnums.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum EquipSpots
    {
        Head,
        Chest,
        Legs,
        Feet,
        Hands,
        Weapon
    }

    public enum ArmorClass
    {
        Light,
        Heavy
    }







}================================================================================

File: ./Items/Item.cs
--------------------------------------------------------------------------------
﻿using text_survival.Crafting;
using text_survival.IO;

namespace text_survival.Items
{
    public class Item
    {
        public string Name { get; set; }
        public double Weight { get; set; } // in kg
        public string Description { get; set; } = "";
        public double Quality { get; set; } // percentage 0% being extremely poor quality, 100% being perfect quality
        public bool IsFound { get; set; }
        public int NumUses { get; set; }
        public List<ItemCraftingProperty> CraftingProperties = [];

        public Item(string name, double weight = 1, int quality = 50)
        {
            Name = name;
            Weight = weight;
            Quality = quality;
            NumUses = -1; // not consumable
        }

        public void Describe()
        {
            Output.Write(this, " => ", Description, " ");
            if (this is Weapon weapon)
            {
                Output.Write("Damage: ", weapon.Damage, " hp, ");
                Output.Write("Hit Chance: ", weapon.Accuracy * 100, "%, ");
                if (weapon.BlockChance != 0)
                {
                    Output.Write(", BlockChance: ", weapon.BlockChance * 100, "%, ");
                }
            }
            else if (this is Armor armor)
            {
                if (armor.Rating != 0)
                    Output.Write("Defense: ", armor.Rating * 100, "%, ");

                if (armor.Insulation != 0)
                    Output.Write("Warmth: ", armor.Insulation, "F, ");
            }

            if (Weight != 0)
            {
                Output.Write("Weight: ", Weight, "kg");
            }
            Output.WriteLine();
        }
        public override string ToString()
        {
            return Name;
        }

        public ItemCraftingProperty? GetProperty(string name)
        {
            return CraftingProperties.FirstOrDefault(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
        }

        public bool HasProperty(string name, double minAmount = 0, double minQuality = 0)
        {
            var property = GetProperty(name);
            return property != null && property.Quality >= minAmount && property.Quality >= minQuality;
        }

    }
}
================================================================================

File: ./Items/Container.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.IO;

namespace text_survival.Items
{
    public class Container(string name, float maxWeight)
    {
        private string _name = name;
        public string Name { get => IsEmpty ? _name + " (Empty)" : _name; set => _name = value; }
        public double Weight() => Items.Sum(item => item.Weight);
        public float MaxWeight { get; set; } = maxWeight;
        public List<Item> Items { get; } = [];
        public bool IsEmpty => Items.Count == 0;
        public bool IsFound { get; set; }

        public Item GetItem(int index) => Items[index];
        public Item GetItemByName(string itemName) => Items.First(i => i.Name.Equals(itemName));
   
        public override string ToString() => Name;

        public void Add(Item item)
        {
            if (item.Weight + Weight() > MaxWeight)
            {
                Output.Write("The ", this, "is full!\n");
                return;
            }
            Items.Add(item);
        }

        public void Remove(Item item) => Items.Remove(item);
        public int Count() => Items.Count;

    }
}
================================================================================

File: ./Items/Weapon.cs
--------------------------------------------------------------------------------
﻿namespace text_survival.Items
{
    public enum WeaponType
    {
        // Crafted weapons
        Spear,          // Long distance hunting/combat
        Club,           // Heavy blunt force
        HandAxe,        // Cutting tool and weapon
        Knife,          // Sharp tool made of flint or similar
        SharpStone,     // Primitive cutting tool

        // Natural weapons
        Unarmed,        // Human fists
        Claws,          // Bear, large feline
        Fangs,          // Wolf, snake
        Horns           // Mammoth tusks, deer antlers
    }

    public enum WeaponClass
    {
        Blade,          // Cutting damage
        Blunt,          // Impact damage
        Pierce,         // Stabbing damage
        Claw,           // Tearing damage
        Unarmed         // Basic damage
    }

    public enum WeaponMaterial
    {
        Wood,           // Sticks, branches
        Stone,          // Basic stone
        Bone,           // Animal bones
        Antler,         // Deer/elk antlers
        Flint,          // Knapped flint
        Obsidian,       // Volcanic glass
        Organic,        // Natural animal weapons
        Other           // Miscellaneous
    }
    public class Weapon : Gear
    {
        public WeaponClass Class { get; set; }
        public WeaponMaterial Material { get; set; }
        public WeaponType Type { get; set; }
        public double Damage { get; set; }
        public double Accuracy { get; set; }
        public double BlockChance { get; set; }
        public double Craftsmanship { get; set; }

        public Weapon(WeaponType type, WeaponMaterial material, string name = "", int craftsmanship = 50)
            : base(name, quality: craftsmanship)
        {
            Craftsmanship = craftsmanship;
            SetBaseStats(type);
            ApplyMaterialModifier(material);
            ApplyCraftsmanshipModifier();
            Class = GetDamageTypeFromWeaponType(type);

            if (string.IsNullOrWhiteSpace(name))
                Name = $"{GetCraftsmanshipDescription(Craftsmanship)} {GetMaterialDescription(material)} {GetWeaponTypeDescription(type)}";

            Type = type;
            Material = material;
            EquipEffects = [];
        }

        private void ApplyCraftsmanshipModifier()
        {
            // The better crafted the weapon, the more effective it is
            Damage *= (Craftsmanship * 1.5) / 100;
            BlockChance *= Craftsmanship / 100;
        }

        private void ApplyMaterialModifier(WeaponMaterial material)
        {
            switch (material)
            {
                case WeaponMaterial.Wood:
                    Damage *= 0.6;
                    BlockChance *= 0.7;
                    Weight *= 0.5;
                    break;
                case WeaponMaterial.Stone:
                    Damage *= 1.0;
                    BlockChance *= 0.6;
                    Weight *= 1.2;
                    break;
                case WeaponMaterial.Bone:
                    Damage *= 0.8;
                    BlockChance *= 0.8;
                    Weight *= 0.7;
                    break;
                case WeaponMaterial.Antler:
                    Damage *= 0.9;
                    BlockChance *= 0.7;
                    Weight *= 0.8;
                    break;
                case WeaponMaterial.Flint:
                    Damage *= 1.2;
                    BlockChance *= 0.5;
                    Weight *= 1.0;
                    break;
                case WeaponMaterial.Obsidian:
                    Damage *= 1.4;
                    BlockChance *= 0.4;
                    Weight *= 0.9;
                    break;
                case WeaponMaterial.Organic:
                case WeaponMaterial.Other:
                default:
                    // No modifiers for natural/organic materials
                    break;
            }
        }

        private void SetBaseStats(WeaponType type)
        {
            switch (type)
            {
                case WeaponType.Spear:
                    Damage = 8;
                    BlockChance = 0.12;
                    Accuracy = 1.2;
                    Weight = 1.5;
                    break;
                case WeaponType.Club:
                    Damage = 10;
                    BlockChance = 0.08;
                    Accuracy = 0.9;
                    Weight = 2.0;
                    break;
                case WeaponType.HandAxe:
                    Damage = 12;
                    BlockChance = 0.05;
                    Accuracy = 0.8;
                    Weight = 1.8;
                    break;
                case WeaponType.Knife:
                    Damage = 6;
                    BlockChance = 0.02;
                    Accuracy = 1.4;
                    Weight = 0.5;
                    break;
                case WeaponType.SharpStone:
                    Damage = 4;
                    BlockChance = 0.01;
                    Accuracy = 1.1;
                    Weight = 0.3;
                    break;
                case WeaponType.Unarmed:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.5;
                    Weight = 0;
                    break;
                default:
                    Damage = 2;
                    BlockChance = 0.01;
                    Accuracy = 1.0;
                    Weight = 0.5;
                    break;
            }
        }

        public static Weapon GenerateRandomWeapon()
        {
            // Filter out unarmed and natural weapons when generating random weapons
            var validTypes = Enum.GetValues(typeof(WeaponType))
                .Cast<WeaponType>()
                .Where(t => t != WeaponType.Unarmed &&
                            t != WeaponType.Claws &&
                            t != WeaponType.Fangs &&
                            t != WeaponType.Horns)
                .ToArray();

            // Filter out organic and other from random generation
            var validMaterials = Enum.GetValues(typeof(WeaponMaterial))
                .Cast<WeaponMaterial>()
                .Where(m => m != WeaponMaterial.Organic && m != WeaponMaterial.Other)
                .ToArray();

            WeaponMaterial material = validMaterials[Utils.RandInt(0, validMaterials.Length - 1)];
            WeaponType type = validTypes[Utils.RandInt(0, validTypes.Length - 1)];

            int craftsmanship = Utils.RandInt(30, 80); // Primitive technology has limited upper quality

            return new Weapon(type, material, craftsmanship: craftsmanship);
        }

        private static WeaponClass GetDamageTypeFromWeaponType(WeaponType type)
        {
            return type switch
            {
                WeaponType.Knife => WeaponClass.Blade,
                WeaponType.SharpStone => WeaponClass.Blade,
                WeaponType.HandAxe => WeaponClass.Blade,
                WeaponType.Spear => WeaponClass.Pierce,
                WeaponType.Club => WeaponClass.Blunt,
                WeaponType.Unarmed => WeaponClass.Unarmed,
                WeaponType.Claws => WeaponClass.Claw,
                WeaponType.Fangs => WeaponClass.Pierce,
                WeaponType.Horns => WeaponClass.Pierce,
                _ => WeaponClass.Blunt,
            };
        }

        private string GetCraftsmanshipDescription(double craftsmanship)
        {
            return craftsmanship switch
            {
                0 => "Broken",
                < 20 => "Primitive",
                < 40 => "Rough",
                < 60 => "Simple",
                < 80 => "Sturdy",
                < 95 => "Master Crafted",
                <= 100 => "Flawless",
                _ => "Strange"
            };
        }

        private string GetMaterialDescription(WeaponMaterial material)
        {
            return material switch
            {
                WeaponMaterial.Wood => "Wooden",
                WeaponMaterial.Stone => "Stone",
                WeaponMaterial.Bone => "Bone",
                WeaponMaterial.Antler => "Antler",
                WeaponMaterial.Flint => "Flint",
                WeaponMaterial.Obsidian => "Obsidian",
                WeaponMaterial.Organic => "",
                WeaponMaterial.Other => "",
                _ => ""
            };
        }

        private string GetWeaponTypeDescription(WeaponType type)
        {
            return type switch
            {
                WeaponType.Spear => "Spear",
                WeaponType.Club => "Club",
                WeaponType.HandAxe => "Hand Axe",
                WeaponType.Knife => "Knife",
                WeaponType.SharpStone => "Sharp Stone",
                WeaponType.Unarmed => "Fists",
                WeaponType.Claws => "Claws",
                WeaponType.Fangs => "Fangs",
                WeaponType.Horns => "Horns",
                _ => "Tool"
            };
        }
    }
}================================================================================

File: ./Events/EventBus.cs
--------------------------------------------------------------------------------
namespace text_survival.Events;

public interface IGameEvent { }

public interface IEventHandler<T> where T : IGameEvent
{
    void Handle(T gameEvent);
}

public static class EventBus
{
    private static readonly Dictionary<Type, List<object>> _handlers = new();

    public static void Subscribe<T>(IEventHandler<T> handler) where T : IGameEvent
    {
        var eventType = typeof(T);
        if (!_handlers.TryGetValue(eventType, out List<object>? value))
        {
            value = [];
            _handlers[eventType] = value;
        }

        value.Add(handler);
    }

    public static void Publish<T>(T gameEvent) where T : IGameEvent
    {
        var eventType = typeof(T);
        if (_handlers.TryGetValue(eventType, out List<object>? eventHandlers))
        {
            eventHandlers.Cast<IEventHandler<T>>().ToList().ForEach(h => h.Handle(gameEvent));
        }
    }
}================================================================================

File: ./Player.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.Environments;
using text_survival.IO;
using text_survival.Items;
using text_survival.Level;
using text_survival.Magic;
using text_survival.PlayerComponents;


namespace text_survival;

public class Player : Actor
{
    private readonly LocationManager locationManager;
    public readonly InventoryManager inventoryManager;
    public readonly SkillRegistry Skills;
    public readonly List<Spell> _spells = [SpellFactory.Bleeding, SpellFactory.Poison, SpellFactory.MinorHeal];

    public override void Update()
    {
        EffectRegistry.Update();
        var context = new SurvivalContext
        {
            ActivityLevel = 2,
            LocationTemperature = locationManager.CurrentLocation.GetTemperature(),
            ClothingInsulation = inventoryManager.ClothingInsulation,
        };
        Body.Update(TimeSpan.FromMinutes(1), context);
    }
    public void Sleep(int minutes)
    {
        bool fullyRested = Body.Rest(1);
        if (fullyRested)
        {
            Output.Write("You wake up feeling refreshed.\n");
        }

    }
    public override Weapon ActiveWeapon
    {
        get => inventoryManager.Weapon; protected set
        {
            inventoryManager.Weapon = value;
        }
    }

    // Location-related methods
    public override Location CurrentLocation
    {
        get => locationManager.CurrentLocation;
        set => locationManager.CurrentLocation = value;
    }

    public Zone CurrentZone => locationManager.CurrentZone;

    public Player(Location startingLocation) : base("Player", Body.BaselinePlayerStats)
    {
        Name = "Player";
        locationManager = new LocationManager(startingLocation);
        inventoryManager = new(EffectRegistry);
        Skills = new SkillRegistry();
    }

    public void DropItem(Item item)
    {
        inventoryManager.RemoveFromInventory(item);
        locationManager.AddItemToLocation(item);
    }

    public void TakeItem(Item item)
    {
        locationManager.RemoveItemFromLocation(item);

        // QOL - auto equip gear if you can
        if (item is IEquippable equipment && inventoryManager.CanAutoEquip(equipment))
        {
            inventoryManager.Equip(equipment);
            return;
        }
        
        inventoryManager.AddToInventory(item);
    }

    public void UseItem(Item item)
    {
        // handle special logic for each item type
        if (item is FoodItem food)
        {
            string eating_type = food.WaterContent > food.Calories ? "drink" : "eat";
            Output.Write($"You {eating_type} the ", food, "...");
            Body.Consume(food);
        }
        else if (item is ConsumableItem consumable)
        {
            foreach (Effect e in consumable.Effects)
            {
                EffectRegistry.AddEffect(e);
            }
        }
        else if (item is Gear gear)
        {
            Output.WriteLine("You equip the ", gear);
            inventoryManager.Equip(gear);
            foreach (Effect effect in gear.EquipEffects)
            {
                EffectRegistry.AddEffect(effect);
            }
        }

        else if (item is WeaponModifierItem weaponMod)
        {
            if (ModifyWeapon(weaponMod.Damage))
            {
                Output.WriteLine("You use the ", weaponMod, " to modify your ", inventoryManager.Weapon);
            }
            else
            {
                Output.WriteLine("You don't have a weapon equipped to modify.");
                return;
            }
        }
        else if (item is ArmorModifierItem armorMod)
        {
            if (ModifyArmor(armorMod.ValidArmorTypes[0], armorMod.Rating, armorMod.Warmth))
            {
                Output.WriteLine("You use the ", armorMod, " to modify your armor.");
            }
            else
            {
                Output.WriteLine("You don't have any armor you can use that on.");
                return;
            }
        }
        else
        {
            Output.Write("You don't know what to use the ", item, " for...\n");
            return;
        }
        // shared logic for all item types
        if (item.NumUses != -1)
        {
            item.NumUses -= 1;
            if (item.NumUses == 0)
            {
                inventoryManager.RemoveFromInventory(item);
            }
        }
        World.Update(1);
    }

    public bool ModifyWeapon(double damage)
    {
        if (!inventoryManager.IsArmed) return false;

        inventoryManager.Weapon.Damage += damage;
        return true;
    }
    public bool ModifyArmor(EquipSpots spot, double rating = 0, double warmth = 0)
    {
        Armor? armor = inventoryManager.GetArmorInSpot(spot);
        if (armor is null) return false;

        armor.Rating += rating;
        armor.Insulation += warmth;
        return true;
    }

    public void Travel() => locationManager.TravelToAdjacentZone();
}
================================================================================

File: ./Effects/EffectBuilder.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects;

public class EffectBuilder
{
    private string _effectKind = "";
    private string _source = "";
    private string? _targetBodyPart = null;
    private double _severity = 1.0;
    private double _severityChangeRate = 0;
    private List<SurvivalStatsUpdate> _survivalStatsUpdates = [];
    private bool _canHaveMultiple = false;
    private bool _requiresTreatment = false;
    private readonly CapacityModifierContainer _capacityModifiers = new();

    // Hook actions - using lists to allow multiple actions
    private readonly List<Action<Actor>> _onApplyActions = [];
    private readonly List<Action<Actor>> _onUpdateActions = [];
    private readonly List<Action<Actor, double, double>> _onSeverityChangeActions = [];
    private readonly List<Action<Actor>> _onRemoveActions = [];

    public EffectBuilder Named(string effectKind)
    {
        _effectKind = effectKind;
        return this;
    }

    public EffectBuilder From(string source)
    {
        _source = source;
        return this;
    }

    public EffectBuilder Targeting(string? bodyPart)
    {
        _targetBodyPart = bodyPart;
        return this;
    }

    public EffectBuilder WithSeverity(double severity)
    {
        _severity = Math.Clamp(severity, 0, 1);
        return this;
    }

    public EffectBuilder WithHourlySeverityChange(double rate)
    {
        _severityChangeRate = rate;
        return this;
    }

    public EffectBuilder AllowMultiple(bool allow = true)
    {
        _canHaveMultiple = allow;
        return this;
    }

    public EffectBuilder RequiresTreatment(bool requires = true)
    {
        _requiresTreatment = requires;
        return this;
    }

    public EffectBuilder ReducesCapacity(string capacity, double reduction)
    {
        _capacityModifiers.SetCapacityModifier(capacity, -reduction);
        return this;
    }

    public EffectBuilder ModifiesCapacity(string capacity, double multiplier)
    {
        _capacityModifiers.SetCapacityModifier(capacity, multiplier);
        return this;
    }

    public EffectBuilder OnApply(Action<Actor> action)
    {
        _onApplyActions.Add(action);
        return this;
    }

    public EffectBuilder OnUpdate(Action<Actor> action)
    {
        _onUpdateActions.Add(action);
        return this;
    }

    public EffectBuilder OnSeverityChange(Action<Actor, double, double> action)
    {
        _onSeverityChangeActions.Add(action);
        return this;
    }

    public EffectBuilder OnRemove(Action<Actor> action)
    {
        _onRemoveActions.Add(action);
        return this;
    }

    public EffectBuilder WithSurvivalStatsUpdate(SurvivalStatsUpdate minuteUpdate)
    {
        _survivalStatsUpdates.Add(minuteUpdate);
        return this;
    }

    public DynamicEffect Build()
    {
        if (string.IsNullOrWhiteSpace(_effectKind))
        {
            throw new InvalidOperationException("Effect kind is required");
        }

        // Combine multiple actions like ActionBuilder does
        Action<Actor>? combinedOnApply = null;
        if (_onApplyActions.Count > 0)
        {
            combinedOnApply = target => _onApplyActions.ForEach(action => action(target));
        }

        Action<Actor>? combinedOnUpdate = null;
        if (_onUpdateActions.Count > 0)
        {
            combinedOnUpdate = target => _onUpdateActions.ForEach(action => action(target));
        }

        Action<Actor, double, double>? combinedOnSeverityChange = null;
        if (_onSeverityChangeActions.Count > 0)
        {
            combinedOnSeverityChange = (target, oldSeverity, newSeverity) =>
                _onSeverityChangeActions.ForEach(action => action(target, oldSeverity, newSeverity));
        }

        Action<Actor>? combinedOnRemove = null;
        if (_onRemoveActions.Count > 0)
        {
            combinedOnRemove = target => _onRemoveActions.ForEach(action => action(target));
        }

        SurvivalStatsUpdate combinedStatsUpdate = new();
        foreach (var update in _survivalStatsUpdates)
        {
            combinedStatsUpdate = combinedStatsUpdate.Add(update);
        }

        return new DynamicEffect(
            effectKind: _effectKind,
            source: _source,
            targetBodyPart: _targetBodyPart,
            severity: _severity,
            severityChangeRate: _severityChangeRate,
            canHaveMultiple: _canHaveMultiple,
            requiresTreatment: _requiresTreatment,
            capacityModifiers: _capacityModifiers,
            onApply: combinedOnApply,
            onUpdate: combinedOnUpdate,
            onSeverityChange: combinedOnSeverityChange,
            onRemove: combinedOnRemove

        );
    }
}

public static class EffectBuilderExtensions
{
    public static EffectBuilder CreateEffect(string effectKind) => new EffectBuilder().Named(effectKind);

    // Common effect patterns
    public static EffectBuilder Bleeding(this EffectBuilder builder, double damagePerHour)
    {
        return builder
            .Named("Bleeding")
            .WithHourlySeverityChange(-0.05) // Natural clotting
            .AllowMultiple(true)
            .ReducesCapacity(CapacityNames.BloodPumping, 0.2)
            .ReducesCapacity(CapacityNames.Consciousness, 0.1)
            .WithApplyMessage("{target} is bleeding!")
            .WithPeriodicMessage("Blood continues to flow from {target}'s wound...")
            .WhenSeverityDropsBelowWithMessage(0.2, "{target}'s bleeding is slowing")
            .OnUpdate(target =>
            {
                double damage = (damagePerHour / 60.0) * builder.Build().Severity;
                var damageInfo = new DamageInfo
                {
                    Amount = damage,
                    Type = DamageType.Bleed,
                    Source = builder.Build().Source,
                    TargetPartName = builder.Build().TargetBodyPart
                };
                target.Body.Damage(damageInfo);
            });
    }

    public static EffectBuilder Poisoned(this EffectBuilder builder, double damagePerHour)
    {
        return builder
            .Named("Poison")
            .WithHourlySeverityChange(-0.02) // Slow detox
            .AllowMultiple(true)
            .ReducesCapacity(CapacityNames.Consciousness, 0.3)
            .ReducesCapacity(CapacityNames.Manipulation, 0.2)
            .ReducesCapacity(CapacityNames.Moving, 0.2)
            .ReducesCapacity(CapacityNames.BloodPumping, .1)
            .OnUpdate(target =>
            {
                double damage = (damagePerHour / 60.0) * builder.Build().Severity;
                var damageInfo = new DamageInfo
                {
                    Amount = damage,
                    Type = DamageType.Poison,
                    Source = builder.Build().Source
                };
                target.Body.Damage(damageInfo);
            });
    }

    public static EffectBuilder Healing(this EffectBuilder builder, double healPerHour)
    {
        return builder
            .Named("Healing")
            .WithHourlySeverityChange(-1.0 / 60) // Expires in 1 hour by default
            .OnUpdate(target =>
            {
                double heal = (healPerHour / 60.0) * builder.Build().Severity;
                var healInfo = new HealingInfo
                {
                    Amount = heal,
                    Quality = 1.0,
                    Source = builder.Build().Source,
                    TargetPart = builder.Build().TargetBodyPart
                };
                target.Body.Heal(healInfo);
            });
    }

    public static EffectBuilder Temperature(this EffectBuilder builder, TemperatureType type)
    {
        return type switch
        {
            TemperatureType.Hypothermia => builder
                .Named("Hypothermia")
                .RequiresTreatment(true)
                .WithHourlySeverityChange(-.02)
                .ReducesCapacity(CapacityNames.Moving, 0.3)
                .ReducesCapacity(CapacityNames.Manipulation, 0.3)
                .ReducesCapacity(CapacityNames.Consciousness, 0.5)
                .ReducesCapacity(CapacityNames.BloodPumping, 0.2),

            TemperatureType.Hyperthermia => builder
                .Named("Hyperthermia")
                .RequiresTreatment(true)
                .WithHourlySeverityChange(-.01)
                .ReducesCapacity(CapacityNames.Consciousness, 0.5)
                .ReducesCapacity(CapacityNames.Moving, 0.3)
                .ReducesCapacity(CapacityNames.BloodPumping, 0.2),

            TemperatureType.Frostbite => builder
                .Named("Frostbite")
                .WithHourlySeverityChange(-0.02)
                .ReducesCapacity(CapacityNames.Manipulation, 0.5)
                .ReducesCapacity(CapacityNames.Moving, 0.5)
                .ReducesCapacity(CapacityNames.BloodPumping, 0.2),

            _ => builder
        };
    }

    public static EffectBuilder WithDuration(this EffectBuilder builder, int minutes)
    {
        return builder.WithHourlySeverityChange(-1.0 / minutes);
    }

    public static EffectBuilder Permanent(this EffectBuilder builder)
    {
        return builder.WithHourlySeverityChange(0);
    }

    public static EffectBuilder NaturalHealing(this EffectBuilder builder, double rate = -0.05)
    {
        return builder.WithHourlySeverityChange(rate);
    }

    // Message helpers
    public static EffectBuilder WithApplyMessage(this EffectBuilder builder, string message)
    {
        if (string.IsNullOrWhiteSpace(message)) return builder;
        return builder.OnApply(target => IO.Output.WriteLine(message.Replace("{target}", target.Name)));
    }

    public static EffectBuilder WithRemoveMessage(this EffectBuilder builder, string message)
    {
        if (string.IsNullOrWhiteSpace(message)) return builder;
        return builder.OnRemove(target => IO.Output.WriteLine(message.Replace("{target}", target.Name)));
    }

    public static EffectBuilder WithPeriodicMessage(this EffectBuilder builder, string message, double chance = 0.05)
    {
        if (string.IsNullOrWhiteSpace(message)) return builder;
        return builder.OnUpdate(target =>
        {
            if (Utils.DetermineSuccess(chance))
            {
                IO.Output.WriteLine(message.Replace("{target}", target.Name));
            }
        });
    }

    public static EffectBuilder AsInstantEffect(this EffectBuilder builder)
    {
        return builder.WithHourlySeverityChange(-999); // should make it last only one tick
    }

    public static EffectBuilder CausesDehydration(this EffectBuilder builder, double hydrationLossPerMinute)
    {
        return builder.WithSurvivalStatsUpdate(new SurvivalStatsUpdate { Hydration = -hydrationLossPerMinute });
    }

    public static EffectBuilder CausesExhaustion(this EffectBuilder builder, double exhaustionPerMinute)
    {
        return builder.WithSurvivalStatsUpdate(new SurvivalStatsUpdate { Exhaustion = exhaustionPerMinute });
    }

    public static EffectBuilder AffectsTemperature(this EffectBuilder builder, double hourlyTemperatureChange)
    {
        return builder.WithSurvivalStatsUpdate(new SurvivalStatsUpdate()
        {
            Temperature = hourlyTemperatureChange / 60
        });
    }

    public static EffectBuilder GrantsExperience(this EffectBuilder builder, string skillName, int xpPerMinute)
    {
        return builder.OnUpdate(target =>
        {
            if (target is Player player)
            {
                player.Skills.GetSkill(skillName).GainExperience(xpPerMinute);
            }
        });
    }

    public static EffectBuilder AppliesOnRemoval(this EffectBuilder builder, Effect effectToApply)
    {
        return builder.OnRemove(target =>
        {
            target.EffectRegistry.AddEffect(effectToApply);
        });
    }
    public static EffectBuilder WhenSeverityDropsBelow(this EffectBuilder builder, double threshold, Action<Actor> action)
    {
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity < threshold && oldSeverity >= threshold)
            {
                action(target);
            }
        });
    }

    public static EffectBuilder WhenSeverityRisesAbove(this EffectBuilder builder, double threshold, Action<Actor> action)
    {
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity > threshold && oldSeverity <= threshold)
            {
                action(target);
            }
        });
    }

    public static EffectBuilder WhenSeverityDropsBelowWithMessage(this EffectBuilder builder, double threshold, string message)
    {
        if (string.IsNullOrWhiteSpace(message)) return builder;
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity < threshold && oldSeverity >= threshold)
            {
                IO.Output.WriteLine(message.Replace("{target}", target.Name));
            }
        });
    }

    public static EffectBuilder WhenSeverityRisesAboveWithMessage(this EffectBuilder builder, double threshold, string message)
    {
        if (string.IsNullOrWhiteSpace(message)) return builder;
        return builder.OnSeverityChange((target, oldSeverity, newSeverity) =>
        {
            if (newSeverity > threshold && oldSeverity <= threshold)
            {
                IO.Output.WriteLine(message.Replace("{target}", target.Name));
            }
        });
    }
    public static EffectBuilder ClearsEffectType(this EffectBuilder builder, string effectKindToClear)
    {
        return builder.OnApply(target =>
        {
            var effectsToClear = target.EffectRegistry.GetEffectsByKind(effectKindToClear);
            foreach (var effect in effectsToClear)
            {
                target.EffectRegistry.RemoveEffect(effect);
            }
        });
    }
}

public enum TemperatureType
{
    Hypothermia,
    Hyperthermia,
    Frostbite,
    Burn
}
================================================================================

File: ./Effects/DynamicEffect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects;

// Dynamic effect class to support the builder
public class DynamicEffect : Effect
{
    private readonly Action<Actor>? _onApply;
    private readonly Action<Actor>? _onUpdate;
    private readonly Action<Actor, double, double>? _onSeverityChange;
    private readonly Action<Actor>? _onRemove;

    public DynamicEffect(
        string effectKind,
        string source,
        string? targetBodyPart,
        double severity,
        double severityChangeRate,
        bool canHaveMultiple,
        bool requiresTreatment,
        CapacityModifierContainer capacityModifiers,
        Action<Actor>? onApply = null,
        Action<Actor>? onUpdate = null,
        Action<Actor, double, double>? onSeverityChange = null,
        Action<Actor>? onRemove = null,
        SurvivalStatsUpdate? survivalStatsUpdate = null)
        : base(effectKind, source, targetBodyPart, severity, severityChangeRate)
    {
        CanHaveMultiple = canHaveMultiple;
        RequiresTreatment = requiresTreatment;

        CapacityModifiers = capacityModifiers;

        _onApply = onApply;
        _onUpdate = onUpdate;
        _onSeverityChange = onSeverityChange;
        _onRemove = onRemove;
        if (survivalStatsUpdate != null)
        {
            this.SurvivalStatsEffect = survivalStatsUpdate;
        }
    }

    protected override void OnApply(Actor target) => _onApply?.Invoke(target);
    protected override void OnUpdate(Actor target) => _onUpdate?.Invoke(target);
    protected override void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity)
        => _onSeverityChange?.Invoke(target, oldSeverity, updatedSeverity);
    protected override void OnRemove(Actor target) => _onRemove?.Invoke(target);
}================================================================================

File: ./Effects/EffectRegistry.cs
--------------------------------------------------------------------------------

using text_survival.Actors;
using text_survival.Bodies;
using text_survival.IO;
namespace text_survival.Effects;

public class EffectRegistry(Actor owner)
{
    public void AddEffect(Effect effect)
    {
        if (_effects.Contains(effect)) return;

        if (!effect.CanHaveMultiple) // if you can't have multiple then we need to check for existing
        {
            var existingEffect = _effects.FirstOrDefault(e => e.EffectKind == effect.EffectKind);
            if (existingEffect != null) // if we find existing, update, otherwise apply it below
            {
                double newSeverity = Math.Max(existingEffect.Severity, effect.Severity); // for now go with the more severe effect, but maybe we change this to most recent?
                existingEffect.UpdateSeverity(_owner, newSeverity);
                return;
            }
        }
        // if multiple are allowed or if no existing, then it's new -> apply it
        _effects.Add(effect);
        effect.Apply(_owner);
    }

    public void RemoveEffect(Effect effect)
    {
        if (_effects.Remove(effect))
        {
            effect.Remove(_owner);
        }
        else
        {
            Output.WriteWarning("ERROR: couldn't find effect to remove."); // shouldn't hit this, but soft error for now
        }
    }
    public void Update()
    {
        _effects.ForEach(e => e.Update(_owner));
        // Clean up inactive effects
        _effects.RemoveAll(e => !e.IsActive);
    }

    public List<Effect> GetAll() => _effects;
    public List<Effect> GetEffectsByKind(string kind) => [.. _effects.Where(e => e.EffectKind.Equals(kind, StringComparison.CurrentCultureIgnoreCase))];
    public void RemoveEffectsByKind(string kind)
    {
        var effectsToRemove = _effects.Where(e => e.EffectKind.Equals(kind, StringComparison.CurrentCultureIgnoreCase)).ToList();
        foreach (var effect in effectsToRemove)
        {
            RemoveEffect(effect);
        }
    }


    private readonly Actor _owner = owner;
    private List<Effect> _effects = [];
}================================================================================

File: ./Effects/Effect.cs
--------------------------------------------------------------------------------
using text_survival.Actors;
using text_survival.Bodies;

namespace text_survival.Effects
{
    /// <summary>
    /// Manages its own severity state but does apply survival stats changes or capacity modifiers directly
    /// </summary>
    /// <param name="effectKind"></param>
    /// <param name="source"></param>
    /// <param name="targetBodyPart"></param>
    /// <param name="severity"></param>
    /// <param name="hourlySeverityChange"></param>
    public abstract class Effect(string effectKind, string source, string? targetBodyPart = null, double severity = 1, double hourlySeverityChange = 0)
    {
        #region Properties
        public string EffectKind { get; protected set; } = effectKind;
        public string Source { get; } = source;
        public string? TargetBodyPart { get; set; } = targetBodyPart;
        public bool CanHaveMultiple { get; protected set; } = false;
        public bool IsActive { get; protected set; } = true;
        public double Severity { get; protected set; } = severity; // multiplier for survival and capacity effects
        public double hourlySeverityChange { get; protected set; } = hourlySeverityChange;
        public bool RequiresTreatment { get; protected set; } = false;
        public CapacityModifierContainer CapacityModifiers { get; set; } = new(); // gets applied in body
        public SurvivalStatsUpdate SurvivalStatsEffect { get; set; } = new(); // gets applied in survival processor
        // public List<TreatmentOption> TreatmentOptions {get;}
        #endregion

        #region  core algorithm methods - typically don't override
        /// <summary>
        /// Gets called once by the effect registry, you probably shouldn't be calling this directly.
        /// </summary>
        public void Apply(Actor target)
        {
            IsActive = true;
            OnApply(target);
        }

        /// <summary>
        /// Gets called every minute. The main algorithm which calls the hook methods.
        /// If IsActive is false do nothing, otherwise call each hook in this order
        /// 1. OnUpdate
        /// 2. OnUpdateSeverity if SeverityChangeRate <> 0
        /// 3. OnRemove if severity <= 0
        /// </summary>
        public void Update(Actor target)
        {
            if (!IsActive) return;

            OnUpdate(target);

            if (!RequiresTreatment && hourlySeverityChange > 0)
            {
                double minuteChange = hourlySeverityChange / 60;
                UpdateSeverity(target, minuteChange);
            }

            if (Severity <= 0)
            {
                Remove(target);
                return;
            }
        }

        /// <summary>
        /// Gets called when the severity reaches zero and automatically removes the effect from the target
        /// </summary>
        public void Remove(Actor target)
        {
            if (!IsActive) return;
            OnRemove(target);
            IsActive = false;
        }

        /// <summary>
        /// Gets called every minute if the severity change rate is not 0
        /// </summary>
        public virtual void UpdateSeverity(Actor target, double severityChange)
        {
            if (!IsActive) return;

            double oldSeverity = Severity;

            Severity = Math.Clamp(Severity + severityChange, 0, 1);

            if (Math.Abs(oldSeverity - Severity) > 0.01)
            {
                OnSeverityChange(target, oldSeverity, Severity);
            }
        }
        #endregion


        #region Hook Methods
        // hook methods that can be implemented by sub classes

        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called once when the effect is applied to the target
        /// </summary>
        protected virtual void OnApply(Actor target) { }
        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called every minute when the effect is active
        /// </summary>
        protected virtual void OnUpdate(Actor target) { }
        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called whenever the severity changes
        /// </summary>
        protected virtual void OnSeverityChange(Actor target, double oldSeverity, double updatedSeverity) { }
        /// <summary>
        /// Event meant to be overwritten by implementing classes that gets called once when the effect is removed from the target
        /// </summary>
        protected virtual void OnRemove(Actor target) { }

        #endregion

        #region UI methods
        public string GetSeverityDescription()
        {
            if (Severity < 0.3f) return "Minor";
            if (Severity < 0.7f) return "Moderate";
            if (Severity < 0.9f) return "Severe";
            return "Critical";
        }
        public virtual string Describe()
        {
            string severityDesc = GetSeverityDescription();
            string locationDesc = TargetBodyPart != null ? $" on {TargetBodyPart}" : "";
            return $"{severityDesc} {EffectKind}{locationDesc}";
        }
        #endregion
    }
}================================================================================

File: ./Effects/EffectFactory.cs
--------------------------------------------------------------------------------
//todo================================================================================

File: ./CombatUtils.cs
--------------------------------------------------------------------------------
﻿using text_survival.Actors;
using text_survival.Bodies;
using text_survival.Environments;

namespace text_survival;

public static class CombatUtils
{
    public static bool SpeedCheck(Player player, Actor enemy)
    {
        double playerCheck = CalcSpeedCheck(player);
        double enemyCheck = CalcSpeedCheck(enemy);

        return playerCheck >= enemyCheck;
    }

    public static Npc? GetFastestHostileNpc(Location location)
    {
        double fastestCheck = 0;
        Npc? fastestNpc = null;
        foreach (Npc npc in location.Npcs)
        {
            if (npc == fastestNpc) continue;
            if (!npc.IsAlive) continue;
            if (!npc.IsHostile) continue;

            fastestNpc ??= npc;

            var currentNpcCheck = CalcSpeedCheck(npc);
            if (currentNpcCheck > fastestCheck)
            {
                fastestNpc = npc;
                fastestCheck = currentNpcCheck;
            }
        }
        return fastestNpc;
    }

    public static double CalcSpeedCheck(Actor actor)
    {
        double athleticsBonus = 0;
        if (actor is Player player)
        {
            athleticsBonus = player.Skills.Reflexes.Level;
        }
        return AbilityCalculator.CalculateSpeed(actor.Body) + athleticsBonus;
    }
}
================================================================================

File: ./Survival/SurvivalProcessor.cs
--------------------------------------------------------------------------------
using System.Net.Http.Headers;
using text_survival.Bodies;
using text_survival.Effects;
using text_survival.IO;

namespace text_survival.Survival;



public static class SurvivalProcessor
{
	private const double BASE_EXHAUSTION_RATE = 1;
	public const double MAX_ENERGY_MINUTES = 960.0F; // minutes (16 hours)
	private const double BASE_DEHYDRATION_RATE = 4000F / (24F * 60F); // mL per minute
	public const double MAX_HYDRATION = 4000.0F; // mL
	public const double MAX_CALORIES = 2000.0; // Maximum calories stored before fat conversion

	private const double BaseBodyTemperature = 98.6F;
	private const double SevereHypothermiaThreshold = 89.6; // °F
	private const double HypothermiaThreshold = 95.0;  // °F
	private const double ShiveringThreshold = 97.0; // °F
	private const double HyperthermiaThreshold = 100.0; // °F  
	private const double SweatingThreshold = 99.00; // °F

	private enum TemperatureEnum
	{
		Warm,
		Cool,
		Cold,
		Freezing,
		Hot,
	}


	public static SurvivalProcessorResult Process(SurvivalData data, int minutesElapsed, List<Effect> activeEffects)
	{
		data.Energy = Math.Max(0, data.Energy - (BASE_EXHAUSTION_RATE * minutesElapsed));
		data.Hydration = Math.Max(0, data.Hydration - (BASE_DEHYDRATION_RATE * minutesElapsed));

		// Hunger update
		// todo, actually update with activity level
		// todo have this account for temp too
		double currentMetabolism = GetCurrentMetabolism(data);
		double caloriesBurned = currentMetabolism / 24 / 60 * minutesElapsed;
		bool wasStarving = data.Calories <= 0;
		data.Calories -= caloriesBurned;

		data.Temperature += caloriesBurned / 24000;

		if (data.Calories <= 0)
		{
			double excessCalories = -data.Calories;
			data.Calories = 0;
			// EventBus.Publish(new StarvingEvent(owner, excessCalories, isNew: !wasStarving));
		}
		//else if (wasStarving) // wasStarving but is no longer // TODO this will never be hit anymore, move to eat method
		//{
		//EventBus.Publish(new StoppedStarvingEvent(owner));
		//}

		// Temperature Update
		TemperatureEnum oldTemperature = GetTemperatureEnum(data.Temperature); // todo update message when temp changes
		double naturalInsulation = Math.Clamp(data.ColdResistance, 0, 1); // 0-1
		double totalInsulation = Math.Clamp(naturalInsulation + data.equipmentInsulation, 0, 0.95);

		double skinTemp = data.Temperature - 8.4;
		double tempDifferential = data.environmentalTemp - skinTemp;
		double insulatedDiff = tempDifferential * (1 - totalInsulation);
		double tempDiffMagnitude = Math.Abs(insulatedDiff);
		double baseRate = 1.0 / 120.0;
		double exponentialFactor = 1.0 + (tempDiffMagnitude / 40.0);
		double rate = baseRate * exponentialFactor;

		// double surfaceAreaFactor = Math.Pow(body.Weight / 70.0, -0.2);

		double tempChange = insulatedDiff * rate;
		data.Temperature += tempChange;
		SurvivalProcessorResult result = new(data);

		HandleActiveEffects(data, activeEffects);

		AddTemperatureEffects(data, oldTemperature, result);

		return result;
	}

	private static double GetCurrentMetabolism(SurvivalData data)
	{
		// Base BMR uses the Harris-Benedict equation (simplified)
		double bmr = 370 + (21.6 * data.BodyStats.MuscleWeight) + (6.17 * data.BodyStats.FatWeight); // bigger creature more calories
		bmr *= 0.7 + (0.3 * data.BodyStats.HealthPercent); // Injured bodies need more energy to heal
		return bmr * data.activityLevel;
	}


	private static void AddTemperatureEffects(SurvivalData data, TemperatureEnum oldTemperature, SurvivalProcessorResult result)
	{
		List<Effect> effects = [];
		TemperatureEnum temperatureStage = GetTemperatureEnum(data.Temperature);

		// Handle cold effects
		if (temperatureStage == TemperatureEnum.Cold || temperatureStage == TemperatureEnum.Freezing)
		{
			bool tempChanged = oldTemperature == temperatureStage;
			GenerateColdEffects(data, tempChanged, result);
		}

		else if (temperatureStage == TemperatureEnum.Hot)
		{
			double severity = Math.Clamp((data.Temperature - HyperthermiaThreshold) / 10.0, 0.01, 1.00);

			// Apply to whole body (will handle stacking through EffectRegistry)
			var hyperthermia = EffectBuilderExtensions
				.CreateEffect("Heat Exposure")
				.Temperature(TemperatureType.Hyperthermia)
				.WithSeverity(severity)
				.Build(); // todo add messages
			effects.Add(hyperthermia);
		}

		if (data.Temperature > SweatingThreshold)
		{
			// Calculate severity based on temperature
			double severity = Math.Clamp((data.Temperature - SweatingThreshold) / 4.0, 0.10, 1.00);

			// Apply to whole body (will handle stacking through EffectRegistry)
			var sweatingEffect = EffectBuilderExtensions
				.CreateEffect("Sweating")
				.CausesDehydration(1000 / 60 * severity) // up to 1L per hour
				.WithSeverity(severity)
				.Build(); // todo add notification messages
			effects.Add(sweatingEffect);
		}

		result.Effects.AddRange(effects);
	}

	private static void HandleActiveEffects(SurvivalData data, List<Effect> effects)
	{
		SurvivalStatsUpdate update = new();
		foreach (Effect effect in effects)
		{
			var effectWithSeverity = effect.SurvivalStatsEffect.ApplyMultiplier(effect.Severity);
			update = update.Add(effectWithSeverity);
		}
		data.Calories += update.Calories;
		data.Hydration += update.Hydration;
		data.Temperature += update.Temperature;
		data.Energy -= update.Exhaustion;
	}


	private static void GenerateColdEffects(SurvivalData data, bool isNewTemperatureChange, SurvivalProcessorResult result)
	{
		// Generate cold messages
		if (isNewTemperatureChange && data.IsPlayer)
		{
			result.Messages.Add("You are staring to feel cold.");
		}
		else if (Utils.DetermineSuccess(Config.NOTIFY_EXISTING_STATUS_CHANCE))
		{
			result.Messages.Add("You are still feeling cold.");
		}

		// Generate shivering effect if cold enough
		if (data.Temperature < ShiveringThreshold)
		{
			double intensity = (ShiveringThreshold - data.Temperature) / 5.0;
			intensity = Math.Clamp(intensity, 0.01, 1.0);

			var shiveringEffect = EffectBuilderExtensions
				.CreateEffect("Shivering")
				.WithSeverity(intensity)
				.ReducesCapacity(CapacityNames.Manipulation, .2)
				.AllowMultiple(false)
				.AffectsTemperature(3) // at highest rate increases 
				.WithHourlySeverityChange(-2) // resolves in 30 min by default
				.Build();
			result.Effects.Add(shiveringEffect);
		}

		// Generate hypothermia effect if cold enough
		if (data.Temperature < HypothermiaThreshold)
		{
			double severity = Math.Clamp((HypothermiaThreshold - data.Temperature) / 10.0, 0.01, 1.0);

			string applicationMessage;
			string removalMessage;
			if (data.IsPlayer)
			{
				applicationMessage = $"Your core is getting very cold, you feel like you're starting to get hypothermia... Severity = {severity}";
				removalMessage = $"You're warming up enough and starting to feel better, the hypothermia has passed...";
			}
			else
			{
				applicationMessage = "";// $"DEBUG: {{target}} has hypothermia. Severity = {severity}";
				removalMessage = "";// "DEBUG: {target} no longer has hypothermia.";
			}

			var hypothermia = EffectBuilderExtensions
				.CreateEffect("Hypothermia")
				.Temperature(TemperatureType.Hypothermia)
				.WithApplyMessage(applicationMessage)
				.WithSeverity(severity)
				.AllowMultiple(false)
				.WithRemoveMessage(removalMessage)
				.Build();

			result.Effects.Add(hypothermia);
		}

		// Generate frostbite effects if severely cold
		if (data.Temperature < SevereHypothermiaThreshold)
		{
			// Note: This creates frostbite effects for arms and legs
			// The caller will need to apply these to the appropriate body parts
			var extremityNames = new[] { "Left Arm", "Right Arm", "Left Leg", "Right Leg" };

			foreach (var extremityName in extremityNames)
			{
				double severity = Math.Clamp((SevereHypothermiaThreshold - data.Temperature) / 5.0, 0.01, 1.0);

				string applicationMessage;
				string removalMessage;

				if (data.IsPlayer)
				{
					applicationMessage = $"Your {extremityName.ToLower()} is getting dangerously cold, you're developing frostbite! Severity = {severity}";
					removalMessage = $"The feeling is returning to your {extremityName.ToLower()}, the frostbite is healing...";
				}
				else
				{
					applicationMessage = ""; //$"DEBUG: {{target}} has frostbite on {extremityName}. Severity = {severity}";
					removalMessage = ""; //$"DEBUG: {{target}} no longer has frostbite on {extremityName}.";
				}

				var frostbite = EffectBuilderExtensions
					.CreateEffect("Frostbite")
					.Temperature(TemperatureType.Frostbite)
					.WithApplyMessage(applicationMessage)
					.WithSeverity(severity)
					.AllowMultiple(true)
					.WithRemoveMessage(removalMessage)
					.Targeting(extremityName)
					.Build();

				result.Effects.Add(frostbite);
			}
		}
	}


	private static TemperatureEnum GetTemperatureEnum(double temperature)
	{
		if (temperature < SevereHypothermiaThreshold)
		{
			return TemperatureEnum.Freezing;
		}
		else if (temperature >= SevereHypothermiaThreshold && temperature < HypothermiaThreshold)
		{
			return TemperatureEnum.Cold;
		}
		else if (temperature >= HypothermiaThreshold && temperature < BaseBodyTemperature)
		{
			return TemperatureEnum.Cool;
		}
		else if (temperature >= BaseBodyTemperature && temperature <= HyperthermiaThreshold)
		{
			return TemperatureEnum.Warm;
		}
		else // temperature > HyperthermiaThreshold
		{
			return TemperatureEnum.Hot;
		}
	}

	public static SurvivalProcessorResult Sleep(SurvivalData data, int minutes)
	{
		// starve at 1/2 rate - handled in GetCurrentMetabolism
		data.activityLevel = .5;
		// rest restores exhaustion at 2x the rate that you gain it while awake, so 16 hours of wakefulness creates only 8 hours of sleep debt
		data.Energy = Math.Min(1, data.Energy + (BASE_EXHAUSTION_RATE * 2 * minutes));
		data.Hydration = Math.Max(0, data.Hydration - (BASE_DEHYDRATION_RATE * .7 * minutes)); // dehydrate at reduced rate while asleep
		data.Calories = data.Calories -= GetCurrentMetabolism(data) / 24 / 60 * minutes;
		return new SurvivalProcessorResult(data);
	}

}
================================================================================

File: ./Survival/SurvivalProcessorResult.cs
--------------------------------------------------------------------------------
using text_survival.Effects;

namespace text_survival.Survival;


public class SurvivalProcessorResult(SurvivalData data)
{
	public SurvivalData Data { get; set; } = data;
	public List<Effect> Effects { get; set; } = [];
	public List<string> Messages { get; set; } = [];
}

================================================================================

File: ./Survival/SurvivalData.cs
--------------------------------------------------------------------------------

using text_survival.Bodies;

namespace text_survival.Survival;

public class SurvivalData
{
	// Primary stats
	public double Calories;
	public double Hydration;
	public double Energy;
	public double Temperature;
	public double ColdResistance;

	// body stats
	public BodyStats BodyStats;

	// Secondary stats
	public double equipmentInsulation;
	public double environmentalTemp;
	public double activityLevel;
	public bool IsPlayer;
}
================================================================================

File: ./Survival/SurvivalStatsUpdate.cs
--------------------------------------------------------------------------------
namespace text_survival;

public class SurvivalStatsUpdate
{
    public double Temperature;
    public double Calories;
    public double Hydration;
    public double Exhaustion;

    /// <summary>
    /// Returns a new SurvivalStatsUpdate with the update added
    /// </summary>
    /// <param name="update"></param>
    /// <returns></returns>
    public SurvivalStatsUpdate Add(SurvivalStatsUpdate update)
    {
        return new SurvivalStatsUpdate
        {
            Calories = this.Calories + update.Calories,
            Temperature = this.Temperature + update.Temperature,
            Hydration = this.Hydration + update.Hydration,
            Exhaustion = this.Exhaustion + update.Exhaustion,
        };
    }

    /// <summary>
    /// returns a new Survival stats update with the multiplier applied
    /// </summary>
    /// <param name="multiplier"></param>
    /// <returns></returns>
    public SurvivalStatsUpdate ApplyMultiplier(double multiplier)
    {
        return new SurvivalStatsUpdate
        {
            Calories = this.Calories * multiplier,
            Temperature = this.Temperature * multiplier,
            Hydration = this.Hydration * multiplier,
            Exhaustion = this.Exhaustion * multiplier
        };
    }
}================================================================================

File: ./Program.cs
--------------------------------------------------------------------------------
﻿using text_survival.Environments;
using text_survival.Events;
using text_survival.IO;
using text_survival.Items;
using text_survival.Actions;
using text_survival.Crafting;

namespace text_survival
{
    public class Program
    {
        static void Main()
        {
            Output.SleepTime = 500;
            Output.WriteLine();
            Output.WriteLine();
            Output.WriteLine();
            Output.WriteLine();
            Output.WriteLine();
            Output.WriteDanger("You wake up in the forest, with no memory of how you got there.");
            Output.WriteDanger("Light snow is falling, and you feel the air getting colder.");
            Output.WriteDanger("You need to find shelter, food, and water to survive.");
            Output.WriteLine();
            Output.SleepTime = 10;
            Zone zone = ZoneFactory.MakeForestZone();
            Container oldBag = new Container("Old bag", 10);
            Location startingArea = new Location("Clearing", zone);
            oldBag.Add(ItemFactory.MakeKnife());
            oldBag.Add(ItemFactory.MakeMoccasins());
            oldBag.Add(ItemFactory.MakeLeatherTunic());
            oldBag.Add(ItemFactory.MakeLeatherPants());
            startingArea.Containers.Add(oldBag);
            zone.Locations.Add(startingArea);
            Player player = new Player(startingArea);
            World.Player = player;
            
            var defaultAction = ActionFactory.Common.MainMenu();
            var context = new GameContext(player)
            {
                CraftingManager = new CraftingSystem(player)
            }; 
            while (true)
            {
                defaultAction.Execute(context);
            }
        }
    }
}================================================================================

